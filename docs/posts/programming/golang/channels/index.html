<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Channels Concurrency Work-Around | CctoctoFX</title><meta name=keywords content><meta name=description content='记录了一些channels常见的场景，以及自己的一些感受：


使用通道进行异步和并发编程是简单和惬意的；


通道同步技术比被很多其它语言采用的其它同步方案（比如角色模型和async/await模式）有着更多的应用场景和更多的使用变种。
通道作为同步手段，并非在任何情况下都是最佳的同步技术，本文也会补充原子操作和sync包内其他的技术作为参考。


将通道用做future/promise
很多其它流行语言支持future/promise来实现异步（并发）编程。 Future/promise常常用在请求/回应场合。
返回单向接收通道做为函数返回结果
在下面这个例子中，sumSquares函数调用的两个实参请求并发进行。 每个通道读取操作将阻塞到请求返回结果为止。 两个实参总共需要大约3秒钟（而不是6秒钟）准备完毕（以较慢的一个为准）。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29


package main

import (
	"time"
	"math/rand"
	"fmt"
)

func longTimeRequest() <-chan int32 {
	r := make(chan int32)

	go func() {
		time.Sleep(time.Second * 3) // 模拟一个工作负载
		r <- rand.Int31n(100)
	}()

	return r
}

func sumSquares(a, b int32) int32 {
	return a*a + b*b
}

func main() {
	rand.Seed(time.Now().UnixNano())

	a, b := longTimeRequest(), longTimeRequest()
	fmt.Println(sumSquares(<-a, <-b))
}


将单向发送通道类型用做函数实参
和上例一样，在下面这个例子中，sumSquares函数调用的两个实参的请求也是并发进行的。 和上例不同的是longTimeRequest函数接收一个单向发送通道类型参数而不是返回一个单向接收通道结果。'><meta name=author content="Me"><link rel=canonical href=https://pillumina.github.io/posts/programming/golang/channels/><link crossorigin=anonymous href=/assets/css/stylesheet.9d388901283682bb45dd422fcaa0d0a2054a3c8ff47c9cc6b2baab15508b1b90.css integrity="sha256-nTiJASg2grtF3UIvyqDQogVKPI/0fJzGsrqrFVCLG5A=" rel="preload stylesheet" as=style><link rel=icon href=https://pillumina.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pillumina.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pillumina.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://pillumina.github.io/apple-touch-icon.png><link rel=mask-icon href=https://pillumina.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://pillumina.github.io/posts/programming/golang/channels/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>const config={startOnLoad:!0,theme:"neutral",themeVariables:{lineColor:"#0f0f0f"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(0[0],document.querySelectorAll(".language-mermaid"))}</script><link rel=stylesheet href=/css/custom.min.7ca191baf9a98cba901e2771d1f5485af2e39a950ce60a50254e72e853eb373d.css integrity="sha256-fKGRuvmpjLqQHidx0fVIWvLjmpUM5gpQJU5y6FPrNz0="><script>document.addEventListener("DOMContentLoaded",function(){const t=document.querySelectorAll("h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]"),n=document.querySelectorAll(".toc a");if(t.length===0||n.length===0)return;const s={};t.forEach(e=>{s[e.id]=e.offsetTop});function i(){const t=window.scrollY+100;let e="";for(const[n,o]of Object.entries(s))if(t>=o)e=n;else break;return e}function o(){const e=i();if(n.forEach(e=>{e.classList.remove("active")}),e){const t=document.querySelector(`.toc a[href="#${e}"]`);t&&t.classList.add("active")}}let e=!1;window.addEventListener("scroll",function(){e||(window.requestAnimationFrame(function(){o(),e=!1}),e=!0)}),o()})</script><meta property="og:url" content="https://pillumina.github.io/posts/programming/golang/channels/"><meta property="og:site_name" content="CctoctoFX"><meta property="og:title" content="Channels Concurrency Work-Around"><meta property="og:description" content='记录了一些channels常见的场景，以及自己的一些感受：
使用通道进行异步和并发编程是简单和惬意的；
通道同步技术比被很多其它语言采用的其它同步方案（比如角色模型和async/await模式）有着更多的应用场景和更多的使用变种。
通道作为同步手段，并非在任何情况下都是最佳的同步技术，本文也会补充原子操作和sync包内其他的技术作为参考。
将通道用做future/promise 很多其它流行语言支持future/promise来实现异步（并发）编程。 Future/promise常常用在请求/回应场合。
返回单向接收通道做为函数返回结果 在下面这个例子中，sumSquares函数调用的两个实参请求并发进行。 每个通道读取操作将阻塞到请求返回结果为止。 两个实参总共需要大约3秒钟（而不是6秒钟）准备完毕（以较慢的一个为准）。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( "time" "math/rand" "fmt" ) func longTimeRequest() <-chan int32 { r := make(chan int32) go func() { time.Sleep(time.Second * 3) // 模拟一个工作负载 r <- rand.Int31n(100) }() return r } func sumSquares(a, b int32) int32 { return a*a + b*b } func main() { rand.Seed(time.Now().UnixNano()) a, b := longTimeRequest(), longTimeRequest() fmt.Println(sumSquares(<-a, <-b)) } 将单向发送通道类型用做函数实参 和上例一样，在下面这个例子中，sumSquares函数调用的两个实参的请求也是并发进行的。 和上例不同的是longTimeRequest函数接收一个单向发送通道类型参数而不是返回一个单向接收通道结果。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-22T11:22:18+08:00"><meta property="article:modified_time" content="2020-12-22T11:22:18+08:00"><meta property="og:image" content="https://pillumina.github.io/imgs/icon_head.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://pillumina.github.io/imgs/icon_head.png"><meta name=twitter:title content="Channels Concurrency Work-Around"><meta name=twitter:description content='记录了一些channels常见的场景，以及自己的一些感受：


使用通道进行异步和并发编程是简单和惬意的；


通道同步技术比被很多其它语言采用的其它同步方案（比如角色模型和async/await模式）有着更多的应用场景和更多的使用变种。
通道作为同步手段，并非在任何情况下都是最佳的同步技术，本文也会补充原子操作和sync包内其他的技术作为参考。


将通道用做future/promise
很多其它流行语言支持future/promise来实现异步（并发）编程。 Future/promise常常用在请求/回应场合。
返回单向接收通道做为函数返回结果
在下面这个例子中，sumSquares函数调用的两个实参请求并发进行。 每个通道读取操作将阻塞到请求返回结果为止。 两个实参总共需要大约3秒钟（而不是6秒钟）准备完毕（以较慢的一个为准）。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29


package main

import (
	"time"
	"math/rand"
	"fmt"
)

func longTimeRequest() <-chan int32 {
	r := make(chan int32)

	go func() {
		time.Sleep(time.Second * 3) // 模拟一个工作负载
		r <- rand.Int31n(100)
	}()

	return r
}

func sumSquares(a, b int32) int32 {
	return a*a + b*b
}

func main() {
	rand.Seed(time.Now().UnixNano())

	a, b := longTimeRequest(), longTimeRequest()
	fmt.Println(sumSquares(<-a, <-b))
}


将单向发送通道类型用做函数实参
和上例一样，在下面这个例子中，sumSquares函数调用的两个实参的请求也是并发进行的。 和上例不同的是longTimeRequest函数接收一个单向发送通道类型参数而不是返回一个单向接收通道结果。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://pillumina.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming","item":"https://pillumina.github.io/posts/programming/"},{"@type":"ListItem","position":3,"name":"Golang","item":"https://pillumina.github.io/posts/programming/golang/"},{"@type":"ListItem","position":4,"name":"Channels Concurrency Work-Around","item":"https://pillumina.github.io/posts/programming/golang/channels/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Channels Concurrency Work-Around","name":"Channels Concurrency Work-Around","description":"记录了一些channels常见的场景，以及自己的一些感受：\n使用通道进行异步和并发编程是简单和惬意的；\n通道同步技术比被很多其它语言采用的其它同步方案（比如角色模型和async/await模式）有着更多的应用场景和更多的使用变种。\n通道作为同步手段，并非在任何情况下都是最佳的同步技术，本文也会补充原子操作和sync包内其他的技术作为参考。\n将通道用做future/promise 很多其它流行语言支持future/promise来实现异步（并发）编程。 Future/promise常常用在请求/回应场合。\n返回单向接收通道做为函数返回结果 在下面这个例子中，sumSquares函数调用的两个实参请求并发进行。 每个通道读取操作将阻塞到请求返回结果为止。 两个实参总共需要大约3秒钟（而不是6秒钟）准备完毕（以较慢的一个为准）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;time\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;fmt\u0026#34; ) func longTimeRequest() \u0026lt;-chan int32 { r := make(chan int32) go func() { time.Sleep(time.Second * 3) // 模拟一个工作负载 r \u0026lt;- rand.Int31n(100) }() return r } func sumSquares(a, b int32) int32 { return a*a + b*b } func main() { rand.Seed(time.Now().UnixNano()) a, b := longTimeRequest(), longTimeRequest() fmt.Println(sumSquares(\u0026lt;-a, \u0026lt;-b)) } 将单向发送通道类型用做函数实参 和上例一样，在下面这个例子中，sumSquares函数调用的两个实参的请求也是并发进行的。 和上例不同的是longTimeRequest函数接收一个单向发送通道类型参数而不是返回一个单向接收通道结果。\n","keywords":[],"articleBody":"记录了一些channels常见的场景，以及自己的一些感受：\n使用通道进行异步和并发编程是简单和惬意的；\n通道同步技术比被很多其它语言采用的其它同步方案（比如角色模型和async/await模式）有着更多的应用场景和更多的使用变种。\n通道作为同步手段，并非在任何情况下都是最佳的同步技术，本文也会补充原子操作和sync包内其他的技术作为参考。\n将通道用做future/promise 很多其它流行语言支持future/promise来实现异步（并发）编程。 Future/promise常常用在请求/回应场合。\n返回单向接收通道做为函数返回结果 在下面这个例子中，sumSquares函数调用的两个实参请求并发进行。 每个通道读取操作将阻塞到请求返回结果为止。 两个实参总共需要大约3秒钟（而不是6秒钟）准备完毕（以较慢的一个为准）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \"time\" \"math/rand\" \"fmt\" ) func longTimeRequest() \u003c-chan int32 { r := make(chan int32) go func() { time.Sleep(time.Second * 3) // 模拟一个工作负载 r \u003c- rand.Int31n(100) }() return r } func sumSquares(a, b int32) int32 { return a*a + b*b } func main() { rand.Seed(time.Now().UnixNano()) a, b := longTimeRequest(), longTimeRequest() fmt.Println(sumSquares(\u003c-a, \u003c-b)) } 将单向发送通道类型用做函数实参 和上例一样，在下面这个例子中，sumSquares函数调用的两个实参的请求也是并发进行的。 和上例不同的是longTimeRequest函数接收一个单向发送通道类型参数而不是返回一个单向接收通道结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \"time\" \"math/rand\" \"fmt\" ) func longTimeRequest(r chan\u003c- int32) { time.Sleep(time.Second * 3) // 模拟一个工作负载 r \u003c- rand.Int31n(100) } func sumSquares(a, b int32) int32 { return a*a + b*b } func main() { rand.Seed(time.Now().UnixNano()) ra, rb := make(chan int32), make(chan int32) go longTimeRequest(ra) go longTimeRequest(rb) fmt.Println(sumSquares(\u003c-ra, \u003c-rb)) } 对于上面这个特定的例子，我们可以只使用一个通道来接收回应结果，因为两个参数的作用是对等的。\n1 2 3 4 5 6 7 8 ... results := make(chan int32, 2) // 缓冲与否不重要 go longTimeRequest(results) go longTimeRequest(results) fmt.Println(sumSquares(\u003c-results, \u003c-results)) } 这可以看作是后面将要提到的数据聚合的一个应用。\n采用最快回应 本用例可以看作是上例中只使用一个通道变种的增强。\n有时候，一份数据可能同时从多个数据源获取。这些数据源将返回相同的数据。 因为各种因素，这些数据源的回应速度参差不一，甚至某个特定数据源的多次回应速度之间也可能相差很大。 同时从多个数据源获取一份相同的数据可以有效保障低延迟。我们只需采用最快的回应并舍弃其它较慢回应。\n注意：如果有N个数据源，为了防止被舍弃的回应对应的协程永久阻塞，则传输数据用的通道必须为一个容量至少为N-1的缓冲通道。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \"fmt\" \"time\" \"math/rand\" ) func source(c chan\u003c- int32) { ra, rb := rand.Int31(), rand.Intn(3) + 1 // 睡眠1秒/2秒/3秒 time.Sleep(time.Duration(rb) * time.Second) c \u003c- ra } func main() { rand.Seed(time.Now().UnixNano()) startTime := time.Now() c := make(chan int32, 5) // 必须用一个缓冲通道 for i := 0; i \u003c cap(c); i++ { go source(c) } rnd := \u003c- c // 只有第一个回应被使用了 fmt.Println(time.Since(startTime)) fmt.Println(rnd) } “采用最快回应”用例还有一些其它实现方式，本文后面将会谈及。\n更多“请求/回应”用例变种 做为函数参数和返回结果使用的通道可以是缓冲的，从而使得请求协程不需阻塞到它所发送的数据被接收为止。\n有时，一个请求可能并不保证返回一份有效的数据。对于这种情形，我们可以使用一个形如struct{v T; err error}的结构体类型或者一个空接口类型做为通道的元素类型以用来区分回应的值是否有效。\n有时，一个请求可能需要比预期更长的用时才能回应，甚至永远都得不到回应。 我们可以使用本文后面将要介绍的超时机制来应对这样的情况。\n有时，回应方可能会不断地返回一系列值，这也同时属于后面将要介绍的数据流的一个用例。\n使用通道实现通知 通知可以被看作是特殊的请求/回应用例。在一个通知用例中，我们并不关心回应的值，我们只关心回应是否已发生。 所以我们常常使用空结构体类型struct{}来做为通道的元素类型，因为空结构体类型的尺寸为零，能够节省一些内存（虽然常常很少量）。\n向一个通道发送一个值来实现单对单通知 我们已知道，如果一个通道中无值可接收，则此通道上的下一个接收操作将阻塞到另一个协程发送一个值到此通道为止。 所以一个协程可以向此通道发送一个值来通知另一个等待着从此通道接收数据的协程。\n在下面这个例子中，通道done被用来做为一个信号通道来实现单对单通知。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \"crypto/rand\" \"fmt\" \"os\" \"sort\" ) func main() { values := make([]byte, 32 * 1024 * 1024) if _, err := rand.Read(values); err != nil { fmt.Println(err) os.Exit(1) } done := make(chan struct{}) // 也可以是缓冲的 // 排序协程 go func() { sort.Slice(values, func(i, j int) bool { return values[i] \u003c values[j] }) done \u003c- struct{}{} // 通知排序已完成 }() // 并发地做一些其它事情... \u003c- done // 等待通知 fmt.Println(values[0], values[len(values)-1]) } 从一个通道接收一个值来实现单对单通知 如果一个通道的数据缓冲队列已满（非缓冲的通道的数据缓冲队列总是满的）但它的发送协程队列为空，则向此通道发送一个值将阻塞，直到另外一个协程从此通道接收一个值为止。 所以我们可以通过从一个通道接收数据来实现单对单通知。一般我们使用非缓冲通道来实现这样的通知。\n这种通知方式不如上例中介绍的方式使用得广泛，基本很少用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \"fmt\" \"time\" ) func main() { done := make(chan struct{}) // 此信号通道也可以缓冲为1。如果这样，则在下面 // 这个协程创建之前，我们必须向其中写入一个值。 go func() { fmt.Print(\"Hello\") // 模拟一个工作负载。 time.Sleep(time.Second * 2) // 使用一个接收操作来通知主协程。 \u003c- done }() done \u003c- struct{}{} // 阻塞在此，等待通知 fmt.Println(\" world!\") } 另一个事实是，上面的两种单对单通知方式其实并没有本质的区别。 它们都可以被概括为较快者等待较慢者发出通知。\n多对单和单对多通知 略微扩展一下上面两个用例，我们可以很轻松地实现多对单和单对多通知。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import \"log\" import \"time\" type T = struct{} func worker(id int, ready \u003c-chan T, done chan\u003c- T) { \u003c-ready // 阻塞在此，等待通知 log.Print(\"Worker#\", id, \"开始工作\") // 模拟一个工作负载。 time.Sleep(time.Second * time.Duration(id+1)) log.Print(\"Worker#\", id, \"工作完成\") done \u003c- T{} // 通知主协程（N-to-1） } func main() { log.SetFlags(0) ready, done := make(chan T), make(chan T) go worker(0, ready, done) go worker(1, ready, done) go worker(2, ready, done) // 模拟一个初始化过程 time.Sleep(time.Second * 3 / 2) // 单对多通知 ready \u003c- T{}; ready \u003c- T{}; ready \u003c- T{} // 等待被多对单通知 \u003c-done; \u003c-done; \u003c-done } 这种写法是比较少见的，因为not clean enough，一般用sync.WaitGroup实现多对单的通知，使用关闭一个通道方式实现单对多。\n通过关闭一个通道来实现群发通知（单对多模式优化） 关闭一个通道进行对多通知更简单。用到的特性是能够从一个已经关闭的通道接受到无穷多的值。\n我们可以把上一个例子中的三个数据发送操作ready \u003c- struct{}{}替换为一个通道关闭操作close(ready)来达到同样的单对多通知效果。\n1 2 3 ... close(ready) // 群发通知Let's go! ... 其实，单对单通知一般也是用关闭通道的方式，这也是实践中用到最多的通知实现方式。context库中用这种特性实现了传达操作取消消息，后续会介绍具体的cases。\n定时通知（timer） 标准库里的time.After的实现，也就是函数返回一个channel（容量为1的缓冲通道），起一个gorountine等待一段时间后往这个channel里送一个空结构体，类似的逻辑。\n将通道用做互斥锁（mutex） 运用容量为1的缓冲通道作为多次性二元semaphore，也就是mutex，这种mutex不如sync标准包里的高效。\n有两种方式将一个容量为1的缓冲通道用做互斥锁：\n通过发送操作来加锁，通过接收操作来解锁； 通过接收操作来加锁，通过发送操作来解锁。 写一个发送操作加锁的例子，第二种反一下就行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \"fmt\" func main() { mutex := make(chan struct{}, 1) // 容量必须为1 counter := 0 increase := func() { mutex \u003c- struct{}{} // 加锁 counter++ \u003c-mutex // 解锁 } increase1000 := func(done chan\u003c- struct{}) { for i := 0; i \u003c 1000; i++ { increase() } done \u003c- struct{}{} } done := make(chan struct{}) go increase1000(done) go increase1000(done) \u003c-done; \u003c-done fmt.Println(counter) // 2000 } 将通道用做计数信号量（counting semaphore） 缓冲通道可以用于作为counting semaphore，也就是多主锁 – 如果一个缓冲通道的容量为N，那么它可以被看作是一个在任何时刻最多可有N个主人的锁。 上面提到的二元信号量是特殊的计数信号量，每个二元信号量在任一时刻最多只能有一个主人。\n计数信号量经常被使用于限制最大并发数。\n和将通道用做互斥锁一样，也有两种方式用来获取一个用做计数信号量的通道的一份所有权。\n通过发送操作来获取所有权，通过接收操作来释放所有权； 通过接收操作来获取所有权，通过发送操作来释放所有权。 下面是一个酒吧在座位数一定的前提下服务客人的例子，以接受操作获取所有权，先来一个简化版:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \"log\" \"time\" \"math/rand\" ) type Seat int type Bar chan Seat func (bar Bar) ServeCustomer(c int) { log.Print(\"顾客#\", c, \"进入酒吧\") seat := \u003c- bar // 需要一个位子来喝酒 log.Print(\"++ customer#\", c, \" drinks at seat#\", seat) log.Print(\"++ 顾客#\", c, \"在第\", seat, \"个座位开始饮酒\") time.Sleep(time.Second * time.Duration(2 + rand.Intn(6))) log.Print(\"-- 顾客#\", c, \"离开了第\", seat, \"个座位\") bar \u003c- seat // 释放座位，离开酒吧 } func main() { rand.Seed(time.Now().UnixNano()) bar24x7 := make(Bar, 10) // 此酒吧有10个座位 // 摆放10个座位。 for seatId := 0; seatId \u003c cap(bar24x7); seatId++ { bar24x7 \u003c- Seat(seatId) // 均不会阻塞 } for customerId := 0; ; customerId++ { time.Sleep(time.Second) go bar24x7.ServeCustomer(customerId) } for {time.Sleep(time.Second)} // 睡眠不属于阻塞状态 } 在上例中，只有获得一个座位的顾客才能开始饮酒。 所以在任一时刻同时在喝酒的顾客数不会超过座位数10。最后的for循环其实不太好，用select{}阻塞比较好。\n这个例子不好的地方，在于尽管在任一时刻同时在喝酒的顾客数不会超过座位数10，但是在某一时刻可能有多于10个顾客进入了酒吧，因为某些顾客在排队等位子。 在上例中，每个顾客对应着一个协程。虽然协程的开销比系统线程小得多，但是如果协程的数量很多，则它们的总体开销还是不能忽略不计的。 所以，最好当有空位的时候才创建顾客协程。我们可以做个小的优化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ... // 省略了和上例相同的代码 func (bar Bar) ServeCustomerAtSeat(c int, seat Seat) { log.Print(\"++ 顾客#\", c, \"在第\", seat, \"个座位开始饮酒\") time.Sleep(time.Second * time.Duration(2 + rand.Intn(6))) log.Print(\"-- 顾客#\", c, \"离开了第\", seat, \"个座位\") bar \u003c- seat // 释放座位，离开酒吧 } func main() { rand.Seed(time.Now().UnixNano()) bar24x7 := make(Bar, 10) for seatId := 0; seatId \u003c cap(bar24x7); seatId++ { bar24x7 \u003c- Seat(seatId) } // 这个for循环和上例不一样。 for customerId := 0; ; customerId++ { time.Sleep(time.Second) seat := \u003c- bar24x7 // 需要一个空位招待顾客 go bar24x7.ServeCustomerAtSeat(customerId, seat) } for {time.Sleep(time.Second)} } 在上面这个修改后的例子中，在任一时刻最多只有10个顾客协程在运行（但是在程序的生命期内，仍旧会有大量的顾客协程不断被创建和销毁）。\n所以考虑每个gorountine作为消费者，不断从customers的通道去获取客人，这样消费者的数量是一定的。在下面这个更加高效的实现中，在程序的生命期内最多只会有10个顾客协程被创建出来:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ... // 省略了和上例相同的代码 func (bar Bar) ServeCustomerAtSeat(consumers chan int) { for c := range consumers { seatId := \u003c- bar log.Print(\"++ 顾客#\", c, \"在第\", seatId, \"个座位开始饮酒\") time.Sleep(time.Second * time.Duration(2 + rand.Intn(6))) log.Print(\"-- 顾客#\", c, \"离开了第\", seatId, \"个座位\") bar \u003c- seatId // 释放座位，离开酒吧 } } func main() { rand.Seed(time.Now().UnixNano()) bar24x7 := make(Bar, 10) for seatId := 0; seatId \u003c cap(bar24x7); seatId++ { bar24x7 \u003c- Seat(seatId) } consumers := make(chan int) for i := 0; i \u003c cap(bar24x7); i++ { go bar24x7.ServeCustomerAtSeat(consumers) } for customerId := 0; ; customerId++ { time.Sleep(time.Second) consumers \u003c- customerId } } 通过发送操作来获取所有权的实现相对简单一些，省去了摆放座位的步骤：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \"log\" \"time\" \"math/rand\" ) type Customer struct{id int} type Bar chan Customer func (bar Bar) ServeCustomer(c Customer) { log.Print(\"++ 顾客#\", c.id, \"开始饮酒\") time.Sleep(time.Second * time.Duration(3 + rand.Intn(16))) log.Print(\"-- 顾客#\", c.id, \"离开酒吧\") \u003c- bar // 离开酒吧，腾出位子 } func main() { rand.Seed(time.Now().UnixNano()) bar24x7 := make(Bar, 10) // 最多同时服务10位顾客 for customerId := 0; ; customerId++ { time.Sleep(time.Second * 2) customer := Customer{customerId} bar24x7 \u003c- customer // 等待进入酒吧 go bar24x7.ServeCustomer(customer) } for {time.Sleep(time.Second)} } 使用通道传送传输通道(special case) 一个通道类型的元素类型可以是另一个通道类型。 在下面这个例子中， 单向发送通道类型chan\u003c- int是另一个通道类型chan chan\u003c- int的元素类型。\n下面的例子在这个场景其实不是最好的方案，还在关注类似的场景。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \"fmt\" var counter = func (n int) chan\u003c- chan\u003c- int { requests := make(chan chan\u003c- int) go func() { for request := range requests { if request == nil { n++ // 递增计数 } else { request \u003c- n // 返回当前计数 } } }() return requests // 隐式转换到类型chan\u003c- (chan\u003c- int) }(0) func main() { increase1000 := func(done chan\u003c- struct{}) { for i := 0; i \u003c 1000; i++ { counter \u003c- nil } done \u003c- struct{}{} } done := make(chan struct{}) go increase1000(done) go increase1000(done) \u003c-done; \u003c-done request := make(chan int, 1) counter \u003c- request fmt.Println(\u003c-request) // 2000 } 检查通道的长度和容量 我们可以使用内置函数cap和len来查看一个通道的容量和当前长度。 但是在实践中我们很少这样做。我们很少使用内置函数cap的原因是一个通道的容量常常是已知的或者不重要的。 我们很少使用内置函数len的原因是一个**len调用的结果并不能总能准确地反映出的一个通道的当前长度。**\n但有时确实有一些场景需要调用这两个函数。比如，有时一个协程欲将一个未关闭的并且不会再向其中发送数据的缓冲通道中的所有数据接收出来，在确保只有此一个协程从此通道接收数据的情况下，我们可以用下面的代码来实现：\n1 2 3 4 for len(c) \u003e 0 { value := \u003c-c // 使用value ... } 不过这种场景可以用尝试接收机制来实现，这两种方式的运行效率差距不大，但尝试接收机制的优点是多个协程可以并发地进行读取操作。\n有时一个协程欲将一个缓冲通道写满而又不阻塞，在确保只有此一个协程向此通道发送数据的情况下，我们可以用下面的代码实现这一目的：\n1 2 3 for len(c) \u003c cap(c) { c \u003c- aValue } 当然，尝试发送机制也能cover。\n尝试发送和尝试接收(无阻塞select/default) 含有一个default分支和一个case分支的select代码块可以被用做一个尝试发送或者尝试接收操作，取决于case关键字后跟随的是一个发送操作还是一个接收操作。\n如果case关键字后跟随的是一个发送操作，则此select代码块为一个尝试发送操作。 如果case分支的发送操作是阻塞的，则default分支将被执行，发送失败；否则发送成功，case分支得到执行。 如果case关键字后跟随的是一个接收操作，则此select代码块为一个尝试接收操作。 如果case分支的接收操作是阻塞的，则default分支将被执行，接收失败；否则接收成功，case分支得到执行。 尝试发送和尝试接收代码块永不阻塞。\n标准编译器对尝试发送和尝试接收代码块做了特别的优化，使得它们的执行效率比多case分支的普通select代码块执行效率高得多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \"fmt\" func main() { type Book struct{id int} bookshelf := make(chan Book, 3) for i := 0; i \u003c cap(bookshelf) * 2; i++ { select { case bookshelf \u003c- Book{id: i}: fmt.Println(\"成功将书放在书架上\", i) default: fmt.Println(\"书架已经被占满了\") } } for i := 0; i \u003c cap(bookshelf) * 2; i++ { select { case book := \u003c-bookshelf: fmt.Println(\"成功从书架上取下一本书\", book.id) default: fmt.Println(\"书架上已经没有书了\") } } } 输出结果很简单:\n成功将书放在书架上 0 成功将书放在书架上 1 成功将书放在书架上 2 书架已经被占满了 书架已经被占满了 书架已经被占满了 成功从书架上取下一本书 0 成功从书架上取下一本书 1 成功从书架上取下一本书 2 书架上已经没有书了 书架上已经没有书了 书架上已经没有书了 无阻塞地检查一个通道是否已经关闭 假设我们可以保证没有任何协程会向一个通道发送数据，则我们可以使用下面的代码来（并发安全地）检查此通道是否已经关闭，此检查不会阻塞当前协程。\n1 2 3 4 5 6 7 8 func IsClosed(c chan T) bool { select { case \u003c-c: return true default: } return false } 常用场景：此方法常用来查看某个期待中的通知是否已经来临。此通知将由另一个协程通过关闭一个通道来发送。\n峰值限制（peak/burst limiting） 通道用作counting semaphore + 通道尝试(发送/接收)可实现峰值限制。目的是防止过大的并发请求数。\n还是那个酒吧招待客户的例子，现在做一些修改能让顾客不再等待而是离去或者寻找其它酒吧。\n1 2 3 4 5 6 7 8 9 10 11 12 13 ... bar24x7 := make(Bar, 10) // 此酒吧只能同时招待10个顾客 for customerId := 0; ; customerId++ { time.Sleep(time.Second) consumer := Consumer{customerId} select { case bar24x7 \u003c- consumer: // 试图进入此酒吧 go bar24x7.ServeConsumer(consumer) default: log.Print(\"顾客#\", customerId, \"不愿等待而离去\") } } ... 另一种“采用最快回应”的实现方式(复杂场景用) 在上面的“采用最快回应”用例一节已经提到，我们也可以使用选择机制来实现“采用最快回应”用例。 每个数据源协程只需使用一个缓冲为1的通道并向其尝试发送回应数据即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \"fmt\" \"math/rand\" \"time\" ) func source(c chan\u003c- int32) { ra, rb := rand.Int31(), rand.Intn(3)+1 // 休眠1秒/2秒/3秒 time.Sleep(time.Duration(rb) * time.Second) select { case c \u003c- ra: default: } } func main() { rand.Seed(time.Now().UnixNano()) c := make(chan int32, 1) // 此通道容量必须至少为1 for i := 0; i \u003c 5; i++ { go source(c) } rnd := \u003c-c // 只采用第一个成功发送的回应数据 fmt.Println(rnd) } 注意，使用选择机制来实现“采用最快回应”的代码中使用的通道的容量必须至少为1，以保证最快回应总能够发送成功。 否则，如果数据请求者因为种种原因未及时准备好接收，则所有回应者的尝试发送都将失败，从而所有回应的数据都将被错过。\n少量数据源“采用最快回应”的实现方式 如果一个“采用最快回应”用例中的数据源的数量很少，比如两个或三个，我们可以让每个数据源使用一个单独的缓冲通道来回应数据，然后使用一个select代码块来同时接收这三个通道。 示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \"fmt\" \"math/rand\" \"time\" ) func source() \u003c-chan int32 { c := make(chan int32, 1) // 必须为一个缓冲通道 go func() { ra, rb := rand.Int31(), rand.Intn(3)+1 time.Sleep(time.Duration(rb) * time.Second) c \u003c- ra }() return c } func main() { rand.Seed(time.Now().UnixNano()) var rnd int32 // 阻塞在此直到某个数据源率先回应。 select{ case rnd = \u003c-source(): case rnd = \u003c-source(): case rnd = \u003c-source(): } fmt.Println(rnd) } 注意：如果上例中使用的通道是非缓冲的，未被选中的case分支对应的两个source函数调用中开辟的协程将处于永久阻塞状态，从而造成内存泄露。\n超时机制（timeout） 在一些请求/回应用例中，一个请求可能因为种种原因导致需要超出预期的时长才能得到回应，有时甚至永远得不到回应。 对于这样的情形，我们可以使用一个超时方案给请求者返回一个错误信息。 使用选择机制可以很轻松地实现这样的一个超时方案。\n下面这个例子展示了如何实现一个支持超时设置的请求：\n1 2 3 4 5 6 7 8 9 10 11 func requestWithTimeout(timeout time.Duration) (int, error) { c := make(chan int) go doRequest(c) // 可能需要超出预期的时长回应 select { case data := \u003c-c: return data, nil case \u003c-time.After(timeout): return 0, errors.New(\"超时了！\") } } 脉搏器（ticker） 我们可以使用尝试发送操作来实现一个每隔一定时间发送一个信号的脉搏器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \"fmt\" import \"time\" func Tick(d time.Duration) \u003c-chan struct{} { c := make(chan struct{}, 1) // 容量最好为1 go func() { for { time.Sleep(d) select { case c \u003c- struct{}{}: default: } } }() return c } func main() { t := time.Now() for range Tick(time.Second) { fmt.Println(time.Since(t)) } } 事实上，time标准库包中的Tick函数提供了同样的功能，但效率更高。 我们应该尽量使用标准库包中的实现。\n速率限制（rate limiting） 前面实现了峰值限制，同样地我们可以使用尝试机制实现速率限制，但是这里要和定时器配合实现。速率限制常用来限制吞吐和确保在一段时间内的资源使用不会超标。\n下面的例子借鉴了官方Go维基中的例子。 在此例中，任何一分钟时段内处理的请求数不会超过200\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import \"fmt\" import \"time\" type Request interface{} func handle(r Request) {fmt.Println(r.(int))} const RateLimitPeriod = time.Minute const RateLimit = 200 // 任何一分钟内最多处理200个请求 func handleRequests(requests \u003c-chan Request) { quotas := make(chan time.Time, RateLimit) go func() { tick := time.NewTicker(RateLimitPeriod / RateLimit) defer tick.Stop() for t := range tick.C { select { case quotas \u003c- t: default: } } }() for r := range requests { \u003c-quotas go handle(r) } } func main() { requests := make(chan Request) go handleRequests(requests) // time.Sleep(time.Minute) for i := 0; ; i++ {requests \u003c- i} } 上例的代码虽然可以保证任何一分钟时段内处理的请求数不会超过200，但是如果在开始的一分钟内没有任何请求，则接下来的某个瞬时时间点可能会同时处理最多200个请求（试着将time.Sleep行的注释去掉), 这可能会造成卡顿情况。我们可以将速率限制和峰值限制一并使用来避免出现这样的情况。\n开关 向一个nil通道发送数据或者从中接收数据都属于阻塞操作。 利用这一事实，我们可以将一个select流程控制中的case操作中涉及的通道设置为不同的值，以使此select流程控制选择执行不同的分支。\n控制代码被执行的几率（少用） 我们可以通过在一个select流程控制中使用重复的case操作来增加对应分支中的代码的执行几率。这种操作比较少见，下面这个例子， 函数f的调用执行几率大致为函数g的两倍:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import \"fmt\" func main() { foo, bar := make(chan struct{}), make(chan struct{}) close(foo); close(bar) // 仅为演示目的 x, y := 0.0, 0.0 f := func(){x++} g := func(){y++} for i := 0; i \u003c 100000; i++ { select { case \u003c-foo: f() case \u003c-foo: f() case \u003c-bar: g() } } fmt.Println(x/y) // 大致为2 } 从动态数量的分支中选择（少用） reflection ain’t good\n每个select控制流程中的分支数量在运行中是固定的，但是我们可以使用reflect标准库包中提供的功能在运行时刻来构建动态分支数量的select控制流程。 但是请注意：一个select控制流程中的分支越多，此select控制流程的执行效率就越低（这是我们常常只使用不多于三个分支的select控制流程的原因）。 reflect标准库包中也提供了模拟尝试发送和尝试接收代码块的TrySend和TryRecv函数。涉及到反射的，肯定有更好的解决方案:-)。\n数据流操纵（Data Flow） 下面把数据流处理程序大致分成了常见的几类，概念上来说是不同模块由一个或者多个并行处理的协程组成：\n数据生成/搜集/加载；\n数据服务/存盘；\n数据计算/处理；\n数据验证/过滤；\n数据聚合/分流；\n数据组合/拆分；\n数据复制/增殖；\n一个模块中的工作协程从一些其它模块接收数据做为输入，并向另一些模块发送输出数据。 换句话数，一个模块可能同时兼任数据消费者和数据产生者的角色。多个模块一起组成了一个数据流处理系统。后续的一些实现可能并不高效，只是为了描述这些分类模块的实现，比较简单。\n数据生成/搜集/加载 一个数据产生者可能通过以下途径生成数据：\n加载一个文件、或者读取一个数据库、或者用爬虫抓取网页数据；\n从一个软件或者硬件系统搜集各种数据；\n产生一系列随机数；\netc.\n这里的例子是一个随机数生成器作为数据生产者，生产者只有数据输出，所以返回只读通道。实际上此随机数产生器是一个多返回值的future/promise，一个数据产生者可以在任何时刻关闭返回的通道以结束数据生成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import ( \"crypto/rand\" \"encoding/binary\" ) func RandomGenerator() \u003c-chan uint64 { c := make(chan uint64) go func() { rnds := make([]byte, 8) for { _, err := rand.Read(rnds) if err != nil { close(c) // 若读取错误则关闭通道结束数据生成 break } c \u003c- binary.BigEndian.Uint64(rnds) } }() return c } 数据聚合 例如把多个数据流合为一个数据流，下面这个函数把任意数量的数据流合为一个：\n1 2 3 4 5 6 7 8 9 10 11 func Aggregator(inputs ...\u003c-chan uint64) \u003c-chan uint64 { out := make(chan uint64) for _, in := range inputs { go func(in \u003c-chan uint64) { for { out \u003c- \u003c-in // \u003c=\u003e out \u003c- (\u003c-in) } }(in) } return out } 但是这个例子，最好需要考虑一个输入数据流是否已经关闭：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import \"sync\" func Aggregator(inputs ...\u003c-chan uint64) \u003c-chan uint64 { output := make(chan uint64) var wg sync.WaitGroup for _, in := range inputs { wg.Add(1) go func(int \u003c-chan uint64) { defer wg.Done() // 如果通道in被关闭，此循环将最终结束。 for x := range in { output \u003c- x } }(in) } go func() { wg.Wait() close(output) }() return output } 如果被聚合的数据流的数量很小，我们也可以使用一个select控制流程代码块来聚合这些数据流。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 假设数据流的数量为2。 ... output := make(chan uint64) go func() { inA, inB := inputs[0], inputs[1] for { select { case v := \u003c- inA: output \u003c- v case v := \u003c- inB: output \u003c- v } } } ... 数据分流 数据分流是数据聚合的逆过程。数据分流的实现很简单，但在实践中用的并不多。\n1 2 3 4 5 6 7 8 9 func Divisor(input \u003c-chan uint64, outputs ...chan\u003c- uint64) { for _, out := range outputs { go func(o chan\u003c- uint64) { for { o \u003c- \u003c-input // \u003c=\u003e o \u003c- (\u003c-input) } }(out) } } 数据合成 数据合成将多个数据流中读取的数据合成一个。\n下面是一个数据合成工作函数的实现中，从两个不同数据流读取的两个uint64值组成了一个新的uint64值。 当然，在实践中，数据的组合比这复杂得多。\n1 2 3 4 5 6 7 8 9 10 func Composor(inA, inB \u003c-chan uint64) \u003c-chan uint64 { output := make(chan uint64) go func() { for { a1, b, a2 := \u003c-inA, \u003c-inB, \u003c-inA output \u003c- a1 ^ b \u0026 a2 } }() return output } 数据分解 数据分解是数据合成的逆过程。一个数据分解者从一个通道读取一份数据，并将此数据分解为多份数据。 这里就不举例了。\n数据复制/增殖 数据复制（增殖）可以看作是特殊的数据分解。一份输入数据将被复制多份并输出给多个数据流。\n1 2 3 4 5 6 7 8 9 10 func Duplicator(in \u003c-chan uint64) (\u003c-chan uint64, \u003c-chan uint64) { outA, outB := make(chan uint64), make(chan uint64) go func() { for x := range in { outA \u003c- x outB \u003c- x } }() return outA, outB } 数据计算/分析 数据计算和数据分析模块的功能因具体程序不同而有很大的差异。 一般来说，数据分析者接收一份数据并对之加工处理后转换为另一份数据。\n下面的简单示例中，每个输入的uint64值将被进行位反转后输出。\n1 2 3 4 5 6 7 8 9 10 11 func Calculator(in \u003c-chan uint64, out chan uint64) (\u003c-chan uint64) { if out == nil { out = make(chan uint64) } go func() { for x := range in { out \u003c- ^x } }() return out } 数据验证/过滤 一个数据验证或过滤者的任务是检查输入数据的合理性并抛弃不合理的数据。 比如，下面的工作者协程将抛弃所有的非素数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import \"math/big\" func Filter0(input \u003c-chan uint64, output chan uint64) \u003c-chan uint64 { if output == nil { output = make(chan uint64) } go func() { bigInt := big.NewInt(0) for x := range input { bigInt.SetUint64(x) if bigInt.ProbablyPrime(1) { output \u003c- x } } }() return output } func Filter(input \u003c-chan uint64) \u003c-chan uint64 { return Filter0(input, nil) } 数据服务/存盘 一般，一个数据服务或者存盘模块为一个数据流系统中的最后一个模块。 这里的实现值是简单地将数据输出到终端。\n1 2 3 4 5 6 7 import \"fmt\" func Printer(input \u003c-chan uint64) { for x := range input { fmt.Println(x) } } 组装数据流系统 Now，让我们使用上面的模块工作者函数实现来组装一些数据流系统。 组装数据流仅仅是创建一些工作者协程函数调用，并为这些调用指定输入数据流和输出数据流。\n数据流系统例子1（一个流线型系统）\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main ... // 上面的模块工作者函数实现 func main() { Printer( Filter( Calculator( RandomGenerator(), nil, ), ), ) } 数据流系统例子2（一个单向无环图系统）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main ... // 上面的模块工作者函数实现 func main() { filterA := Filter(RandomGenerator()) filterB := Filter(RandomGenerator()) filterC := Filter(RandomGenerator()) filter := Aggregator(filterA, filterB, filterC) calculatorA := Calculator(filter, nil) calculatorB := Calculator(filter, nil) calculator := Aggregator(calculatorA, calculatorB) Printer(calculator) } 更复杂的数据流系统可以表示为任何拓扑结构的图。比如一个复杂的数据流系统可能有多个输出模块。 但是有环拓扑结构的数据流系统在实践中很少用。\n从上面两个例子可以看出，使用通道来构建数据流系统是很简单和直观的。而且，通过使用数据聚合模块，我们可以很轻松地实现各个模块的工作协程数量的扇入（fan-in）和扇出（fan-out）。\n事实上，我们也可以使用一个简单的通道来代替数据聚合模块的角色。比如，下面的代码使用两个通道代替了上例中的两个数据聚合器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main ... // 上面的模块工作者函数实现 func main() { c1 := make(chan uint64, 100) Filter0(RandomGenerator(), c1) // filterA Filter0(RandomGenerator(), c1) // filterB Filter0(RandomGenerator(), c1) // filterC c2 := make(chan uint64, 100) Calculator(c1, c2) // calculatorA Calculator(c1, c2) // calculatorB Printer(c2) } 上面的代码示例并没有太多考虑如何关闭一个数据流，会单独开一个文章介绍。\n","wordCount":"2852","inLanguage":"en","image":"https://pillumina.github.io/imgs/icon_head.png","datePublished":"2020-12-22T11:22:18+08:00","dateModified":"2020-12-22T11:22:18+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://pillumina.github.io/posts/programming/golang/channels/"},"publisher":{"@type":"Organization","name":"CctoctoFX","logo":{"@type":"ImageObject","url":"https://pillumina.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pillumina.github.io/ accesskey=h title="CctoctoFX (Alt + H)"><img src=https://pillumina.github.io/apple-touch-icon.png alt aria-label=logo height=30>CctoctoFX</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pillumina.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://pillumina.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://pillumina.github.io/posts/aiinfra title="AI Infra"><span>AI Infra</span></a></li><li><a href=https://pillumina.github.io/posts/programming title=Programming><span>Programming</span></a></li><li><a href=https://pillumina.github.io/social title=Social><span>Social</span></a></li><li><a href=https://pillumina.github.io/open_courses title=Study><span>Study</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://pillumina.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://pillumina.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://pillumina.github.io/posts/programming/>Programming</a>&nbsp;»&nbsp;<a href=https://pillumina.github.io/posts/programming/golang/>Golang</a></div><h1 class="post-title entry-hint-parent">Channels Concurrency Work-Around</h1><div class=post-meta><span title='2020-12-22 11:22:18 +0800 CST'>December 22, 2020</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2852 words&nbsp;·&nbsp;Me</div></header><div class="toc side left"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#将通道用做futurepromise>将通道用做future/promise</a></li><li><a href=#使用通道实现通知>使用通道实现通知</a></li><li><a href=#将通道用做互斥锁mutex>将通道用做互斥锁（mutex）</a></li><li><a href=#将通道用做计数信号量counting-semaphore>将通道用做计数信号量（counting semaphore）</a></li><li><a href=#使用通道传送传输通道special-case>使用通道传送传输通道(special case)</a></li><li><a href=#检查通道的长度和容量>检查通道的长度和容量</a></li><li><a href=#尝试发送和尝试接收无阻塞selectdefault>尝试发送和尝试接收(无阻塞select/default)</a></li><li><a href=#数据流操纵data-flow>数据流操纵（Data Flow）</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>记录了一些channels常见的场景，以及自己的一些感受：</p><ul><li><p>使用通道进行异步和并发编程是简单和惬意的；</p></li><li><p>通道同步技术比被很多其它语言采用的其它同步方案（比如<a href=https://en.wikipedia.org/wiki/Actor_model>角色模型</a>和<a href=https://en.wikipedia.org/wiki/Async/await>async/await模式</a>）有着更多的应用场景和更多的使用变种。</p><p>通道作为同步手段，并非在任何情况下都是最佳的同步技术，本文也会补充原子操作和sync包内其他的技术作为参考。</p></li></ul><h3 id=将通道用做futurepromise>将通道用做future/promise<a hidden class=anchor aria-hidden=true href=#将通道用做futurepromise>#</a></h3><p>很多其它流行语言支持future/promise来实现异步（并发）编程。 Future/promise常常用在请求/回应场合。</p><h4 id=返回单向接收通道做为函数返回结果>返回单向接收通道做为函数返回结果<a hidden class=anchor aria-hidden=true href=#返回单向接收通道做为函数返回结果>#</a></h4><p>在下面这个例子中，<code>sumSquares</code>函数调用的两个实参请求并发进行。 每个通道读取操作将阻塞到请求返回结果为止。 两个实参总共需要大约3秒钟（而不是6秒钟）准备完毕（以较慢的一个为准）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;math/rand&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>longTimeRequest</span><span class=p>()</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>3</span><span class=p>)</span> <span class=c1>// 模拟一个工作负载</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span> <span class=o>&lt;-</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Int31n</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>r</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>sumSquares</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int32</span><span class=p>)</span> <span class=kt>int32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>a</span><span class=o>*</span><span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span><span class=o>*</span><span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rand</span><span class=p>.</span><span class=nf>Seed</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=o>:=</span> <span class=nf>longTimeRequest</span><span class=p>(),</span> <span class=nf>longTimeRequest</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>sumSquares</span><span class=p>(</span><span class=o>&lt;-</span><span class=nx>a</span><span class=p>,</span> <span class=o>&lt;-</span><span class=nx>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=将单向发送通道类型用做函数实参>将单向发送通道类型用做函数实参<a hidden class=anchor aria-hidden=true href=#将单向发送通道类型用做函数实参>#</a></h4><p>和上例一样，在下面这个例子中，<code>sumSquares</code>函数调用的两个实参的请求也是并发进行的。 和上例不同的是<code>longTimeRequest</code>函数接收一个单向发送通道类型参数而不是返回一个单向接收通道结果。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;math/rand&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>longTimeRequest</span><span class=p>(</span><span class=nx>r</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>int32</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>3</span><span class=p>)</span> <span class=c1>// 模拟一个工作负载</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span> <span class=o>&lt;-</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Int31n</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>sumSquares</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int32</span><span class=p>)</span> <span class=kt>int32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>a</span><span class=o>*</span><span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span><span class=o>*</span><span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rand</span><span class=p>.</span><span class=nf>Seed</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>ra</span><span class=p>,</span> <span class=nx>rb</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int32</span><span class=p>),</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>longTimeRequest</span><span class=p>(</span><span class=nx>ra</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>longTimeRequest</span><span class=p>(</span><span class=nx>rb</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>sumSquares</span><span class=p>(</span><span class=o>&lt;-</span><span class=nx>ra</span><span class=p>,</span> <span class=o>&lt;-</span><span class=nx>rb</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>对于上面这个特定的例子，我们可以只使用一个通道来接收回应结果，因为两个参数的作用是对等的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>results</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int32</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=c1>// 缓冲与否不重要</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>longTimeRequest</span><span class=p>(</span><span class=nx>results</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>longTimeRequest</span><span class=p>(</span><span class=nx>results</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>sumSquares</span><span class=p>(</span><span class=o>&lt;-</span><span class=nx>results</span><span class=p>,</span> <span class=o>&lt;-</span><span class=nx>results</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这可以看作是后面将要提到的数据聚合的一个应用。</p><h4 id=采用最快回应>采用最快回应<a hidden class=anchor aria-hidden=true href=#采用最快回应>#</a></h4><p>本用例可以看作是上例中只使用一个通道变种的增强。</p><p>有时候，一份数据可能同时从多个数据源获取。这些数据源将返回相同的数据。 因为各种因素，这些数据源的回应速度参差不一，甚至某个特定数据源的多次回应速度之间也可能相差很大。 同时从多个数据源获取一份相同的数据可以有效保障低延迟。我们只需采用最快的回应并舍弃其它较慢回应。</p><p>注意：如果有<em>N</em>个数据源，为了防止被舍弃的回应对应的协程永久阻塞，则传输数据用的通道必须为一个容量至少为<em>N-1</em>的缓冲通道。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;math/rand&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>source</span><span class=p>(</span><span class=nx>c</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>int32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ra</span><span class=p>,</span> <span class=nx>rb</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Int31</span><span class=p>(),</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 睡眠1秒/2秒/3秒</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nx>rb</span><span class=p>)</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>ra</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rand</span><span class=p>.</span><span class=nf>Seed</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>startTime</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int32</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span> <span class=c1>// 必须用一个缓冲通道</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>c</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=nf>source</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>rnd</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>c</span> <span class=c1>// 只有第一个回应被使用了</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Since</span><span class=p>(</span><span class=nx>startTime</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>rnd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>“采用最快回应”用例还有一些其它实现方式，本文后面将会谈及。</p><h4 id=更多请求回应用例变种>更多“请求/回应”用例变种<a hidden class=anchor aria-hidden=true href=#更多请求回应用例变种>#</a></h4><p>做为函数参数和返回结果使用的通道可以是缓冲的，从而使得请求协程不需阻塞到它所发送的数据被接收为止。</p><p>有时，一个请求可能并不保证返回一份有效的数据。对于这种情形，我们可以使用一个形如<code>struct{v T; err error}</code>的结构体类型或者一个空接口类型做为通道的元素类型以用来区分回应的值是否有效。</p><p>有时，一个请求可能需要比预期更长的用时才能回应，甚至永远都得不到回应。 我们可以使用本文后面将要介绍的超时机制来应对这样的情况。</p><p>有时，回应方可能会不断地返回一系列值，这也同时属于后面将要介绍的数据流的一个用例。</p><h3 id=使用通道实现通知>使用通道实现通知<a hidden class=anchor aria-hidden=true href=#使用通道实现通知>#</a></h3><p>通知可以被看作是特殊的请求/回应用例。在一个通知用例中，我们并不关心回应的值，我们只关心回应是否已发生。 所以我们常常使用空结构体类型<code>struct{}</code>来做为通道的元素类型，因为空结构体类型的尺寸为零，能够节省一些内存（虽然常常很少量）。</p><h4 id=向一个通道发送一个值来实现单对单通知>向一个通道发送一个值来实现单对单通知<a hidden class=anchor aria-hidden=true href=#向一个通道发送一个值来实现单对单通知>#</a></h4><p>我们已知道，如果一个通道中无值可接收，则此通道上的下一个接收操作将阻塞到另一个协程发送一个值到此通道为止。 所以一个协程可以向此通道发送一个值来通知另一个等待着从此通道接收数据的协程。</p><p>在下面这个例子中，通道<code>done</code>被用来做为一个信号通道来实现单对单通知。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;crypto/rand&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;os&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;sort&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>values</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>32</span> <span class=o>*</span> <span class=mi>1024</span> <span class=o>*</span> <span class=mi>1024</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>values</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=c1>// 也可以是缓冲的</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 排序协程</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>sort</span><span class=p>.</span><span class=nf>Slice</span><span class=p>(</span><span class=nx>values</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>values</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>values</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>		<span class=nx>done</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span> <span class=c1>// 通知排序已完成</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 并发地做一些其它事情...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=o>&lt;-</span> <span class=nx>done</span> <span class=c1>// 等待通知</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>values</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nx>values</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=从一个通道接收一个值来实现单对单通知>从一个通道接收一个值来实现单对单通知<a hidden class=anchor aria-hidden=true href=#从一个通道接收一个值来实现单对单通知>#</a></h4><p>如果一个通道的数据缓冲队列已满（非缓冲的通道的数据缓冲队列总是满的）但它的发送协程队列为空，则向此通道发送一个值将阻塞，直到另外一个协程从此通道接收一个值为止。 所以我们可以通过从一个通道接收数据来实现单对单通知。一般我们使用非缓冲通道来实现这样的通知。</p><p><strong>这种通知方式不如上例中介绍的方式使用得广泛，基本很少用</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 此信号通道也可以缓冲为1。如果这样，则在下面</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 这个协程创建之前，我们必须向其中写入一个值。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;Hello&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 模拟一个工作负载。</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// 使用一个接收操作来通知主协程。</span>
</span></span><span class=line><span class=cl>		<span class=o>&lt;-</span> <span class=nx>done</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>done</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span> <span class=c1>// 阻塞在此，等待通知</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34; world!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>另一个事实是，上面的两种单对单通知方式其实并没有本质的区别。 它们都可以被概括为较快者等待较慢者发出通知。</p><h4 id=多对单和单对多通知>多对单和单对多通知<a hidden class=anchor aria-hidden=true href=#多对单和单对多通知>#</a></h4><p>略微扩展一下上面两个用例，我们可以很轻松地实现多对单和单对多通知。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>T</span> <span class=p>=</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>worker</span><span class=p>(</span><span class=nx>id</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>ready</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=nx>T</span><span class=p>,</span> <span class=nx>done</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>&lt;-</span><span class=nx>ready</span> <span class=c1>// 阻塞在此，等待通知</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;Worker#&#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>,</span> <span class=s>&#34;开始工作&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 模拟一个工作负载。</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nx>id</span><span class=o>+</span><span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;Worker#&#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>,</span> <span class=s>&#34;工作完成&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>done</span> <span class=o>&lt;-</span> <span class=nx>T</span><span class=p>{}</span> <span class=c1>// 通知主协程（N-to-1）</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>SetFlags</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>ready</span><span class=p>,</span> <span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>T</span><span class=p>),</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>T</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>worker</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nx>ready</span><span class=p>,</span> <span class=nx>done</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>worker</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nx>ready</span><span class=p>,</span> <span class=nx>done</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>worker</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=nx>ready</span><span class=p>,</span> <span class=nx>done</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 模拟一个初始化过程</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>3</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 单对多通知</span>
</span></span><span class=line><span class=cl>	<span class=nx>ready</span> <span class=o>&lt;-</span> <span class=nx>T</span><span class=p>{};</span> <span class=nx>ready</span> <span class=o>&lt;-</span> <span class=nx>T</span><span class=p>{};</span> <span class=nx>ready</span> <span class=o>&lt;-</span> <span class=nx>T</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 等待被多对单通知</span>
</span></span><span class=line><span class=cl>	<span class=o>&lt;-</span><span class=nx>done</span><span class=p>;</span> <span class=o>&lt;-</span><span class=nx>done</span><span class=p>;</span> <span class=o>&lt;-</span><span class=nx>done</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这种写法是比较少见的，因为not clean enough，一般用<code>sync.WaitGroup</code>实现多对单的通知，使用关闭一个通道方式实现单对多。</p><h4 id=通过关闭一个通道来实现群发通知单对多模式优化>通过关闭一个通道来实现群发通知（单对多模式优化）<a hidden class=anchor aria-hidden=true href=#通过关闭一个通道来实现群发通知单对多模式优化>#</a></h4><p>关闭一个通道进行对多通知更简单。用到的特性是<code>能够从一个已经关闭的通道接受到无穷多的值</code>。</p><p>我们可以把上一个例子中的三个数据发送操作<code>ready &lt;- struct{}{}</code>替换为一个通道关闭操作<code>close(ready)</code>来达到同样的单对多通知效果。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl>	<span class=nb>close</span><span class=p>(</span><span class=nx>ready</span><span class=p>)</span> <span class=c1>// 群发通知Let&#39;s go!</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span></code></pre></td></tr></table></div></div><p>其实，单对单通知一般也是用关闭通道的方式，这也是实践中用到最多的通知实现方式。<code>context</code>库中用这种特性实现了传达<code>操作取消</code>消息，后续会介绍具体的cases。</p><h4 id=定时通知timer>定时通知（timer）<a hidden class=anchor aria-hidden=true href=#定时通知timer>#</a></h4><p>标准库里的time.After的实现，也就是函数返回一个channel（容量为1的缓冲通道），起一个gorountine等待一段时间后往这个channel里送一个空结构体，类似的逻辑。</p><h3 id=将通道用做互斥锁mutex>将通道用做互斥锁（mutex）<a hidden class=anchor aria-hidden=true href=#将通道用做互斥锁mutex>#</a></h3><p>运用容量为1的缓冲通道作为多次性二元semaphore，也就是mutex，这种mutex不如sync标准包里的高效。</p><p>有两种方式将一个容量为1的缓冲通道用做互斥锁：</p><ol><li>通过发送操作来加锁，通过接收操作来解锁；</li><li>通过接收操作来加锁，通过发送操作来解锁。</li></ol><p>写一个发送操作加锁的例子，第二种反一下就行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mutex</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=mi>1</span><span class=p>)</span> <span class=c1>// 容量必须为1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>counter</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nx>increase</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>mutex</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span> <span class=c1>// 加锁</span>
</span></span><span class=line><span class=cl>		<span class=nx>counter</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=o>&lt;-</span><span class=nx>mutex</span> <span class=c1>// 解锁</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>increase1000</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>done</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>1000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>increase</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>done</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>increase1000</span><span class=p>(</span><span class=nx>done</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>increase1000</span><span class=p>(</span><span class=nx>done</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=o>&lt;-</span><span class=nx>done</span><span class=p>;</span> <span class=o>&lt;-</span><span class=nx>done</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>counter</span><span class=p>)</span> <span class=c1>// 2000</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=将通道用做计数信号量counting-semaphore>将通道用做计数信号量（counting semaphore）<a hidden class=anchor aria-hidden=true href=#将通道用做计数信号量counting-semaphore>#</a></h3><p>缓冲通道可以用于作为counting semaphore，也就是多主锁 &ndash; 如果一个缓冲通道的容量为<code>N</code>，那么它可以被看作是一个在任何时刻最多可有<code>N</code>个主人的锁。 上面提到的二元信号量是特殊的计数信号量，每个二元信号量在任一时刻最多只能有一个主人。</p><p><strong>计数信号量经常被使用于限制最大并发数。</strong></p><p>和将通道用做互斥锁一样，也有两种方式用来获取一个用做计数信号量的通道的一份所有权。</p><ol><li>通过发送操作来获取所有权，通过接收操作来释放所有权；</li><li>通过接收操作来获取所有权，通过发送操作来释放所有权。</li></ol><p>下面是一个酒吧在座位数一定的前提下服务客人的例子，以接受操作获取所有权，先来一个简化版:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;math/rand&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Seat</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Bar</span> <span class=kd>chan</span> <span class=nx>Seat</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>bar</span> <span class=nx>Bar</span><span class=p>)</span> <span class=nf>ServeCustomer</span><span class=p>(</span><span class=nx>c</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;顾客#&#34;</span><span class=p>,</span> <span class=nx>c</span><span class=p>,</span> <span class=s>&#34;进入酒吧&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>seat</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>bar</span> <span class=c1>// 需要一个位子来喝酒</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;++ customer#&#34;</span><span class=p>,</span> <span class=nx>c</span><span class=p>,</span> <span class=s>&#34; drinks at seat#&#34;</span><span class=p>,</span> <span class=nx>seat</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;++ 顾客#&#34;</span><span class=p>,</span> <span class=nx>c</span><span class=p>,</span> <span class=s>&#34;在第&#34;</span><span class=p>,</span> <span class=nx>seat</span><span class=p>,</span> <span class=s>&#34;个座位开始饮酒&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=mi>2</span> <span class=o>+</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>6</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;-- 顾客#&#34;</span><span class=p>,</span> <span class=nx>c</span><span class=p>,</span> <span class=s>&#34;离开了第&#34;</span><span class=p>,</span> <span class=nx>seat</span><span class=p>,</span> <span class=s>&#34;个座位&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>bar</span> <span class=o>&lt;-</span> <span class=nx>seat</span> <span class=c1>// 释放座位，离开酒吧</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rand</span><span class=p>.</span><span class=nf>Seed</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>bar24x7</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=nx>Bar</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span> <span class=c1>// 此酒吧有10个座位</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 摆放10个座位。</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>seatId</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>seatId</span> <span class=p>&lt;</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>bar24x7</span><span class=p>);</span> <span class=nx>seatId</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>bar24x7</span> <span class=o>&lt;-</span> <span class=nf>Seat</span><span class=p>(</span><span class=nx>seatId</span><span class=p>)</span> <span class=c1>// 均不会阻塞</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>customerId</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>;</span> <span class=nx>customerId</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=nx>bar24x7</span><span class=p>.</span><span class=nf>ServeCustomer</span><span class=p>(</span><span class=nx>customerId</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)}</span> <span class=c1>// 睡眠不属于阻塞状态</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在上例中，只有获得一个座位的顾客才能开始饮酒。 所以在任一时刻同时在喝酒的顾客数不会超过座位数10。最后的for循环其实不太好，用<code>select{}</code>阻塞比较好。</p><p>这个例子不好的地方，在于尽管在任一时刻同时在喝酒的顾客数不会超过座位数10，但是在某一时刻可能有多于10个顾客进入了酒吧，因为某些顾客在排队等位子。 在上例中，每个顾客对应着一个协程。虽然协程的开销比系统线程小得多，但是如果协程的数量很多，则它们的总体开销还是不能忽略不计的。 所以，最好当有空位的时候才创建顾客协程。我们可以做个小的优化：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>...</span> <span class=c1>// 省略了和上例相同的代码</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>bar</span> <span class=nx>Bar</span><span class=p>)</span> <span class=nf>ServeCustomerAtSeat</span><span class=p>(</span><span class=nx>c</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>seat</span> <span class=nx>Seat</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;++ 顾客#&#34;</span><span class=p>,</span> <span class=nx>c</span><span class=p>,</span> <span class=s>&#34;在第&#34;</span><span class=p>,</span> <span class=nx>seat</span><span class=p>,</span> <span class=s>&#34;个座位开始饮酒&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=mi>2</span> <span class=o>+</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>6</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;-- 顾客#&#34;</span><span class=p>,</span> <span class=nx>c</span><span class=p>,</span> <span class=s>&#34;离开了第&#34;</span><span class=p>,</span> <span class=nx>seat</span><span class=p>,</span> <span class=s>&#34;个座位&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>bar</span> <span class=o>&lt;-</span> <span class=nx>seat</span> <span class=c1>// 释放座位，离开酒吧</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rand</span><span class=p>.</span><span class=nf>Seed</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>bar24x7</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=nx>Bar</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>seatId</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>seatId</span> <span class=p>&lt;</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>bar24x7</span><span class=p>);</span> <span class=nx>seatId</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>bar24x7</span> <span class=o>&lt;-</span> <span class=nf>Seat</span><span class=p>(</span><span class=nx>seatId</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 这个for循环和上例不一样。</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>customerId</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>;</span> <span class=nx>customerId</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>seat</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>bar24x7</span> <span class=c1>// 需要一个空位招待顾客</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=nx>bar24x7</span><span class=p>.</span><span class=nf>ServeCustomerAtSeat</span><span class=p>(</span><span class=nx>customerId</span><span class=p>,</span> <span class=nx>seat</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在上面这个修改后的例子中，在任一时刻最多只有10个顾客协程在运行（但是在程序的生命期内，仍旧会有大量的顾客协程不断被创建和销毁）。</p><p>所以考虑每个gorountine作为消费者，不断从customers的通道去获取客人，这样消费者的数量是一定的。在下面这个更加高效的实现中，在程序的生命期内最多只会有10个顾客协程被创建出来:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>...</span> <span class=c1>// 省略了和上例相同的代码</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>bar</span> <span class=nx>Bar</span><span class=p>)</span> <span class=nf>ServeCustomerAtSeat</span><span class=p>(</span><span class=nx>consumers</span> <span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>c</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>consumers</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>seatId</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>bar</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;++ 顾客#&#34;</span><span class=p>,</span> <span class=nx>c</span><span class=p>,</span> <span class=s>&#34;在第&#34;</span><span class=p>,</span> <span class=nx>seatId</span><span class=p>,</span> <span class=s>&#34;个座位开始饮酒&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=mi>2</span> <span class=o>+</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>6</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;-- 顾客#&#34;</span><span class=p>,</span> <span class=nx>c</span><span class=p>,</span> <span class=s>&#34;离开了第&#34;</span><span class=p>,</span> <span class=nx>seatId</span><span class=p>,</span> <span class=s>&#34;个座位&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>bar</span> <span class=o>&lt;-</span> <span class=nx>seatId</span> <span class=c1>// 释放座位，离开酒吧</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rand</span><span class=p>.</span><span class=nf>Seed</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>bar24x7</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=nx>Bar</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>seatId</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>seatId</span> <span class=p>&lt;</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>bar24x7</span><span class=p>);</span> <span class=nx>seatId</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>bar24x7</span> <span class=o>&lt;-</span> <span class=nf>Seat</span><span class=p>(</span><span class=nx>seatId</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>consumers</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>bar24x7</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=nx>bar24x7</span><span class=p>.</span><span class=nf>ServeCustomerAtSeat</span><span class=p>(</span><span class=nx>consumers</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>customerId</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>;</span> <span class=nx>customerId</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>consumers</span> <span class=o>&lt;-</span> <span class=nx>customerId</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>通过发送操作来获取所有权的实现相对简单一些，省去了摆放座位的步骤：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;math/rand&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Customer</span> <span class=kd>struct</span><span class=p>{</span><span class=nx>id</span> <span class=kt>int</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Bar</span> <span class=kd>chan</span> <span class=nx>Customer</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>bar</span> <span class=nx>Bar</span><span class=p>)</span> <span class=nf>ServeCustomer</span><span class=p>(</span><span class=nx>c</span> <span class=nx>Customer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;++ 顾客#&#34;</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>id</span><span class=p>,</span> <span class=s>&#34;开始饮酒&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=mi>3</span> <span class=o>+</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>16</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;-- 顾客#&#34;</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>id</span><span class=p>,</span> <span class=s>&#34;离开酒吧&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=o>&lt;-</span> <span class=nx>bar</span> <span class=c1>// 离开酒吧，腾出位子</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rand</span><span class=p>.</span><span class=nf>Seed</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>bar24x7</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=nx>Bar</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span> <span class=c1>// 最多同时服务10位顾客</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>customerId</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>;</span> <span class=nx>customerId</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>customer</span> <span class=o>:=</span> <span class=nx>Customer</span><span class=p>{</span><span class=nx>customerId</span><span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>bar24x7</span> <span class=o>&lt;-</span> <span class=nx>customer</span> <span class=c1>// 等待进入酒吧</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=nx>bar24x7</span><span class=p>.</span><span class=nf>ServeCustomer</span><span class=p>(</span><span class=nx>customer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=使用通道传送传输通道special-case>使用通道传送传输通道(special case)<a hidden class=anchor aria-hidden=true href=#使用通道传送传输通道special-case>#</a></h3><p>一个通道类型的元素类型可以是另一个通道类型。 在下面这个例子中， 单向发送通道类型<code>chan&lt;- int</code>是另一个通道类型<code>chan chan&lt;- int</code>的元素类型。</p><p>下面的例子在这个场景其实不是最好的方案，还在关注类似的场景。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>counter</span> <span class=p>=</span> <span class=kd>func</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>requests</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   	<span class=k>for</span> <span class=nx>request</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>requests</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   		<span class=k>if</span> <span class=nx>request</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   			<span class=nx>n</span><span class=o>++</span> <span class=c1>// 递增计数</span>
</span></span><span class=line><span class=cl>   		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   			<span class=nx>request</span> <span class=o>&lt;-</span> <span class=nx>n</span> <span class=c1>// 返回当前计数</span>
</span></span><span class=line><span class=cl>   		<span class=p>}</span>
</span></span><span class=line><span class=cl>   	<span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=p>}()</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=nx>requests</span> <span class=c1>// 隐式转换到类型chan&lt;- (chan&lt;- int)</span>
</span></span><span class=line><span class=cl><span class=p>}(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>increase1000</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>done</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>1000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   		<span class=nx>counter</span> <span class=o>&lt;-</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>   	<span class=p>}</span>
</span></span><span class=line><span class=cl>   	<span class=nx>done</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>   <span class=k>go</span> <span class=nf>increase1000</span><span class=p>(</span><span class=nx>done</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>go</span> <span class=nf>increase1000</span><span class=p>(</span><span class=nx>done</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=o>&lt;-</span><span class=nx>done</span><span class=p>;</span> <span class=o>&lt;-</span><span class=nx>done</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=nx>request</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=nx>counter</span> <span class=o>&lt;-</span> <span class=nx>request</span>
</span></span><span class=line><span class=cl>   <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&lt;-</span><span class=nx>request</span><span class=p>)</span> <span class=c1>// 2000</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=检查通道的长度和容量>检查通道的长度和容量<a hidden class=anchor aria-hidden=true href=#检查通道的长度和容量>#</a></h3><p>我们可以使用内置函数<code>cap</code>和<code>len</code>来查看一个通道的容量和当前长度。 但是在实践中我们很少这样做。我们很少使用内置函数<code>cap</code>的原因是一个通道的容量常常是已知的或者不重要的。 我们很少使用内置函数<code>len</code>的原因是一个**<code>len</code>调用的结果并不能总能准确地反映出的一个通道的当前长度。**</p><p>但有时确实有一些场景需要调用这两个函数。比如，有时一个协程欲将一个未关闭的并且不会再向其中发送数据的缓冲通道中的所有数据接收出来，在确保只有此一个协程从此通道接收数据的情况下，我们可以用下面的代码来实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>value</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>c</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 使用value ...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>不过这种场景可以用尝试接收机制来实现，这两种方式的运行效率差距不大，但尝试接收机制的优点是多个协程可以并发地进行读取操作。</p><p>有时一个协程欲将一个缓冲通道写满而又不阻塞，在确保只有此一个协程向此通道发送数据的情况下，我们可以用下面的代码实现这一目的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span> <span class=p>&lt;</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>aValue</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>当然，尝试发送机制也能cover。</p><h3 id=尝试发送和尝试接收无阻塞selectdefault>尝试发送和尝试接收(无阻塞select/default)<a hidden class=anchor aria-hidden=true href=#尝试发送和尝试接收无阻塞selectdefault>#</a></h3><p>含有一个<code>default</code>分支和一个<code>case</code>分支的<code>select</code>代码块可以被用做一个尝试发送或者尝试接收操作，取决于<code>case</code>关键字后跟随的是一个发送操作还是一个接收操作。</p><ul><li>如果<code>case</code>关键字后跟随的是一个发送操作，则此<code>select</code>代码块为一个尝试发送操作。 如果<code>case</code>分支的发送操作是阻塞的，则<code>default</code>分支将被执行，发送失败；否则发送成功，<code>case</code>分支得到执行。</li><li>如果<code>case</code>关键字后跟随的是一个接收操作，则此<code>select</code>代码块为一个尝试接收操作。 如果<code>case</code>分支的接收操作是阻塞的，则<code>default</code>分支将被执行，接收失败；否则接收成功，<code>case</code>分支得到执行。</li></ul><p><em><strong>尝试发送和尝试接收代码块永不阻塞。</strong></em></p><p>标准编译器对尝试发送和尝试接收代码块做了特别的优化，使得它们的执行效率比多<code>case</code>分支的普通<code>select</code>代码块执行效率高得多。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>type</span> <span class=nx>Book</span> <span class=kd>struct</span><span class=p>{</span><span class=nx>id</span> <span class=kt>int</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>bookshelf</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>Book</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>bookshelf</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>bookshelf</span> <span class=o>&lt;-</span> <span class=nx>Book</span><span class=p>{</span><span class=nx>id</span><span class=p>:</span> <span class=nx>i</span><span class=p>}:</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;成功将书放在书架上&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;书架已经被占满了&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>bookshelf</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>book</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>bookshelf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;成功从书架上取下一本书&#34;</span><span class=p>,</span> <span class=nx>book</span><span class=p>.</span><span class=nx>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;书架上已经没有书了&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出结果很简单:</p><pre tabindex=0><code>成功将书放在书架上 0
成功将书放在书架上 1
成功将书放在书架上 2
书架已经被占满了
书架已经被占满了
书架已经被占满了
成功从书架上取下一本书 0
成功从书架上取下一本书 1
成功从书架上取下一本书 2
书架上已经没有书了
书架上已经没有书了
书架上已经没有书了
</code></pre><h4 id=无阻塞地检查一个通道是否已经关闭>无阻塞地检查一个通道是否已经关闭<a hidden class=anchor aria-hidden=true href=#无阻塞地检查一个通道是否已经关闭>#</a></h4><p>假设我们可以保证没有任何协程会向一个通道发送数据，则我们可以使用下面的代码来（并发安全地）检查此通道是否已经关闭，此检查不会阻塞当前协程。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>IsClosed</span><span class=p>(</span><span class=nx>c</span> <span class=kd>chan</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>c</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>常用场景：此方法常用来查看某个期待中的通知是否已经来临。此通知将由另一个协程通过<strong>关闭一个通道</strong>来发送。</p><h4 id=峰值限制peakburst-limiting>峰值限制（peak/burst limiting）<a hidden class=anchor aria-hidden=true href=#峰值限制peakburst-limiting>#</a></h4><p>通道用作counting semaphore + 通道尝试(发送/接收)可实现峰值限制。<strong>目的是防止过大的并发请求数。</strong></p><p>还是那个酒吧招待客户的例子，现在做一些修改能让顾客不再等待而是离去或者寻找其它酒吧。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl>	<span class=nx>bar24x7</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=nx>Bar</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span> <span class=c1>// 此酒吧只能同时招待10个顾客</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>customerId</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>;</span> <span class=nx>customerId</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>consumer</span> <span class=o>:=</span> <span class=nx>Consumer</span><span class=p>{</span><span class=nx>customerId</span><span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>bar24x7</span> <span class=o>&lt;-</span> <span class=nx>consumer</span><span class=p>:</span> <span class=c1>// 试图进入此酒吧</span>
</span></span><span class=line><span class=cl>			<span class=k>go</span> <span class=nx>bar24x7</span><span class=p>.</span><span class=nf>ServeConsumer</span><span class=p>(</span><span class=nx>consumer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;顾客#&#34;</span><span class=p>,</span> <span class=nx>customerId</span><span class=p>,</span> <span class=s>&#34;不愿等待而离去&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=另一种采用最快回应的实现方式复杂场景用>另一种“采用最快回应”的实现方式(复杂场景用)<a hidden class=anchor aria-hidden=true href=#另一种采用最快回应的实现方式复杂场景用>#</a></h4><p>在上面的“采用最快回应”用例一节已经提到，我们也可以使用选择机制来实现“采用最快回应”用例。 每个数据源协程只需使用一个<strong>缓冲为1的通道</strong>并向其尝试发送回应数据即可。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;math/rand&#34;</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>source</span><span class=p>(</span><span class=nx>c</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>int32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>ra</span><span class=p>,</span> <span class=nx>rb</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Int31</span><span class=p>(),</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 休眠1秒/2秒/3秒</span>
</span></span><span class=line><span class=cl>  <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nx>rb</span><span class=p>)</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>ra</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>rand</span><span class=p>.</span><span class=nf>Seed</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int32</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=c1>// 此通道容量必须至少为1</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  	<span class=k>go</span> <span class=nf>source</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>rnd</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>c</span> <span class=c1>// 只采用第一个成功发送的回应数据</span>
</span></span><span class=line><span class=cl>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>rnd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>注意，使用选择机制来实现“采用最快回应”的代码中使用的通道的容量必须至少为1，以保证最快回应总能够发送成功。 否则，如果数据请求者因为种种原因未及时准备好接收，则所有回应者的尝试发送都将失败，从而所有回应的数据都将被错过。</strong></p><h4 id=少量数据源采用最快回应的实现方式>少量数据源“采用最快回应”的实现方式<a hidden class=anchor aria-hidden=true href=#少量数据源采用最快回应的实现方式>#</a></h4><p>如果一个“采用最快回应”用例中的数据源的数量很少，比如两个或三个，我们可以让每个数据源使用一个单独的缓冲通道来回应数据，然后使用一个<code>select</code>代码块来同时接收这三个通道。 示例代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;math/rand&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>source</span><span class=p>()</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int32</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=c1>// 必须为一个缓冲通道</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>ra</span><span class=p>,</span> <span class=nx>rb</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Int31</span><span class=p>(),</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nx>rb</span><span class=p>)</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>ra</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rand</span><span class=p>.</span><span class=nf>Seed</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>rnd</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 阻塞在此直到某个数据源率先回应。</span>
</span></span><span class=line><span class=cl>	<span class=k>select</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>rnd</span> <span class=p>=</span> <span class=o>&lt;-</span><span class=nf>source</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>rnd</span> <span class=p>=</span> <span class=o>&lt;-</span><span class=nf>source</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>rnd</span> <span class=p>=</span> <span class=o>&lt;-</span><span class=nf>source</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>rnd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>注意：如果上例中使用的通道是非缓冲的，未被选中的<code>case</code>分支对应的两个<code>source</code>函数调用中开辟的协程将处于永久阻塞状态，从而造成内存泄露。</strong></p><h4 id=超时机制timeout>超时机制（timeout）<a hidden class=anchor aria-hidden=true href=#超时机制timeout>#</a></h4><p>在一些请求/回应用例中，一个请求可能因为种种原因导致需要超出预期的时长才能得到回应，有时甚至永远得不到回应。 对于这样的情形，我们可以使用一个超时方案给请求者返回一个错误信息。 使用选择机制可以很轻松地实现这样的一个超时方案。</p><p>下面这个例子展示了如何实现一个支持超时设置的请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>requestWithTimeout</span><span class=p>(</span><span class=nx>timeout</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>doRequest</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span> <span class=c1>// 可能需要超出预期的时长回应</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>data</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>c</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>data</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>time</span><span class=p>.</span><span class=nf>After</span><span class=p>(</span><span class=nx>timeout</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;超时了！&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=脉搏器ticker>脉搏器（ticker）<a hidden class=anchor aria-hidden=true href=#脉搏器ticker>#</a></h4><p>我们可以使用尝试发送操作来实现一个每隔一定时间发送一个信号的脉搏器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Tick</span><span class=p>(</span><span class=nx>d</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=p>)</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=mi>1</span><span class=p>)</span> <span class=c1>// 容量最好为1</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>c</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}:</span>
</span></span><span class=line><span class=cl>			<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>t</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=k>range</span> <span class=nf>Tick</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Since</span><span class=p>(</span><span class=nx>t</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>事实上，<code>time</code>标准库包中的<code>Tick</code>函数提供了同样的功能，但效率更高。 我们应该尽量使用标准库包中的实现。</p><h4 id=速率限制rate-limiting>速率限制（rate limiting）<a hidden class=anchor aria-hidden=true href=#速率限制rate-limiting>#</a></h4><p>前面实现了峰值限制，同样地我们可以使用尝试机制实现速率限制，但是这里要和定时器配合实现。速率限制常用来限制吞吐和确保在一段时间内的资源使用不会超标。</p><p>下面的例子借鉴了<a href=https://github.com/golang/go/wiki/RateLimiting>官方Go维基中的例子</a>。 在此例中，任何一分钟时段内处理的请求数不会超过200</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Request</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>handle</span><span class=p>(</span><span class=nx>r</span> <span class=nx>Request</span><span class=p>)</span> <span class=p>{</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>r</span><span class=p>.(</span><span class=kt>int</span><span class=p>))}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=nx>RateLimitPeriod</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Minute</span>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=nx>RateLimit</span> <span class=p>=</span> <span class=mi>200</span> <span class=c1>// 任何一分钟内最多处理200个请求</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>handleRequests</span><span class=p>(</span><span class=nx>requests</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>quotas</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>,</span> <span class=nx>RateLimit</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>tick</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>NewTicker</span><span class=p>(</span><span class=nx>RateLimitPeriod</span> <span class=o>/</span> <span class=nx>RateLimit</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>tick</span><span class=p>.</span><span class=nf>Stop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>t</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>tick</span><span class=p>.</span><span class=nx>C</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>quotas</span> <span class=o>&lt;-</span> <span class=nx>t</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>r</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>requests</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=o>&lt;-</span><span class=nx>quotas</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=nf>handle</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>requests</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>Request</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>handleRequests</span><span class=p>(</span><span class=nx>requests</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// time.Sleep(time.Minute)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span><span class=nx>requests</span> <span class=o>&lt;-</span> <span class=nx>i</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>上例的代码虽然可以保证任何一分钟时段内处理的请求数不会超过200，但是如果在开始的一分钟内没有任何请求，则接下来的某个瞬时时间点可能会同时处理最多200个请求（试着将<code>time.Sleep</code>行的注释去掉), 这可能会造成卡顿情况。我们可以将<strong>速率限制和峰值限制</strong>一并使用来避免出现这样的情况。</p><h4 id=开关>开关<a hidden class=anchor aria-hidden=true href=#开关>#</a></h4><p>向一个nil通道发送数据或者从中接收数据都属于阻塞操作。 利用这一事实，我们可以将一个<code>select</code>流程控制中的<code>case</code>操作中涉及的通道设置为不同的值，以使此<code>select</code>流程控制选择执行不同的分支。</p><h4 id=控制代码被执行的几率少用>控制代码被执行的几率（少用）<a hidden class=anchor aria-hidden=true href=#控制代码被执行的几率少用>#</a></h4><p>我们可以通过在一个<code>select</code>流程控制中使用重复的<code>case</code>操作来增加对应分支中的代码的执行几率。这种操作比较少见，下面这个例子， 函数<code>f</code>的调用执行几率大致为函数<code>g</code>的两倍:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>foo</span><span class=p>,</span> <span class=nx>bar</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}),</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	<span class=nb>close</span><span class=p>(</span><span class=nx>foo</span><span class=p>);</span> <span class=nb>close</span><span class=p>(</span><span class=nx>bar</span><span class=p>)</span> <span class=c1>// 仅为演示目的</span>
</span></span><span class=line><span class=cl>	<span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=o>:=</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span>
</span></span><span class=line><span class=cl>	<span class=nx>f</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(){</span><span class=nx>x</span><span class=o>++</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(){</span><span class=nx>y</span><span class=o>++</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>foo</span><span class=p>:</span> <span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>foo</span><span class=p>:</span> <span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>bar</span><span class=p>:</span> <span class=nf>g</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>x</span><span class=o>/</span><span class=nx>y</span><span class=p>)</span> <span class=c1>// 大致为2</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=从动态数量的分支中选择少用>从动态数量的分支中选择（少用）<a hidden class=anchor aria-hidden=true href=#从动态数量的分支中选择少用>#</a></h4><p><em>reflection ain&rsquo;t good</em></p><p>每个<code>select</code>控制流程中的分支数量在运行中是固定的，但是我们可以使用<code>reflect</code>标准库包中提供的功能在运行时刻来构建动态分支数量的<code>select</code>控制流程。 但是请注意：一个<code>select</code>控制流程中的分支越多，此<code>select</code>控制流程的执行效率就越低（这是我们常常只使用不多于三个分支的<code>select</code>控制流程的原因）。 <code>reflect</code>标准库包中也提供了模拟尝试发送和尝试接收代码块的<code>TrySend</code>和<code>TryRecv</code>函数。涉及到反射的，肯定有更好的解决方案:-)。</p><h3 id=数据流操纵data-flow>数据流操纵（Data Flow）<a hidden class=anchor aria-hidden=true href=#数据流操纵data-flow>#</a></h3><p>下面把数据流处理程序大致分成了常见的几类，概念上来说是不同模块由一个或者多个并行处理的协程组成：</p><ul><li><p>数据生成/搜集/加载；</p></li><li><p>数据服务/存盘；</p></li><li><p>数据计算/处理；</p></li><li><p>数据验证/过滤；</p></li><li><p>数据聚合/分流；</p></li><li><p>数据组合/拆分；</p></li><li><p>数据复制/增殖；</p><p>一个模块中的工作协程从一些其它模块接收数据做为输入，并向另一些模块发送输出数据。 换句话数，一个模块可能同时兼任数据消费者和数据产生者的角色。多个模块一起组成了一个数据流处理系统。后续的一些实现可能并不高效，只是为了描述这些分类模块的实现，比较简单。</p></li></ul><h4 id=数据生成搜集加载>数据生成/搜集/加载<a hidden class=anchor aria-hidden=true href=#数据生成搜集加载>#</a></h4><p>一个数据产生者可能通过以下途径生成数据：</p><ul><li><p>加载一个文件、或者读取一个数据库、或者用爬虫抓取网页数据；</p></li><li><p>从一个软件或者硬件系统搜集各种数据；</p></li><li><p>产生一系列随机数；</p></li><li><p>etc.</p><p>这里的例子是一个随机数生成器作为数据生产者，生产者只有数据输出，所以返回只读通道。实际上此随机数产生器是一个多返回值的future/promise，<strong>一个数据产生者可以在任何时刻关闭返回的通道以结束数据生成</strong>。</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;crypto/rand&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;encoding/binary&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>RandomGenerator</span><span class=p>()</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>rnds</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>rnds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nb>close</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>  <span class=c1>// 若读取错误则关闭通道结束数据生成</span>
</span></span><span class=line><span class=cl>				<span class=k>break</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>binary</span><span class=p>.</span><span class=nx>BigEndian</span><span class=p>.</span><span class=nf>Uint64</span><span class=p>(</span><span class=nx>rnds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=数据聚合>数据聚合<a hidden class=anchor aria-hidden=true href=#数据聚合>#</a></h4><p>例如把多个数据流合为一个数据流，下面这个函数把任意数量的数据流合为一个：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Aggregator</span><span class=p>(</span><span class=nx>inputs</span> <span class=o>...&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>out</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>in</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>inputs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>in</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>out</span> <span class=o>&lt;-</span> <span class=o>&lt;-</span><span class=nx>in</span> <span class=c1>// &lt;=&gt; out &lt;- (&lt;-in)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>in</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>out</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><img alt="merge cahnnels" loading=lazy src=https://miro.medium.com/max/1400/0*oNO9-NZHuTerKDym.png data-zoomable></p><p>但是这个例子，最好需要考虑一个输入数据流是否已经关闭：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Aggregator</span><span class=p>(</span><span class=nx>inputs</span> <span class=o>...&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>output</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>in</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>inputs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 如果通道in被关闭，此循环将最终结束。</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=nx>x</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>in</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>output</span> <span class=o>&lt;-</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>in</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nb>close</span><span class=p>(</span><span class=nx>output</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>output</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如果被聚合的数据流的数量很小，我们也可以使用一个<code>select</code>控制流程代码块来聚合这些数据流。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 假设数据流的数量为2。</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl>	<span class=nx>output</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>inA</span><span class=p>,</span> <span class=nx>inB</span> <span class=o>:=</span> <span class=nx>inputs</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nx>inputs</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>v</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>inA</span><span class=p>:</span> <span class=nx>output</span> <span class=o>&lt;-</span> <span class=nx>v</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>v</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>inB</span><span class=p>:</span> <span class=nx>output</span> <span class=o>&lt;-</span> <span class=nx>v</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=数据分流>数据分流<a hidden class=anchor aria-hidden=true href=#数据分流>#</a></h4><p>数据分流是数据聚合的逆过程。数据分流的实现很简单，但在实践中用的并不多。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Divisor</span><span class=p>(</span><span class=nx>input</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>,</span> <span class=nx>outputs</span> <span class=o>...</span><span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>out</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>outputs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>o</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>o</span> <span class=o>&lt;-</span> <span class=o>&lt;-</span><span class=nx>input</span> <span class=c1>// &lt;=&gt; o &lt;- (&lt;-input)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=数据合成>数据合成<a hidden class=anchor aria-hidden=true href=#数据合成>#</a></h4><p>数据合成将多个数据流中读取的数据合成一个。</p><p>下面是一个数据合成工作函数的实现中，从两个不同数据流读取的两个<code>uint64</code>值组成了一个新的<code>uint64</code>值。 当然，在实践中，数据的组合比这复杂得多。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Composor</span><span class=p>(</span><span class=nx>inA</span><span class=p>,</span> <span class=nx>inB</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>output</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>a1</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>a2</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>inA</span><span class=p>,</span> <span class=o>&lt;-</span><span class=nx>inB</span><span class=p>,</span> <span class=o>&lt;-</span><span class=nx>inA</span>
</span></span><span class=line><span class=cl>			<span class=nx>output</span> <span class=o>&lt;-</span> <span class=nx>a1</span> <span class=p>^</span> <span class=nx>b</span> <span class=o>&amp;</span> <span class=nx>a2</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>output</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=数据分解>数据分解<a hidden class=anchor aria-hidden=true href=#数据分解>#</a></h4><p>数据分解是数据合成的逆过程。一个数据分解者从一个通道读取一份数据，并将此数据分解为多份数据。 这里就不举例了。</p><h4 id=数据复制增殖>数据复制/增殖<a hidden class=anchor aria-hidden=true href=#数据复制增殖>#</a></h4><p>数据复制（增殖）可以看作是特殊的数据分解。一份输入数据将被复制多份并输出给多个数据流。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Duplicator</span><span class=p>(</span><span class=nx>in</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>(</span><span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>,</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>outA</span><span class=p>,</span> <span class=nx>outB</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>),</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>x</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>in</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>outA</span> <span class=o>&lt;-</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl>			<span class=nx>outB</span> <span class=o>&lt;-</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>outA</span><span class=p>,</span> <span class=nx>outB</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=数据计算分析>数据计算/分析<a hidden class=anchor aria-hidden=true href=#数据计算分析>#</a></h4><p>数据计算和数据分析模块的功能因具体程序不同而有很大的差异。 一般来说，数据分析者接收一份数据并对之加工处理后转换为另一份数据。</p><p>下面的简单示例中，每个输入的<code>uint64</code>值将被进行位反转后输出。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Calculator</span><span class=p>(</span><span class=nx>in</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>,</span> <span class=nx>out</span> <span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>(</span><span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>out</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>out</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>x</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>in</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>out</span> <span class=o>&lt;-</span> <span class=p>^</span><span class=nx>x</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>out</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=数据验证过滤>数据验证/过滤<a hidden class=anchor aria-hidden=true href=#数据验证过滤>#</a></h4><p>一个数据验证或过滤者的任务是检查输入数据的合理性并抛弃不合理的数据。 比如，下面的工作者协程将抛弃所有的非素数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;math/big&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Filter0</span><span class=p>(</span><span class=nx>input</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>,</span> <span class=nx>output</span> <span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>output</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>output</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>bigInt</span> <span class=o>:=</span> <span class=nx>big</span><span class=p>.</span><span class=nf>NewInt</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>x</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>input</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>bigInt</span><span class=p>.</span><span class=nf>SetUint64</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>bigInt</span><span class=p>.</span><span class=nf>ProbablyPrime</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>output</span> <span class=o>&lt;-</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>output</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Filter</span><span class=p>(</span><span class=nx>input</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>Filter0</span><span class=p>(</span><span class=nx>input</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=数据服务存盘>数据服务/存盘<a hidden class=anchor aria-hidden=true href=#数据服务存盘>#</a></h4><p>一般，一个数据服务或者存盘模块为一个数据流系统中的最后一个模块。 这里的实现值是简单地将数据输出到终端。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Printer</span><span class=p>(</span><span class=nx>input</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>x</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>input</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=组装数据流系统>组装数据流系统<a hidden class=anchor aria-hidden=true href=#组装数据流系统>#</a></h4><p>Now，让我们使用上面的模块工作者函数实现来组装一些数据流系统。 组装数据流仅仅是创建一些工作者协程函数调用，并为这些调用指定输入数据流和输出数据流。</p><p>数据流系统例子1（一个流线型系统）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>...</span> <span class=c1>// 上面的模块工作者函数实现</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>Printer</span><span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nf>Filter</span><span class=p>(</span>
</span></span><span class=line><span class=cl>			<span class=nf>Calculator</span><span class=p>(</span>
</span></span><span class=line><span class=cl>				<span class=nf>RandomGenerator</span><span class=p>(),</span> <span class=kc>nil</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><img alt=pipe loading=lazy src=https://gfw.go101.org/article/res/data-flow-linear.png data-zoomable></p><p>数据流系统例子2（一个单向无环图系统）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>...</span> <span class=c1>// 上面的模块工作者函数实现</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>filterA</span> <span class=o>:=</span> <span class=nf>Filter</span><span class=p>(</span><span class=nf>RandomGenerator</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=nx>filterB</span> <span class=o>:=</span> <span class=nf>Filter</span><span class=p>(</span><span class=nf>RandomGenerator</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=nx>filterC</span> <span class=o>:=</span> <span class=nf>Filter</span><span class=p>(</span><span class=nf>RandomGenerator</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=nx>filter</span> <span class=o>:=</span> <span class=nf>Aggregator</span><span class=p>(</span><span class=nx>filterA</span><span class=p>,</span> <span class=nx>filterB</span><span class=p>,</span> <span class=nx>filterC</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>calculatorA</span> <span class=o>:=</span> <span class=nf>Calculator</span><span class=p>(</span><span class=nx>filter</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>calculatorB</span> <span class=o>:=</span> <span class=nf>Calculator</span><span class=p>(</span><span class=nx>filter</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>calculator</span> <span class=o>:=</span> <span class=nf>Aggregator</span><span class=p>(</span><span class=nx>calculatorA</span><span class=p>,</span> <span class=nx>calculatorB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>Printer</span><span class=p>(</span><span class=nx>calculator</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><img alt="no circle" loading=lazy src=https://gfw.go101.org/article/res/data-flow-dag.png data-zoomable></p><p>更复杂的数据流系统可以表示为任何拓扑结构的图。比如一个复杂的数据流系统可能有多个输出模块。 但是有环拓扑结构的数据流系统在实践中很少用。</p><p>从上面两个例子可以看出，使用通道来构建数据流系统是很简单和直观的。而且，通过使用数据聚合模块，我们可以很轻松地实现各个模块的工作协程数量的扇入（fan-in）和扇出（fan-out）。</p><p>事实上，我们也可以使用一个简单的通道来代替数据聚合模块的角色。比如，下面的代码使用两个通道代替了上例中的两个数据聚合器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>...</span> <span class=c1>// 上面的模块工作者函数实现</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c1</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>Filter0</span><span class=p>(</span><span class=nf>RandomGenerator</span><span class=p>(),</span> <span class=nx>c1</span><span class=p>)</span> <span class=c1>// filterA</span>
</span></span><span class=line><span class=cl>	<span class=nf>Filter0</span><span class=p>(</span><span class=nf>RandomGenerator</span><span class=p>(),</span> <span class=nx>c1</span><span class=p>)</span> <span class=c1>// filterB</span>
</span></span><span class=line><span class=cl>	<span class=nf>Filter0</span><span class=p>(</span><span class=nf>RandomGenerator</span><span class=p>(),</span> <span class=nx>c1</span><span class=p>)</span> <span class=c1>// filterC</span>
</span></span><span class=line><span class=cl>	<span class=nx>c2</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>uint64</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>Calculator</span><span class=p>(</span><span class=nx>c1</span><span class=p>,</span> <span class=nx>c2</span><span class=p>)</span> <span class=c1>// calculatorA</span>
</span></span><span class=line><span class=cl>	<span class=nf>Calculator</span><span class=p>(</span><span class=nx>c1</span><span class=p>,</span> <span class=nx>c2</span><span class=p>)</span> <span class=c1>// calculatorB</span>
</span></span><span class=line><span class=cl>	<span class=nf>Printer</span><span class=p>(</span><span class=nx>c2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><img alt="new topo" loading=lazy src=https://gfw.go101.org/article/res/data-flow-dag-b.png data-zoomable></p><p>上面的代码示例并没有太多考虑如何关闭一个数据流，会单独开一个文章介绍。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://pillumina.github.io/posts/programming/golang/channel-graceful/><span class=title>« Prev</span><br><span>Close Channels Gracefully</span>
</a><a class=next href=https://pillumina.github.io/posts/programming/black-magic/><span class=title>Next »</span><br><span>Black Magic</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Channels Concurrency Work-Around on x" href="https://x.com/intent/tweet/?text=Channels%20Concurrency%20Work-Around&amp;url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fchannels%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Channels Concurrency Work-Around on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fchannels%2f&amp;title=Channels%20Concurrency%20Work-Around&amp;summary=Channels%20Concurrency%20Work-Around&amp;source=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fchannels%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Channels Concurrency Work-Around on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fchannels%2f&title=Channels%20Concurrency%20Work-Around"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Channels Concurrency Work-Around on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fchannels%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Channels Concurrency Work-Around on whatsapp" href="https://api.whatsapp.com/send?text=Channels%20Concurrency%20Work-Around%20-%20https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fchannels%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Channels Concurrency Work-Around on telegram" href="https://telegram.me/share/url?text=Channels%20Concurrency%20Work-Around&amp;url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fchannels%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Channels Concurrency Work-Around on ycombinator" href="https://news.ycombinator.com/submitlink?t=Channels%20Concurrency%20Work-Around&u=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fchannels%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://pillumina.github.io/>CctoctoFX</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg></a><div class=reading-progress-bar></div><script src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){const t=document.querySelector(".reading-progress-bar");if(!t)return;const n=document.querySelector(".post-single");if(!n)return;function s(){const e=n.getBoundingClientRect(),s=e.height,o=window.innerHeight,i=window.scrollY||window.pageYOffset,a=i/(s-o)*100;t.style.width=`${Math.min(100,Math.max(0,a))}%`}let e=!1;window.addEventListener("scroll",function(){e||(window.requestAnimationFrame(function(){s(),e=!1}),e=!0)}),s()}),document.addEventListener("DOMContentLoaded",function(){mediumZoom("article img:not(.nozoom)",{margin:24,background:"var(--theme)",scrollOffset:0})})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>