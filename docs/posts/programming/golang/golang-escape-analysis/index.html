<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang逃逸分析 | CctoctoFX</title><meta name=keywords content><meta name=description content="问题： golang函数传参是不是应该和c一样，尽量不要直接传结构体，而是要传结构体指针？
逃逸分析
逃逸分析指的是，在计算机语言编译器优化原理中，分析指针动态范围的方法，和编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中被分配后，其指针有可能被返回或者被全局引用，这种现象就是指针（或引用）的逃逸（Escape）。
其实在java概念中有一个误解 &mdash; new出来的东西都在堆上，栈上存的是它的引用。 这句话在现代JVM上有问题，就是因为逃逸分析机制。简单来说，就是JVM的逃逸分析会在运行时(runtime)检测当前方法栈帧(frame)内new出来的对象的引用，是否被传出当前的栈帧。如果传出，就会发生逃逸，没有传出则不会。对于未发生逃逸的变量，则会直接在栈上分配内存。因为栈上内存由在函数返回时自动回收，而堆上的的内存需要gc去回收，如果程序中有大量逃逸的对象，那么势必会增加gc的压力。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


public void test(){
  List<Integer> a = new ArrayList<>();
  a.add(1); // a 未逃逸，在栈上分配
}

public List<Integer> test1(){
  List<Integer> a = new ArrayList<>();
  a.add(1);
  return a // 发生逃逸，因此分配在堆上
}


区别

不同于JVM运行时的逃逸分析，Golang的逃逸分析是在编译期完成。
golang的逃逸分析只针对指针。一个值引用变量如果没有被取址，那么它永远不可能逃逸。

go version go1.13.4 darwin/amd64
验证某个函数的变量是否发生逃逸的方法：


go run -gcflags &ldquo;-m -l&rdquo; (-m打印逃逸分析信息，-l禁止内联编译)"><meta name=author content="Me"><link rel=canonical href=https://pillumina.github.io/posts/programming/golang/golang-escape-analysis/><link crossorigin=anonymous href=/assets/css/stylesheet.9d388901283682bb45dd422fcaa0d0a2054a3c8ff47c9cc6b2baab15508b1b90.css integrity="sha256-nTiJASg2grtF3UIvyqDQogVKPI/0fJzGsrqrFVCLG5A=" rel="preload stylesheet" as=style><link rel=icon href=https://pillumina.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pillumina.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pillumina.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://pillumina.github.io/apple-touch-icon.png><link rel=mask-icon href=https://pillumina.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://pillumina.github.io/posts/programming/golang/golang-escape-analysis/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>const config={startOnLoad:!0,theme:"neutral",themeVariables:{lineColor:"#0f0f0f"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(0[0],document.querySelectorAll(".language-mermaid"))}</script><link rel=stylesheet href=/css/custom.min.7ca191baf9a98cba901e2771d1f5485af2e39a950ce60a50254e72e853eb373d.css integrity="sha256-fKGRuvmpjLqQHidx0fVIWvLjmpUM5gpQJU5y6FPrNz0="><script>document.addEventListener("DOMContentLoaded",function(){const t=document.querySelectorAll("h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]"),n=document.querySelectorAll(".toc a");if(t.length===0||n.length===0)return;const s={};t.forEach(e=>{s[e.id]=e.offsetTop});function i(){const t=window.scrollY+100;let e="";for(const[n,o]of Object.entries(s))if(t>=o)e=n;else break;return e}function o(){const e=i();if(n.forEach(e=>{e.classList.remove("active")}),e){const t=document.querySelector(`.toc a[href="#${e}"]`);t&&t.classList.add("active")}}let e=!1;window.addEventListener("scroll",function(){e||(window.requestAnimationFrame(function(){o(),e=!1}),e=!0)}),o()})</script><meta property="og:url" content="https://pillumina.github.io/posts/programming/golang/golang-escape-analysis/"><meta property="og:site_name" content="CctoctoFX"><meta property="og:title" content="Golang逃逸分析"><meta property="og:description" content="问题： golang函数传参是不是应该和c一样，尽量不要直接传结构体，而是要传结构体指针？
逃逸分析 逃逸分析指的是，在计算机语言编译器优化原理中，分析指针动态范围的方法，和编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中被分配后，其指针有可能被返回或者被全局引用，这种现象就是指针（或引用）的逃逸（Escape）。
其实在java概念中有一个误解 — new出来的东西都在堆上，栈上存的是它的引用。 这句话在现代JVM上有问题，就是因为逃逸分析机制。简单来说，就是JVM的逃逸分析会在运行时(runtime)检测当前方法栈帧(frame)内new出来的对象的引用，是否被传出当前的栈帧。如果传出，就会发生逃逸，没有传出则不会。对于未发生逃逸的变量，则会直接在栈上分配内存。因为栈上内存由在函数返回时自动回收，而堆上的的内存需要gc去回收，如果程序中有大量逃逸的对象，那么势必会增加gc的压力。
1 2 3 4 5 6 7 8 9 10 public void test(){ List<Integer> a = new ArrayList<>(); a.add(1); // a 未逃逸，在栈上分配 } public List<Integer> test1(){ List<Integer> a = new ArrayList<>(); a.add(1); return a // 发生逃逸，因此分配在堆上 } 区别 不同于JVM运行时的逃逸分析，Golang的逃逸分析是在编译期完成。 golang的逃逸分析只针对指针。一个值引用变量如果没有被取址，那么它永远不可能逃逸。 go version go1.13.4 darwin/amd64 验证某个函数的变量是否发生逃逸的方法：
go run -gcflags “-m -l” (-m打印逃逸分析信息，-l禁止内联编译)"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-23T11:22:18+08:00"><meta property="article:modified_time" content="2020-11-23T11:22:18+08:00"><meta property="og:image" content="https://pillumina.github.io/imgs/icon_head.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://pillumina.github.io/imgs/icon_head.png"><meta name=twitter:title content="Golang逃逸分析"><meta name=twitter:description content="问题： golang函数传参是不是应该和c一样，尽量不要直接传结构体，而是要传结构体指针？
逃逸分析
逃逸分析指的是，在计算机语言编译器优化原理中，分析指针动态范围的方法，和编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中被分配后，其指针有可能被返回或者被全局引用，这种现象就是指针（或引用）的逃逸（Escape）。
其实在java概念中有一个误解 &mdash; new出来的东西都在堆上，栈上存的是它的引用。 这句话在现代JVM上有问题，就是因为逃逸分析机制。简单来说，就是JVM的逃逸分析会在运行时(runtime)检测当前方法栈帧(frame)内new出来的对象的引用，是否被传出当前的栈帧。如果传出，就会发生逃逸，没有传出则不会。对于未发生逃逸的变量，则会直接在栈上分配内存。因为栈上内存由在函数返回时自动回收，而堆上的的内存需要gc去回收，如果程序中有大量逃逸的对象，那么势必会增加gc的压力。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


public void test(){
  List<Integer> a = new ArrayList<>();
  a.add(1); // a 未逃逸，在栈上分配
}

public List<Integer> test1(){
  List<Integer> a = new ArrayList<>();
  a.add(1);
  return a // 发生逃逸，因此分配在堆上
}


区别

不同于JVM运行时的逃逸分析，Golang的逃逸分析是在编译期完成。
golang的逃逸分析只针对指针。一个值引用变量如果没有被取址，那么它永远不可能逃逸。

go version go1.13.4 darwin/amd64
验证某个函数的变量是否发生逃逸的方法：


go run -gcflags &ldquo;-m -l&rdquo; (-m打印逃逸分析信息，-l禁止内联编译)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://pillumina.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming","item":"https://pillumina.github.io/posts/programming/"},{"@type":"ListItem","position":3,"name":"Golang","item":"https://pillumina.github.io/posts/programming/golang/"},{"@type":"ListItem","position":4,"name":"Golang逃逸分析","item":"https://pillumina.github.io/posts/programming/golang/golang-escape-analysis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang逃逸分析","name":"Golang逃逸分析","description":"问题： golang函数传参是不是应该和c一样，尽量不要直接传结构体，而是要传结构体指针？\n逃逸分析 逃逸分析指的是，在计算机语言编译器优化原理中，分析指针动态范围的方法，和编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中被分配后，其指针有可能被返回或者被全局引用，这种现象就是指针（或引用）的逃逸（Escape）。\n其实在java概念中有一个误解 \u0026mdash; new出来的东西都在堆上，栈上存的是它的引用。 这句话在现代JVM上有问题，就是因为逃逸分析机制。简单来说，就是JVM的逃逸分析会在运行时(runtime)检测当前方法栈帧(frame)内new出来的对象的引用，是否被传出当前的栈帧。如果传出，就会发生逃逸，没有传出则不会。对于未发生逃逸的变量，则会直接在栈上分配内存。因为栈上内存由在函数返回时自动回收，而堆上的的内存需要gc去回收，如果程序中有大量逃逸的对象，那么势必会增加gc的压力。\n1 2 3 4 5 6 7 8 9 10 public void test(){ List\u0026lt;Integer\u0026gt; a = new ArrayList\u0026lt;\u0026gt;(); a.add(1); // a 未逃逸，在栈上分配 } public List\u0026lt;Integer\u0026gt; test1(){ List\u0026lt;Integer\u0026gt; a = new ArrayList\u0026lt;\u0026gt;(); a.add(1); return a // 发生逃逸，因此分配在堆上 } 区别 不同于JVM运行时的逃逸分析，Golang的逃逸分析是在编译期完成。 golang的逃逸分析只针对指针。一个值引用变量如果没有被取址，那么它永远不可能逃逸。 go version go1.13.4 darwin/amd64 验证某个函数的变量是否发生逃逸的方法：\ngo run -gcflags \u0026ldquo;-m -l\u0026rdquo; (-m打印逃逸分析信息，-l禁止内联编译)\n","keywords":[],"articleBody":"问题： golang函数传参是不是应该和c一样，尽量不要直接传结构体，而是要传结构体指针？\n逃逸分析 逃逸分析指的是，在计算机语言编译器优化原理中，分析指针动态范围的方法，和编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中被分配后，其指针有可能被返回或者被全局引用，这种现象就是指针（或引用）的逃逸（Escape）。\n其实在java概念中有一个误解 — new出来的东西都在堆上，栈上存的是它的引用。 这句话在现代JVM上有问题，就是因为逃逸分析机制。简单来说，就是JVM的逃逸分析会在运行时(runtime)检测当前方法栈帧(frame)内new出来的对象的引用，是否被传出当前的栈帧。如果传出，就会发生逃逸，没有传出则不会。对于未发生逃逸的变量，则会直接在栈上分配内存。因为栈上内存由在函数返回时自动回收，而堆上的的内存需要gc去回收，如果程序中有大量逃逸的对象，那么势必会增加gc的压力。\n1 2 3 4 5 6 7 8 9 10 public void test(){ List\u003cInteger\u003e a = new ArrayList\u003c\u003e(); a.add(1); // a 未逃逸，在栈上分配 } public List\u003cInteger\u003e test1(){ List\u003cInteger\u003e a = new ArrayList\u003c\u003e(); a.add(1); return a // 发生逃逸，因此分配在堆上 } 区别 不同于JVM运行时的逃逸分析，Golang的逃逸分析是在编译期完成。 golang的逃逸分析只针对指针。一个值引用变量如果没有被取址，那么它永远不可能逃逸。 go version go1.13.4 darwin/amd64 验证某个函数的变量是否发生逃逸的方法：\ngo run -gcflags “-m -l” (-m打印逃逸分析信息，-l禁止内联编译)\ngo tool compile -S xxxx.go | grep runtime.newobject（汇编代码中搜newobject指令，这个指令用于生成堆对象）\n备注： 关于-gcflags “-m -l\"的输出，有两种情况：\nMoved to heap: xxx xxx escapes to heap 二者都表示发生了逃逸，当xxx变量为指针的时候，出现第二种；当xxx变量为值类型时，为上一种，测试代码：\n1 2 3 4 5 6 7 8 type S int func main(){ a := S(0) b := make([]*S, 2) b[0] = \u0026a c := new(S) b[1] = c } Golang逃逸分析 本文探究什么时候，什么情况下会发生逃逸\ncase 1 最基本的情况\n在某个函数中new或者字面量创建出的变量，将其指针作为函数返回值，则该变量一定发生逃逸 下面是例子:\n1 2 3 4 func test() *User{ a := User{} return \u0026a } case 2 需要验证文章开头情况的正确性，也就是当某个值取指针并传给另一个函数的时候，是否有逃逸：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type User struct{ Username string Password string Age\tint } func main(){ a := \"aaa\" u := \u0026User{a, \"123\", 12} Call1(u) } func Call1(u *User){ fmt.Printf(\"%v\", u) } 逃逸情况:\n-\u003e go run -gcflags \"-m -l\" main.go # command-line-arguments ./main.go:18:12: leaking param: u ./main.go:19:12: Call1... argument does bnot escape ./main.go:19:13 u escapes to heap ./main.go:14:23 \u0026User literal escapes to heap 可见发生了逃逸，这里将指针传给一个函数并打印，如果不打印，只对u进行读写：\n1 2 3 4 func Call1(u *User) int{ u.Username = \"bbb\" return u.Age * 20 } 结果:\n-\u003e go run -gcflags \"-m -l\" main.go # command-line-arguments ./main.go:19:12: Call1 u does not escape ./main.go:14:23 main \u0026User literal does not escape 并没有发生逃逸。其实如果只是对u进行读写，不管调用几次函数，传了几次指针，都不会逃逸。所以我们可以怀疑fmt.Printf的源码有问题，可以发现传入的u被赋值给了pp指针的一个成员变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Printf formats according to a format specifier and writes to standard output. // It returns the number of bytes written and any write error encountered. func Printf(format string, a ...interface{}) (n int, err error) { return Fprintf(os.Stdout, format, a...) } // Fprintf formats according to a format specifier and writes to w. // It returns the number of bytes written and any write error encountered. func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) { p := newPrinter() p.doPrintf(format, a) n, err = w.Write(p.buf) p.free() return } // doPrintf里有 // .... p.printArg(a[argNum], rune(c)) // .... func (p *pp) printArg(arg interface{}, verb rune) { p.arg = arg p.value = reflect.Value{} // .... } 这个pp类型的指针p是由构造函数newPrinter返回，根据case1，p一定会发生逃逸，而p引用了传入指针，所以我们可以总结：\n被已经逃逸的变量引用的指针，一定发生逃逸。 case3 上述备注代码的例子：\n1 2 3 4 5 func main(){ a := make([]*int, 1) b := 12 a[0] = \u0026b } 实际上这个代码中, slice a不会逃逸，而被a引用的b会逃逸。类似的情况会发生在map和chan之中\n1 2 3 4 5 6 7 8 9 10 11 12 13 func main(){ a := make([]*int, 1) b := 12 a[0] = \u0026b c := make(map[string]*int) d := 14 c[\"aaa\"] = \u0026d e := make(chan *int, 1) f := 15 e \u003c- \u0026f } 结果可以发现, b, d, f都逃逸了。所以我们可以得出结论：\n被指针类型的slice, map和chan引用的指针一定会发生逃逸。 备注： stack overflow上有人提问为何使用指针的chan比使用值得chan慢%30， 答案就在这里。使用指针的chan发生逃逸，gc拖慢了速度。 总结与深入本质 变量的逃逸，本质由于对于stack栈帧的内存分配，对于函数的调用将开辟一个栈帧frame，在这个栈帧内定义局部变量，当传出栈帧内创建的变量引用到前一个栈帧离去，如果函数结束，那么原来这块栈帧有可能被其他覆盖，这个传出去的引用就有问题。所以编译器把这种函数返回的变量可能在后续被引用的情况，将变量逃逸到堆上是一个非常合理的策略。 GopherCon SG 2019 1. When a value could possibly be reference after the function that constructed the value returns. 2. When the compiler determines a value is too large to fit on the stack. 3. When the compiler doesn't know the size of a value at compile time. 我们得出指针必然逃逸的情况：\n在某个函数中new或者字面量创建出的变量，将其指针作为函数返回，则该变量一定发生逃逸（构造函数返回的指针变量一定逃逸） 被已经逃逸的变量引用的指针，一定发生逃逸 被指针类型slice, map和chan引用的指针，一定发生逃逸 同时我们也得出一些必然不会逃逸的情况：\n指针被未发生逃逸的变量引用 仅仅在函数内对变量做取址操作，而未将指针传出 有些情况可能发生逃逸，也可能不会发生逃逸 ：\n将指针作为入参传给别的函数，这里还是要看指针在被传入的函数中的处理过程，如果发生了上述三种情况，则会逃逸；否则不会发生逃逸。 因此，对于文章开头的问题，我们不能仅仅依据使用值引用作为函数入参可能因为copy导致额外内存开销而放弃这种值引用类型入参的写法。因为如果函数内有造成变量逃逸的操作情形，gc可能会成为程序效率不高的瓶颈。\n对io.Reader的解释 1 2 3 4 5 6 7 8 type Reader struct{ Read(p []byte) (n int, err error) } // Instead of type Reader struct{ Read(n int) (b []byte, err error) } 对于一个Reader来说当然第二种写法更为贴近逻辑，但是根据逃逸分析，第二种写法明显在不断的Read时在堆上产生过多的垃圾。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // escape to heap func main(){ b := read() // use b } func read() []byte{ // return a new slice b := make([]byte, 32) return b } // stay on stack func main(){ b := make([]byte, 32) read(b) // use b } func read(b []byte){ // write into slice } 几点强调 Optimize for correctness, not performance. Go only puts function variables on the stakc if it can prove a variable is not used after the function returned. Sharing down typically stay on the stack (传递指针给函数) Sharing up typically escapes to the heap (返回指针，不过不必须，都加了typically，比如内联可能会让情形不太一样) Ask the compiler to find out 深入逃逸和内联 逃逸的深入解释 ​ 前面尝试了几个例子去分析逃逸的场景，实际上我们还是需要理解其内部机制，才能把收益最大化（开发效率v.s.运行效率）。逃逸分析的本质是当compiler发现函数变量将脱离函数栈的有效域或被函数栈域外的变量所引用时，把变量分配在堆上而不是栈上，分析一些典型的场景：\n上述讨论过的，函数返回变量地址，或者返回包含变量地址的结构体。\n把变量地址写入channel或者sync.Pool，compiler无法获取goroutine如何使用这个变量，也就无法在编译的时候决定变量的生命周期。\n闭包可能导致闭包上下文逃逸，\nslice变量超过cap重新分配时，将在堆上进行，栈的大小毕竟是固定和有限的。\n上述讨论过的把变量地址赋值给可扩容容器（map, slice）时。\n把变量赋给可扩容interface容器（k或v为interface的map，或[]interface）的时候。\n几乎涉及到interface的地方都有可能导致对象逃逸，MyInterface(x).Foo(a)会导致a逃逸，如果a是引用语义(pointer, slice, map etc.)，那么a也会分配到堆上。涉及到interface的很多逃逸优化都很保守，比如reflect.ValueOf(x)会显式调用escapes(x)导致x逃逸。\n我们分析一下slice重分配的场景。这个场景是在堆上发生的，因为slice重分配时，会发生数据迁移，此时会把原本slice len内的元素浅拷贝到新的space。这个浅拷贝会导致新的slice(堆内存)引用了p(栈内存)的内容，而栈内存和堆内存的生命周期不一样，导致了可能出现函数return了以后，堆内存引用无效的栈内存的情形，这无疑会影响到运行的稳定。所以即使slice变量本身没有显式得逃逸，由于隐式的数据迁移，compiler会保守把slice或者map的指针元素逃逸到堆上。\n对于interface相关的，interface{}把值语义变为引用语义，其本质是type+pointer，这个pointer指向实际的data (源码分析开坑)。如果把值语义的变量赋值给interface容器，那么容器会持有变量的引用，所以这个变量会逃逸到堆上分配。\n案例里也分析了，fmt.Printf会导致逃逸，其实fmt.Sprintf或者logrus.Debugf都会导致所有传入参数逃逸，因为不定参数实际上是slice语法糖，编译器无法确定这些函数不会对参数slice进行append操作导致重分配，所以基于保守策略，都会把这些传入的参数分配到堆上以保证浅拷贝是准确的。\n这里我评价golang编译器的逃逸策略为保守应该是比较合适的，好的逃逸分析需要在编译期更深入地理解程序，这无疑非常困难，特别是涉及到interface{}，指针，可扩展容器的时候。\n内联 关于内联我需要在另一篇post中深入讨论，这里简单地说些感受。逃逸分析+GC很好用但是如果没有内联就会显得很昂贵，所有函数返回的地方会有一道“墙”，任何想要从墙逃逸到墙外的变量都会分配到堆上，比如：\n1 2 3 4 5 6 7 8 9 10 11 func NewCoord() *Coord{ return \u0026Coord{ x : 1, z : 2, } } func foo(){ c := NewCoord() return c.x } 像NewCoord这样简单的构造函数都会导致返回值分配在堆上，抽离函数的代价也会更大。所以Go的内联，逃逸分析，GC像是三剑客，共同把其他语言避之不及的指针变得cheap。\nGo1.9开始对内联做了比较大的runtime优化，开始支持mid-stack inline ，并且通过-l编译参数指定内联等级(参数定义)。并且只在-l=4中提供了mid-stack inline，Go官方统计，这大概可以提升9%的性能，不过也增加了11%左右的二进制大小。\nGo1.10做一些interface相关的优化，比如devirtualization , compiler能够知道interface具体对象的情况下(如var i Iface = \u0026myStruct{})可以直接生成对象相关代码调用(而非内联)，无需走interface方法查找。不过目前这个优化还不完善，还不能应用于逃逸分析优化。\nGo1.12开始默认支持了mid-stack inline\n在目前的项目中，似乎还不需要去调整内联参数，因为这个操作是个trade-off，过于激进的内联会导致生成的二进制文件更大你，CPU intstruction cache miss也可能会增加。默认等级的内联大部分时候都工作得很好并且保持稳定，到Go1.13为止，对interface方法的调用还不能被内联（哪怕compiler知道其具体的类型）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 type I interface { F() int } type A struct{ x int y int } func (a *A) F() int { z := a.x + a.y return z } func BenchmarkX(b *testing.B) { b.ReportAllocs() for i:=0; i\u003cb.N; i++ { // F() 会被内联 0.36 ns/op // var a = \u0026A{} // a.F() // 对Interface的方法调用不能被内联 18.4 ns/op var i I = \u0026A{} i.F() } } 对于一些偏底层基础的结构体，像上述的外层抽象了接口interface用于提供简单的对字段的访问设置，按照目前的分析和测试，内联会把字段访问速度提升一个数量级。\nPS： 个人的感受是目前Go interfaced的内联做的不够好，或许可以用公共API返回具体类型而不是interface，比如etcdclient.New, grpc.NewServer这些都是这样实践的，它们通过private fields加public methods让外部用起来像interface一样，但是数据逻辑层可能实践起来比较麻烦，因为Go的访问控制太差。\n","wordCount":"852","inLanguage":"en","image":"https://pillumina.github.io/imgs/icon_head.png","datePublished":"2020-11-23T11:22:18+08:00","dateModified":"2020-11-23T11:22:18+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://pillumina.github.io/posts/programming/golang/golang-escape-analysis/"},"publisher":{"@type":"Organization","name":"CctoctoFX","logo":{"@type":"ImageObject","url":"https://pillumina.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pillumina.github.io/ accesskey=h title="CctoctoFX (Alt + H)"><img src=https://pillumina.github.io/apple-touch-icon.png alt aria-label=logo height=30>CctoctoFX</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pillumina.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://pillumina.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://pillumina.github.io/posts/aiinfra title="AI Infra"><span>AI Infra</span></a></li><li><a href=https://pillumina.github.io/posts/programming title=Programming><span>Programming</span></a></li><li><a href=https://pillumina.github.io/social title=Social><span>Social</span></a></li><li><a href=https://pillumina.github.io/open_courses title=Study><span>Study</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://pillumina.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://pillumina.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://pillumina.github.io/posts/programming/>Programming</a>&nbsp;»&nbsp;<a href=https://pillumina.github.io/posts/programming/golang/>Golang</a></div><h1 class="post-title entry-hint-parent">Golang逃逸分析</h1><div class=post-meta><span title='2020-11-23 11:22:18 +0800 CST'>November 23, 2020</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;852 words&nbsp;·&nbsp;Me</div></header><div class="toc side left"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#逃逸分析>逃逸分析</a></li><li><a href=#区别>区别</a></li><li><a href=#golang逃逸分析>Golang逃逸分析</a><ul><li><a href=#case-1>case 1</a></li><li><a href=#case-2>case 2</a></li><li><a href=#case3>case3</a></li></ul></li><li><a href=#总结与深入本质>总结与深入本质</a></li><li><a href=#对ioreader的解释>对io.Reader的解释</a></li><li><a href=#几点强调>几点强调</a></li><li><a href=#深入逃逸和内联>深入逃逸和内联</a><ul><li><a href=#逃逸的深入解释>逃逸的深入解释</a></li><li><a href=#内联>内联</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p><em><strong>问题： golang函数传参是不是应该和c一样，尽量不要直接传结构体，而是要传结构体指针？</strong></em></p><h2 id=逃逸分析>逃逸分析<a hidden class=anchor aria-hidden=true href=#逃逸分析>#</a></h2><p>逃逸分析指的是，在计算机语言编译器优化原理中，分析指针动态范围的方法，和编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中被分配后，其指针有可能被返回或者被全局引用，这种现象就是指针（或引用）的逃逸（Escape）。</p><p>其实在java概念中有一个误解 &mdash; new出来的东西都在堆上，栈上存的是它的引用。 这句话在现代JVM上有问题，就是因为逃逸分析机制。简单来说，就是JVM的逃逸分析会在运行时(runtime)检测当前方法栈帧(frame)内new出来的对象的引用，是否被传出当前的栈帧。如果传出，就会发生逃逸，没有传出则不会。对于未发生逃逸的变量，则会直接在栈上分配内存。因为栈上内存由在函数返回时自动回收，而堆上的的内存需要gc去回收，如果程序中有大量逃逸的对象，那么势必会增加gc的压力。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>test</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>a</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>1</span><span class=p>);</span><span class=w> </span><span class=c1>// a 未逃逸，在栈上分配</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=nf>test1</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>a</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=c1>// 发生逃逸，因此分配在堆上</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=区别>区别<a hidden class=anchor aria-hidden=true href=#区别>#</a></h2><ul><li>不同于JVM运行时的逃逸分析，Golang的逃逸分析是在编译期完成。</li><li>golang的逃逸分析只针对指针。一个值引用变量如果没有被取址，那么它永远不可能逃逸。</li></ul><pre tabindex=0><code>go version go1.13.4 darwin/amd64
</code></pre><p>验证某个函数的变量是否发生逃逸的方法：</p><ul><li><p>go run -gcflags &ldquo;-m -l&rdquo; (-m打印逃逸分析信息，-l禁止内联编译)</p></li><li><p>go tool compile -S xxxx.go | grep runtime.newobject（汇编代码中搜newobject指令，这个指令用于生成堆对象）</p></li></ul><p>备注： 关于-gcflags &ldquo;-m -l"的输出，有两种情况：</p><ul><li>Moved to heap: xxx</li><li>xxx escapes to heap</li></ul><p>二者都表示发生了逃逸，当xxx变量为指针的时候，出现第二种；当xxx变量为值类型时，为上一种，测试代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>S</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=nx>a</span> <span class=o>:=</span> <span class=nf>S</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>b</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=o>*</span><span class=nx>S</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>b</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>a</span>
</span></span><span class=line><span class=cl>  <span class=nx>c</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>S</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>b</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=golang逃逸分析>Golang逃逸分析<a hidden class=anchor aria-hidden=true href=#golang逃逸分析>#</a></h2><p>本文探究什么时候，什么情况下会发生逃逸</p><h3 id=case-1>case 1<a hidden class=anchor aria-hidden=true href=#case-1>#</a></h3><p>最基本的情况</p><pre tabindex=0><code>在某个函数中new或者字面量创建出的变量，将其指针作为函数返回值，则该变量一定发生逃逸
</code></pre><p>下面是例子:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>test</span><span class=p>()</span> <span class=o>*</span><span class=nx>User</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>a</span> <span class=o>:=</span> <span class=nx>User</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&amp;</span><span class=nx>a</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=case-2>case 2<a hidden class=anchor aria-hidden=true href=#case-2>#</a></h3><p>需要验证文章开头情况的正确性，也就是当某个值取指针并传给另一个函数的时候，是否有逃逸：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>User</span> <span class=kd>struct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>Username</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>  <span class=nx>Password</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>  <span class=nx>Age</span>	<span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=nx>a</span> <span class=o>:=</span> <span class=s>&#34;aaa&#34;</span>
</span></span><span class=line><span class=cl>  <span class=nx>u</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>User</span><span class=p>{</span><span class=nx>a</span><span class=p>,</span> <span class=s>&#34;123&#34;</span><span class=p>,</span> <span class=mi>12</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>Call1</span><span class=p>(</span><span class=nx>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Call1</span><span class=p>(</span><span class=nx>u</span> <span class=o>*</span><span class=nx>User</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%v&#34;</span><span class=p>,</span> <span class=nx>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>逃逸情况:</p><pre tabindex=0><code>-&gt; go run -gcflags &#34;-m -l&#34; main.go
# command-line-arguments
./main.go:18:12: leaking param: u
./main.go:19:12: Call1... argument does bnot escape
./main.go:19:13 u escapes to heap
./main.go:14:23 &amp;User literal escapes to heap
</code></pre><p>可见发生了逃逸，这里将指针传给一个函数并打印，如果不打印，只对u进行读写：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Call1</span><span class=p>(</span><span class=nx>u</span> <span class=o>*</span><span class=nx>User</span><span class=p>)</span> <span class=kt>int</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>u</span><span class=p>.</span><span class=nx>Username</span> <span class=p>=</span> <span class=s>&#34;bbb&#34;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>u</span><span class=p>.</span><span class=nx>Age</span> <span class=o>*</span> <span class=mi>20</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>结果:</p><pre tabindex=0><code>-&gt; go run -gcflags &#34;-m -l&#34; main.go
# command-line-arguments
./main.go:19:12: Call1 u does not escape
./main.go:14:23 main &amp;User literal does not escape
</code></pre><p>并没有发生逃逸。其实如果只是对u进行读写，不管调用几次函数，传了几次指针，都不会逃逸。所以我们可以怀疑fmt.Printf的源码有问题，可以发现传入的u被赋值给了pp指针的一个成员变量</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Printf formats according to a format specifier and writes to standard output.</span>
</span></span><span class=line><span class=cl><span class=c1>// It returns the number of bytes written and any write error encountered.</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Printf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>Fprintf</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Stdout</span><span class=p>,</span> <span class=nx>format</span><span class=p>,</span> <span class=nx>a</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Fprintf formats according to a format specifier and writes to w.</span>
</span></span><span class=line><span class=cl><span class=c1>// It returns the number of bytes written and any write error encountered.</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Fprintf</span><span class=p>(</span><span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>,</span> <span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span> <span class=o>:=</span> <span class=nf>newPrinter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nf>doPrintf</span><span class=p>(</span><span class=nx>format</span><span class=p>,</span> <span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nf>free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// doPrintf里有</span>
</span></span><span class=line><span class=cl><span class=c1>// ....</span>
</span></span><span class=line><span class=cl><span class=nx>p</span><span class=p>.</span><span class=nf>printArg</span><span class=p>(</span><span class=nx>a</span><span class=p>[</span><span class=nx>argNum</span><span class=p>],</span> <span class=nb>rune</span><span class=p>(</span><span class=nx>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1>// ....</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>pp</span><span class=p>)</span> <span class=nf>printArg</span><span class=p>(</span><span class=nx>arg</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>verb</span> <span class=kt>rune</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>arg</span> <span class=p>=</span> <span class=nx>arg</span>
</span></span><span class=line><span class=cl>	<span class=nx>p</span><span class=p>.</span><span class=nx>value</span> <span class=p>=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Value</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ....</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这个pp类型的指针p是由构造函数newPrinter返回，根据case1，p一定会发生逃逸，而p引用了传入指针，所以我们可以总结：</p><pre tabindex=0><code>被已经逃逸的变量引用的指针，一定发生逃逸。
</code></pre><h3 id=case3>case3<a hidden class=anchor aria-hidden=true href=#case3>#</a></h3><p>上述备注代码的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=nx>a</span>  <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=o>*</span><span class=kt>int</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>b</span> <span class=o>:=</span> <span class=mi>12</span>
</span></span><span class=line><span class=cl>  <span class=nx>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>实际上这个代码中, slice a不会逃逸，而被a引用的b会逃逸。类似的情况会发生在map和chan之中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=nx>a</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=o>*</span><span class=kt>int</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>b</span> <span class=o>:=</span> <span class=mi>12</span>
</span></span><span class=line><span class=cl>  <span class=nx>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>b</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=o>*</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>d</span> <span class=o>:=</span> <span class=mi>14</span>
</span></span><span class=line><span class=cl>  <span class=nx>c</span><span class=p>[</span><span class=s>&#34;aaa&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>d</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nx>e</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=o>*</span><span class=kt>int</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>f</span> <span class=o>:=</span> <span class=mi>15</span>
</span></span><span class=line><span class=cl>  <span class=nx>e</span> <span class=o>&lt;-</span> <span class=o>&amp;</span><span class=nx>f</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>结果可以发现, b, d, f都逃逸了。所以我们可以得出结论：</p><pre tabindex=0><code>被指针类型的slice, map和chan引用的指针一定会发生逃逸。
备注： stack overflow上有人提问为何使用指针的chan比使用值得chan慢%30， 答案就在这里。使用指针的chan发生逃逸，gc拖慢了速度。
</code></pre><h2 id=总结与深入本质>总结与深入本质<a hidden class=anchor aria-hidden=true href=#总结与深入本质>#</a></h2><pre tabindex=0><code>变量的逃逸，本质由于对于stack栈帧的内存分配，对于函数的调用将开辟一个栈帧frame，在这个栈帧内定义局部变量，当传出栈帧内创建的变量引用到前一个栈帧离去，如果函数结束，那么原来这块栈帧有可能被其他覆盖，这个传出去的引用就有问题。所以编译器把这种函数返回的变量可能在后续被引用的情况，将变量逃逸到堆上是一个非常合理的策略。
GopherCon SG 2019
1. When a value could possibly be reference after the function that constructed the value returns.
2. When the compiler determines a value is too large to fit on the stack.
3. When the compiler doesn&#39;t know the size of a value at compile time.
</code></pre><p>我们得出指针<strong>必然逃逸</strong>的情况：</p><ul><li>在某个函数中new或者字面量创建出的变量，将其指针作为函数返回，则该变量一定发生逃逸（构造函数返回的指针变量一定逃逸）</li><li>被已经逃逸的变量引用的指针，一定发生逃逸</li><li>被指针类型slice, map和chan引用的指针，一定发生逃逸</li></ul><p>同时我们也得出一些<strong>必然不会逃逸</strong>的情况：</p><ul><li>指针被未发生逃逸的变量引用</li><li>仅仅在函数内对变量做取址操作，而未将指针传出</li></ul><p>有些情况<strong>可能发生逃逸，也可能不会发生逃逸</strong> ：</p><ul><li>将指针作为入参传给别的函数，这里还是要看指针在被传入的函数中的处理过程，如果发生了上述三种情况，则会逃逸；否则不会发生逃逸。</li></ul><p><em><strong>因此，对于文章开头的问题，我们不能仅仅依据使用值引用作为函数入参可能因为copy导致额外内存开销而放弃这种值引用类型入参的写法。因为如果函数内有造成变量逃逸的操作情形，gc可能会成为程序效率不高的瓶颈。</strong></em></p><h2 id=对ioreader的解释>对io.Reader的解释<a hidden class=anchor aria-hidden=true href=#对ioreader的解释>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Reader</span> <span class=kd>struct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>Read</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Instead of </span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Reader</span> <span class=kd>struct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>Read</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>对于一个Reader来说当然第二种写法更为贴近逻辑，但是根据逃逸分析，第二种写法明显在不断的Read时在堆上产生过多的垃圾。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// escape to heap</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=nx>b</span> <span class=o>:=</span> <span class=nf>read</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=c1>// use b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>read</span><span class=p>()</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// return a new slice</span>
</span></span><span class=line><span class=cl>  <span class=nx>b</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// stay on stack</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=nx>b</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nf>read</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c1>// use b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>read</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=c1>// write into slice</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=几点强调>几点强调<a hidden class=anchor aria-hidden=true href=#几点强调>#</a></h2><ul><li>Optimize for correctness, not performance.</li><li>Go only puts function variables on the stakc if it can prove a variable is not used after the function returned.</li><li>Sharing down typically stay on the stack (传递指针给函数)</li><li>Sharing up typically escapes to the heap (返回指针，不过不必须，都加了typically，比如内联可能会让情形不太一样)</li><li>Ask the compiler to find out</li></ul><h2 id=深入逃逸和内联>深入逃逸和内联<a hidden class=anchor aria-hidden=true href=#深入逃逸和内联>#</a></h2><h3 id=逃逸的深入解释>逃逸的深入解释<a hidden class=anchor aria-hidden=true href=#逃逸的深入解释>#</a></h3><p>​ 前面尝试了几个例子去分析逃逸的场景，实际上我们还是需要理解其内部机制，才能把收益最大化（开发效率v.s.运行效率）。逃逸分析的本质是当compiler发现函数变量将脱离函数栈的有效域或被函数栈域外的变量所引用时，把变量分配在堆上而不是栈上，分析一些典型的场景：</p><ul><li><p>上述讨论过的，函数返回变量地址，或者返回包含变量地址的结构体。</p></li><li><p>把变量地址写入channel或者sync.Pool，compiler无法获取goroutine如何使用这个变量，也就无法在编译的时候决定变量的生命周期。</p></li><li><p>闭包可能导致闭包上下文逃逸，</p></li><li><p>slice变量超过cap重新分配时，将在堆上进行，栈的大小毕竟是固定和有限的。</p></li><li><p>上述讨论过的把变量地址赋值给可扩容容器（map, slice）时。</p></li><li><p>把变量赋给可扩容interface容器（k或v为interface的map，或[]interface）的时候。</p></li><li><p>几乎涉及到interface的地方都有可能导致对象逃逸，MyInterface(x).Foo(a)会导致a逃逸，如果a是引用语义(pointer, slice, map etc.)，那么a也会分配到堆上。涉及到interface的很多逃逸优化都很保守，比如reflect.ValueOf(x)会显式调用escapes(x)导致x逃逸。</p><p>我们分析一下slice重分配的场景。这个场景是在堆上发生的，因为slice重分配时，会发生数据迁移，此时会把原本slice len内的元素<strong>浅拷贝</strong>到新的space。这个浅拷贝会导致新的slice(堆内存)引用了p(栈内存)的内容，而栈内存和堆内存的生命周期不一样，导致了可能出现函数return了以后，堆内存引用无效的栈内存的情形，这无疑会影响到运行的稳定。所以即使slice变量本身没有显式得逃逸，由于隐式的数据迁移，compiler会保守把slice或者map的指针元素逃逸到堆上。</p><p>对于interface相关的，interface{}把值语义变为引用语义，其本质是type+pointer，这个pointer指向实际的data (源码分析开坑)。如果把值语义的变量赋值给interface容器，那么容器会持有变量的引用，所以这个变量会逃逸到堆上分配。</p><p>案例里也分析了，fmt.Printf会导致逃逸，其实fmt.Sprintf或者logrus.Debugf都会导致所有传入参数逃逸，因为不定参数实际上是slice语法糖，编译器无法确定这些函数不会对参数slice进行append操作导致重分配，所以基于保守策略，都会把这些传入的参数分配到堆上以保证浅拷贝是准确的。</p><p>这里我评价golang编译器的逃逸策略为保守应该是比较合适的，好的逃逸分析需要在编译期更深入地理解程序，这无疑非常困难，特别是涉及到interface{}，指针，可扩展容器的时候。</p></li></ul><h3 id=内联>内联<a hidden class=anchor aria-hidden=true href=#内联>#</a></h3><p>关于内联我需要在另一篇post中深入讨论，这里简单地说些感受。逃逸分析+GC很好用但是如果没有内联就会显得很昂贵，所有函数返回的地方会有一道“墙”，任何想要从墙逃逸到墙外的变量都会分配到堆上，比如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewCoord</span><span class=p>()</span> <span class=o>*</span><span class=nx>Coord</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&amp;</span><span class=nx>Coord</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>x</span> <span class=p>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>z</span> <span class=p>:</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>foo</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=nx>c</span> <span class=o>:=</span> <span class=nf>NewCoord</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nx>x</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>像NewCoord这样简单的构造函数都会导致返回值分配在堆上，抽离函数的代价也会更大。所以Go的内联，逃逸分析，GC像是三剑客，共同把其他语言避之不及的指针变得cheap。</p><p>Go1.9开始对内联做了比较大的runtime优化，开始支持<a href=https://go.googlesource.com/proposal/+/master/design/19348-midstack-inlining.md>mid-stack inline</a> ，并且通过<code>-l</code>编译参数指定内联等级(<a href=https://golang.org/src/cmd/compile/internal/gc/inl.go>参数定义</a>)。并且只在<code>-l=4</code>中提供了mid-stack inline，Go官方统计，这大概可以提升9%的性能，不过也增加了11%左右的二进制大小。</p><p>Go1.10做一些interface相关的优化，比如<a href=https://github.com/golang/go/issues/19361>devirtualization</a> , compiler能够知道interface具体对象的情况下(如<code>var i Iface = &amp;myStruct{}</code>)可以直接生成对象相关代码调用(而非内联)，无需走interface方法查找。不过目前这个优化还不完善，还不能应用于逃逸分析优化。</p><p>Go1.12开始默认支持了mid-stack inline</p><p>在目前的项目中，似乎还不需要去调整内联参数，因为这个操作是个trade-off，过于激进的内联会导致生成的二进制文件更大你，CPU intstruction cache miss也可能会增加。默认等级的内联大部分时候都工作得很好并且保持稳定，到Go1.13为止，对interface方法的调用还不能被内联（哪怕compiler知道其具体的类型）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>I</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>F</span><span class=p>()</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>A</span> <span class=kd>struct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>x</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>  <span class=nx>y</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>a</span> <span class=o>*</span><span class=nx>A</span><span class=p>)</span> <span class=nf>F</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>z</span> <span class=o>:=</span> <span class=nx>a</span><span class=p>.</span><span class=nx>x</span> <span class=o>+</span> <span class=nx>a</span><span class=p>.</span><span class=nx>y</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>z</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkX</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>b</span><span class=p>.</span><span class=nf>ReportAllocs</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span><span class=o>:=</span><span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  	<span class=c1>// F() 会被内联 0.36 ns/op</span>
</span></span><span class=line><span class=cl>  	<span class=c1>// var a = &amp;A{}</span>
</span></span><span class=line><span class=cl>  	<span class=c1>// a.F()</span>
</span></span><span class=line><span class=cl>  	<span class=c1>// 对Interface的方法调用不能被内联 18.4 ns/op</span>
</span></span><span class=line><span class=cl>  	<span class=kd>var</span> <span class=nx>i</span> <span class=nx>I</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>A</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>  	<span class=nx>i</span><span class=p>.</span><span class=nf>F</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>对于一些偏底层基础的结构体，像上述的外层抽象了接口interface用于提供简单的对字段的访问设置，按照目前的分析和测试，内联会把字段访问速度提升一个数量级。</p><p><strong>PS： 个人的感受是目前Go interfaced的内联做的不够好，或许可以用公共API返回具体类型而不是interface，比如etcdclient.New, grpc.NewServer这些都是这样实践的，它们通过private fields加public methods让外部用起来像interface一样，但是数据逻辑层可能实践起来比较麻烦，因为Go的访问控制太差。</strong></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://pillumina.github.io/posts/programming/golang/memory-management/><span class=title>« Prev</span><br><span>Golang内存管理</span>
</a><a class=next href=https://pillumina.github.io/posts/programming/design-pattern/design-pattern/><span class=title>Next »</span><br><span>Design Pattern: Overview</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang逃逸分析 on x" href="https://x.com/intent/tweet/?text=Golang%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90&amp;url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgolang-escape-analysis%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang逃逸分析 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgolang-escape-analysis%2f&amp;title=Golang%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90&amp;summary=Golang%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90&amp;source=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgolang-escape-analysis%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang逃逸分析 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgolang-escape-analysis%2f&title=Golang%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang逃逸分析 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgolang-escape-analysis%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang逃逸分析 on whatsapp" href="https://api.whatsapp.com/send?text=Golang%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90%20-%20https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgolang-escape-analysis%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang逃逸分析 on telegram" href="https://telegram.me/share/url?text=Golang%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90&amp;url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgolang-escape-analysis%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang逃逸分析 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Golang%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90&u=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgolang-escape-analysis%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://pillumina.github.io/>CctoctoFX</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg></a><div class=reading-progress-bar></div><script src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){const t=document.querySelector(".reading-progress-bar");if(!t)return;const n=document.querySelector(".post-single");if(!n)return;function s(){const e=n.getBoundingClientRect(),s=e.height,o=window.innerHeight,i=window.scrollY||window.pageYOffset,a=i/(s-o)*100;t.style.width=`${Math.min(100,Math.max(0,a))}%`}let e=!1;window.addEventListener("scroll",function(){e||(window.requestAnimationFrame(function(){s(),e=!1}),e=!0)}),s()}),document.addEventListener("DOMContentLoaded",function(){mediumZoom("article img:not(.nozoom)",{margin:24,background:"var(--theme)",scrollOffset:0})})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>