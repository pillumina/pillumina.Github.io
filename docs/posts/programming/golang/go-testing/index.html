<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang TDD | CctoctoFX</title><meta name=keywords content><meta name=description content='Preface
本文整理golang编码的单元测试常用示例，以及TDD的简要流程。
单元测试基础
单元测试文件以_test.go结尾，需要记住以下原则：

文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码
你必须import testing这个包
所有的测试用例函数必须是Test开头
测试用例会按照源代码中写的顺序依次执行
测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态
测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如Testintdiv是错误的函数名。
函数中通过调用testing.T的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息。

Table-Driven-Testing
测试讲究 case 覆盖，当我们要覆盖更多 case 时，显然通过修改代码的方式很笨拙。这时我们可以采用 Table-Driven 的方式写测试，标准库中有很多测试是使用这种方式写的。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21


func TestFib(t *testing.T) {
    var fibTests = []struct {
        in       int // input
        expected int // expected result
    }{
        {1, 1},
        {2, 1},
        {3, 2},
        {4, 3},
        {5, 5},
        {6, 8},
        {7, 13},
    }

    for _, tt := range fibTests {
        actual := Fib(tt.in)
        if actual != tt.expected {
            t.Errorf("Fib(%d) = %d; expected %d", tt.in, actual, tt.expected)
        }
    }
}


由于我们使用的是 t.Errorf，即使其中某个 case 失败，也不会终止测试执行。'><meta name=author content="Me"><link rel=canonical href=https://pillumina.github.io/posts/programming/golang/go-testing/><link crossorigin=anonymous href=/assets/css/stylesheet.9d388901283682bb45dd422fcaa0d0a2054a3c8ff47c9cc6b2baab15508b1b90.css integrity="sha256-nTiJASg2grtF3UIvyqDQogVKPI/0fJzGsrqrFVCLG5A=" rel="preload stylesheet" as=style><link rel=icon href=https://pillumina.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pillumina.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pillumina.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://pillumina.github.io/apple-touch-icon.png><link rel=mask-icon href=https://pillumina.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://pillumina.github.io/posts/programming/golang/go-testing/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>const config={startOnLoad:!0,theme:"neutral",themeVariables:{lineColor:"#0f0f0f"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(0[0],document.querySelectorAll(".language-mermaid"))}</script><link rel=stylesheet href=/css/custom.min.bda7229c4269a242639e058fb11a4782f02f8d77071ba16609befee67cc41c49.css integrity="sha256-vacinEJpokJjngWPsRpHgvAvjXcHG6FmCb7+5nzEHEk="><script>document.addEventListener("DOMContentLoaded",function(){const t=document.querySelectorAll("h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]"),n=document.querySelectorAll(".toc a");if(t.length===0||n.length===0)return;const s={};t.forEach(e=>{s[e.id]=e.offsetTop});function i(){const t=window.scrollY+100;let e="";for(const[n,o]of Object.entries(s))if(t>=o)e=n;else break;return e}function o(){const e=i();if(n.forEach(e=>{e.classList.remove("active")}),e){const t=document.querySelector(`.toc a[href="#${e}"]`);t&&t.classList.add("active")}}let e=!1;window.addEventListener("scroll",function(){e||(window.requestAnimationFrame(function(){o(),e=!1}),e=!0)}),o()})</script><meta property="og:url" content="https://pillumina.github.io/posts/programming/golang/go-testing/"><meta property="og:site_name" content="CctoctoFX"><meta property="og:title" content="Golang TDD"><meta property="og:description" content='Preface 本文整理golang编码的单元测试常用示例，以及TDD的简要流程。
单元测试基础 单元测试文件以_test.go结尾，需要记住以下原则：
文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 你必须import testing这个包 所有的测试用例函数必须是Test开头 测试用例会按照源代码中写的顺序依次执行 测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态 测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如Testintdiv是错误的函数名。 函数中通过调用testing.T的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息。 Table-Driven-Testing 测试讲究 case 覆盖，当我们要覆盖更多 case 时，显然通过修改代码的方式很笨拙。这时我们可以采用 Table-Driven 的方式写测试，标准库中有很多测试是使用这种方式写的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func TestFib(t *testing.T) { var fibTests = []struct { in int // input expected int // expected result }{ {1, 1}, {2, 1}, {3, 2}, {4, 3}, {5, 5}, {6, 8}, {7, 13}, } for _, tt := range fibTests { actual := Fib(tt.in) if actual != tt.expected { t.Errorf("Fib(%d) = %d; expected %d", tt.in, actual, tt.expected) } } } 由于我们使用的是 t.Errorf，即使其中某个 case 失败，也不会终止测试执行。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-19T11:22:18+08:00"><meta property="article:modified_time" content="2020-12-19T11:22:18+08:00"><meta property="og:image" content="https://pillumina.github.io/imgs/icon_head.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://pillumina.github.io/imgs/icon_head.png"><meta name=twitter:title content="Golang TDD"><meta name=twitter:description content='Preface
本文整理golang编码的单元测试常用示例，以及TDD的简要流程。
单元测试基础
单元测试文件以_test.go结尾，需要记住以下原则：

文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码
你必须import testing这个包
所有的测试用例函数必须是Test开头
测试用例会按照源代码中写的顺序依次执行
测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态
测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如Testintdiv是错误的函数名。
函数中通过调用testing.T的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息。

Table-Driven-Testing
测试讲究 case 覆盖，当我们要覆盖更多 case 时，显然通过修改代码的方式很笨拙。这时我们可以采用 Table-Driven 的方式写测试，标准库中有很多测试是使用这种方式写的。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21


func TestFib(t *testing.T) {
    var fibTests = []struct {
        in       int // input
        expected int // expected result
    }{
        {1, 1},
        {2, 1},
        {3, 2},
        {4, 3},
        {5, 5},
        {6, 8},
        {7, 13},
    }

    for _, tt := range fibTests {
        actual := Fib(tt.in)
        if actual != tt.expected {
            t.Errorf("Fib(%d) = %d; expected %d", tt.in, actual, tt.expected)
        }
    }
}


由于我们使用的是 t.Errorf，即使其中某个 case 失败，也不会终止测试执行。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://pillumina.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming","item":"https://pillumina.github.io/posts/programming/"},{"@type":"ListItem","position":3,"name":"Golang","item":"https://pillumina.github.io/posts/programming/golang/"},{"@type":"ListItem","position":4,"name":"Golang TDD","item":"https://pillumina.github.io/posts/programming/golang/go-testing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang TDD","name":"Golang TDD","description":"Preface 本文整理golang编码的单元测试常用示例，以及TDD的简要流程。\n单元测试基础 单元测试文件以_test.go结尾，需要记住以下原则：\n文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 你必须import testing这个包 所有的测试用例函数必须是Test开头 测试用例会按照源代码中写的顺序依次执行 测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态 测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如Testintdiv是错误的函数名。 函数中通过调用testing.T的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息。 Table-Driven-Testing 测试讲究 case 覆盖，当我们要覆盖更多 case 时，显然通过修改代码的方式很笨拙。这时我们可以采用 Table-Driven 的方式写测试，标准库中有很多测试是使用这种方式写的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func TestFib(t *testing.T) { var fibTests = []struct { in int // input expected int // expected result }{ {1, 1}, {2, 1}, {3, 2}, {4, 3}, {5, 5}, {6, 8}, {7, 13}, } for _, tt := range fibTests { actual := Fib(tt.in) if actual != tt.expected { t.Errorf(\u0026#34;Fib(%d) = %d; expected %d\u0026#34;, tt.in, actual, tt.expected) } } } 由于我们使用的是 t.Errorf，即使其中某个 case 失败，也不会终止测试执行。\n","keywords":[],"articleBody":"Preface 本文整理golang编码的单元测试常用示例，以及TDD的简要流程。\n单元测试基础 单元测试文件以_test.go结尾，需要记住以下原则：\n文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 你必须import testing这个包 所有的测试用例函数必须是Test开头 测试用例会按照源代码中写的顺序依次执行 测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态 测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如Testintdiv是错误的函数名。 函数中通过调用testing.T的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息。 Table-Driven-Testing 测试讲究 case 覆盖，当我们要覆盖更多 case 时，显然通过修改代码的方式很笨拙。这时我们可以采用 Table-Driven 的方式写测试，标准库中有很多测试是使用这种方式写的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func TestFib(t *testing.T) { var fibTests = []struct { in int // input expected int // expected result }{ {1, 1}, {2, 1}, {3, 2}, {4, 3}, {5, 5}, {6, 8}, {7, 13}, } for _, tt := range fibTests { actual := Fib(tt.in) if actual != tt.expected { t.Errorf(\"Fib(%d) = %d; expected %d\", tt.in, actual, tt.expected) } } } 由于我们使用的是 t.Errorf，即使其中某个 case 失败，也不会终止测试执行。\nT类型 单元测试中，传递给测试函数的参数是 *testing.T 类型。它用于管理测试状态并支持格式化测试日志。测试日志会在执行测试的过程中不断累积，并在测试完成时转储至标准输出。\n当测试函数返回时，或者当测试函数调用 FailNow、 Fatal、Fatalf、SkipNow、Skip、Skipf 中的任意一个时，则宣告该测试函数结束。跟 Parallel 方法一样，以上提到的这些方法只能在运行测试函数的 goroutine 中调用。\n至于其他报告方法，比如 Log 以及 Error 的变种， 则可以在多个 goroutine 中同时进行调用。\n报告方式 上面提到的系列包括方法，带 f 的是格式化的，格式化语法参考 fmt 包。\nT 类型内嵌了 common 类型，common 提供这一系列方法，我们经常会用到的（注意，这里说的测试中断，都是指当前测试函数）：\n1）当我们遇到一个断言错误的时候，标识这个测试失败，会使用到：\nFail : 测试失败，测试继续，也就是之后的代码依然会执行 FailNow : 测试失败，测试中断 在 FailNow 方法实现的内部，是通过调用 runtime.Goexit() 来中断测试的。\n2）当我们遇到一个断言错误，只希望跳过这个错误，但是不希望标识测试失败，会使用到：\nSkipNow : 跳过测试，测试中断 在 SkipNow 方法实现的内部，是通过调用 runtime.Goexit() 来中断测试的。\n3）当我们只希望打印信息，会用到 :\nLog : 输出信息 Logf : 输出格式化的信息 注意：默认情况下，单元测试成功时，它们打印的信息不会输出，可以通过加上 -v 选项，输出这些信息。但对于基准测试，它们总是会被输出。\n4）当我们希望跳过这个测试，并且打印出信息，会用到：\nSkip : 相当于 Log + SkipNow Skipf : 相当于 Logf + SkipNow 5）当我们希望断言失败的时候，标识测试失败，并打印出必要的信息，但是测试继续，会用到：\nError : 相当于 Log + Fail Errorf : 相当于 Logf + Fail 6）当我们希望断言失败的时候，标识测试失败，打印出必要的信息，但中断测试，会用到：\nFatal : 相当于 Log + FailNow Fatalf : 相当于 Logf + FailNow Parallel并行测试 这里简单测试一个对Map的读写并行测试。注意：Parallel方法表示只与其他带有Parallel方法的测试并行进行测试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var ( data = make(map[string]string) locker sync.RWMutex ) func WriteToMap(k, v string) { locker.Lock() defer locker.Unlock() data[k] = v } func ReadFromMap(k string) string { locker.RLock() defer locker.RUnlock() return data[k] } 测试用例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 var pairs = []struct { k string v string }{ {\"polaris\", \"calvin1\"}, {\"studygolang\", \"oops1\"}, {\"stdlib\", \"go demo1\"}, {\"polaris1\", \"calvin2\"}, {\"studygolang1\", \"oops2\"}, {\"stdlib1\", \"go demo2\"}, {\"polaris2\", \" calvin3\"}, } // 注意 TestWriteToMap 需要在 TestReadFromMap 之前 func TestWriteToMap(t *testing.T) { t.Parallel() for _, tt := range pairs { WriteToMap(tt.k, tt.v) } } func TestReadFromMap(t *testing.T) { t.Parallel() for _, tt := range pairs { actual := ReadFromMap(tt.k) if actual != tt.v { t.Errorf(\"the value of key(%s) is %s, expected: %s\", tt.k, actual, tt.v) } } } 试验步骤：\n注释掉 WriteToMap 和 ReadFromMap 中 locker 保护的代码，同时注释掉测试代码中的 t.Parallel，执行测试，测试通过，即使加上 -race，测试依然通过； 只注释掉 WriteToMap 和 ReadFromMap 中 locker 保护的代码，执行测试，测试失败（如果未失败，加上 -race 一定会失败）； 如果代码能够进行并行测试，在写测试时，尽量加上 Parallel，这样可以测试出一些可能的问题。\n子测试与子基准测试(Run) Go1.7开始引入的特性，即能够执行嵌套测试，对于过滤执行特性测试用例非常有用。\nT 和 B 的 Run 方法允许定义子单元测试和子基准测试，而不必为它们单独定义函数。这便于创建基于 Table-Driven 的基准测试和层级测试。它还提供了一种共享通用 setup 和 tear-down 代码的方法：\n1 2 3 4 5 6 7 func TestFoo(t *testing.T) { // t.Run(\"A=1\", func(t *testing.T) { ... }) t.Run(\"A=2\", func(t *testing.T) { ... }) t.Run(\"B=1\", func(t *testing.T) { ... }) // } 每个子测试和子基准测试都有一个唯一的名称：由顶层测试的名称与传递给 Run 的名称组成，以斜杠分隔，并具有可选的尾随序列号，用于消除歧义。\n命令行标志 -run 和 -bench 的参数是非固定的正则表达式，用于匹配测试名称。对于由斜杠分隔的测试名称，例如子测试的名称，它名称本身即可作为参数，依次匹配由斜杠分隔的每部分名称。因为参数是非固定的，一个空的表达式匹配任何字符串，所以下述例子中的 “匹配” 意味着 “顶层/子测试名称包含有”：\ngo test -run '' # 执行所有测试。 go test -run Foo # 执行匹配 \"Foo\" 的顶层测试，例如 \"TestFooBar\"。 go test -run Foo/A= # 对于匹配 \"Foo\" 的顶层测试，执行其匹配 \"A=\" 的子测试。 go test -run /A=1 # 执行所有匹配 \"A=1\" 的子测试。 子测试也可用于程序并行控制。只有子测试全部执行完毕后，父测试才会完成。在下述例子中，所有子测试之间并行运行，此处的 “并行” 只限于这些子测试之间，并不影响定义在其他顶层测试中的子测试：\n1 2 3 4 5 6 7 8 9 func TestGroupedParallel(t *testing.T) { for _, tc := range tests { tc := tc // capture range variable t.Run(tc.Name, func(t *testing.T) { t.Parallel() ... }) } } 在所有子测试并行运行完毕之前，Run 方法不会返回。下述例子提供了一种方法，用于在子测试并行运行完毕后清理资源：\n1 2 3 4 5 6 7 8 9 func TestTeardownParallel(t *testing.T) { // This Run will not return until the parallel tests finish. t.Run(\"group\", func(t *testing.T) { t.Run(\"Test1\", parallelTest1) t.Run(\"Test2\", parallelTest2) t.Run(\"Test3\", parallelTest3) }) // } Test Coverage 测试覆盖率，这里讨论的是基于代码的测试覆盖率。\nGo 从 1.2 开始，引入了对测试覆盖率的支持，使用的是与 cover 相关的工具（go test -cover、go tool cover）。虽然 testing 包提供了 cover 相关函数，不过它们是给 cover 的工具使用的。\n关于测试覆盖率的更多信息，可以参考官方的博文：The cover story\ngotest变量(参考) gotest 的变量有这些：\ntest.short : 一个快速测试的标记，在测试用例中可以使用 testing.Short() 来绕开一些测试 test.outputdir : 输出目录 test.coverprofile : 测试覆盖率参数，指定输出文件 test.run : 指定正则来运行某个 / 某些测试用例 test.memprofile : 内存分析参数，指定输出文件 test.memprofilerate : 内存分析参数，内存分析的抽样率 test.cpuprofile : cpu 分析输出参数，为空则不做 cpu 分析 test.blockprofile : 阻塞事件的分析参数，指定输出文件 test.blockprofilerate : 阻塞事件的分析参数，指定抽样频率 test.timeout : 超时时间 test.cpu : 指定 cpu 数量 test.parallel : 指定运行测试用例的并行数 gotest结构体(参考) B : 压力测试 BenchmarkResult : 压力测试结果 Cover : 代码覆盖率相关结构体 CoverBlock : 代码覆盖率相关结构体 InternalBenchmark : 内部使用的结构体 InternalExample : 内部使用的结构体 InternalTest : 内部使用的结构体 M : main 测试使用的结构体 PB : Parallel benchmarks 并行测试使用的结构体 T : 普通测试用例 TB : 测试用例的接口 压力测试基础 压测检测函数(方法)的性能，和编写UT类似，所以不再赘述，但需要注意以下几点：\n压力测试用例必须遵循如下格式，其中XXX可以是任意字母数字的组合，但是首字母不能是小写字母 func BenchmarkXXX(b *testing.B) { ... } go test不会默认执行压力测试的函数，如果要执行压力测试需要带上参数-test.bench，语法:-test.bench=\"test_name_regex\",例如go test -test.bench=\".*\"表示测试全部的压力测试函数 在压力测试用例中,请记得在循环体内使用testing.B.N,以使测试可以正常的运行 文件名也必须以_test.go结尾 下面是一个压测的例子，测试除法函数的性能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package gotest import ( \"testing\" ) func Benchmark_Division(b *testing.B) { for i := 0; i \u003c b.N; i++ { //use b.N for looping Division(4, 5) } } func Benchmark_TimeConsumingFunction(b *testing.B) { b.StopTimer() //调用该函数停止压力测试的时间计数 //做一些初始化的工作,例如读取文件数据,数据库连接之类的, //这样这些时间不影响我们测试函数本身的性能 b.StartTimer() //重新开始时间 for i := 0; i \u003c b.N; i++ { Division(4, 5) } } 我们执行命令go test webbench_test.go -test.bench=\".*\"，可以看到如下结果：\nBenchmark_Division-4 500000000\t7.76 ns/op\t456 B/op\t14 allocs/op Benchmark_TimeConsumingFunction-4 500000000\t7.80 ns/op\t224 B/op\t4 allocs/op PASS ok gotest\t9.364s 上面的结果显示我们没有执行任何TestXXX的单元测试函数，显示的结果只执行了压力测试函数，第一条显示了Benchmark_Division执行了500000000次，每次的执行平均时间是7.76纳秒，第二条显示了Benchmark_TimeConsumingFunction执行了500000000，每次的平均执行时间是7.80纳秒。最后一条显示总共的执行时间。\n性能测试进阶(benchstat) sync.Map优化例子 在sync.Map中存储一个值，然后再并发删除该值:\n1 2 3 4 5 6 7 8 func BenchmarkDeleteCollision(b *testing.B){ benchMap(b, bench{ setup: func(_ *testing.B, m mapInterface){m,LoadOrStore(0, 0)}, perG: func(b *testing.B, pb *testing.PB, i int, m mapInterface){ for; pb.Next(); i++ {m.Delete(0)} } }) } 优化 src/sync/map.go 275 -delete(m.dirty, key) 275 +e, ok = m.dirty[key] 276 +m.misslocked() $ git stash $ git test -run=none -bench=BenchmarkDeleteCollision -count=20 | tee old.txt $ git stash pop $ git test -run=none -bench=BenchmarkDeleteCollision -count=20 | tee new.txt $ benchstat old.txt new.ext 编译器优化例子 查看编译器优化，测试函数被编译成了什么\n1 2 3 4 5 6 7 8 9 10 11 12 13 package compile func comp1(s1, s2 []byte)bool{ return string(s1) == string(s2) } func comp2(s1, s2 []byte)bool{ return conv(s1) == conv(s2) } func conv(s []byte) string{ return string(s) } $GOSSAFUNC=com1 go build // 会生成ssa.html，open它即可看到comp1函数编译后的代码 假设性检验 统计是一套在总体分布函数完全未知或者只知道形式、不知道参数的情况下，为了由样本推断总体的某些未知特性，形成的一套方法论。 多次抽样：对同一个性能基准测试运行多次，根据中心极限定理，如果理论均值存在，则抽样噪声服从正态分布。 当重复执行完某个性能基准测试后，benchstat先帮我们剔除掉了一些异常值，我们得到了关于某段代码在可控的环境条件E下的性能分布的一组样本。 T检验：参数检验，假设数据服从正态分布，且方差相同 (最严格) Welch T检验(ttest)： 参数检验，假设服从正态分布，但方差不一定相同 Mann-Whitney U检验(utest， benchstat的default): 非参数检验，假设最少，最通用，值假设两组样本来自于同一个总体（例如两个性能测试是否在同一个机器跑的），只有均值的差异。当对数据的假设减少时，结论的不确定性增大，p值会因此增大，进而使得性能基准测试的条件更加严格。 局限和应对 perflock降低系统噪音，作用是限制CPU时钟频率，从而一定程度上消除系统对性能测试程序的影响，仅支持Linux。\n$ go get github.com/aclements/perflock/cmd/perflock $ sudo install $GOPATH/bin/perflock /usr/bin/perflock $ sudo -b perflock -daemon $ perflock $ perflock -governer 70% go test -test=none -bench=. Mocking GoMock GoMock为很常用的测试mock框架，虽然我自己不常用:0（因为我自身并不非常喜欢mock), 并且对在生产开发环境使用mock有点意见，代码增长（和Injection类似），以及如果不单独部署一个mock server很多修改并不能很好得share。\n虽然如此，这里还是记录一下GoMock的quick start。\nInstall 首先就是安装gomock包，以及mockgen代码生成工具，后者其实并不是必要的，但是如果没有自己就要写一个容易出错并且繁琐的mock代码。\ngo get github.com/golang/mock/gomock go get github.com/golang/mock/mockgen 检查一下有没有成功，会打印一些使用帮助信息:\n$GOPATH/bin/mockgen 基本使用 基本上使用gomock遵循以下几个步骤：\n使用mockgen去对你想要mock的interface生成mock对象 在测试代码中，创建一个gomock.Controller实例，并且将其传入mock对象的constructor中获取一个mock对象 在你的mock中调用EXPECT()去设置测试期望以及返回值 在mock controller调用FINISH()去设置进行mock期望的assert（断言） 下面记录一个小的demo展示上述的workflow，为了让展示简单，我们可以只是聚焦两个文件- 一个接口文件doer.go中的Doer接口（希望mock的），以及user.go文件中的结构体User，这个接口体用到了Doer接口。\ndoer.go：\n1 2 3 4 5 package doer type Doer interface { DoSomething(int, string) error } user.go\n1 2 3 4 5 6 7 8 9 10 11 package user import \"github.com/sgreben/testing-with-gomock/doer\" type User struct { Doer doer.Doer } func (u *User) Use() error { return u.Doer.DoSomething(123, \"Hello GoMock\") } 下面是project的layout：\n'-- doer '-- doer.go '-- user '-- user.go 我们接下来要在mocks文件夹内添加Doer的mock，并且新增一个user_test.go文件：\n1 2 3 4 5 6 7 '-- doer '-- doer.go '-- mocks '-- mock_doer.go '-- user '-- user.go '-- user_test.go 为了生成这个mock_doer.go，我们创建mocks目录后调用：\nmockgen -destination=mocks/mock_doer.go -package=mocks github.com/sgreben/testing-with-gomock/doer Doer 这里的mockgen传入以下几个参数:\n-destination=mocks/mock_doer.go 目标路径 -package=mocks：在mockspackage内生成mocks github.com/sgreben/testing-with-gomock/doer： 为这个package生成mocks (包名而已，根据实际情况定) Doer: 为这个interface生成mocks，如果想要mock多个接口，可以传入以逗号分隔的列表Doer1,Doer2，对接口的声明必须清楚。 注意如果$GOPATH/bin不在$PATH中，mockgen要改成$GOPATH/bin/mockgen\n最终mockgen会生成mock_doer.go这个文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // Code generated by MockGen. DO NOT EDIT. // Source: github.com/sgreben/testing-with-gomock/doer (interfaces: Doer) package mocks import ( gomock \"github.com/golang/mock/gomock\" ) // MockDoer is a mock of Doer interface type MockDoer struct { ctrl *gomock.Controller recorder *MockDoerMockRecorder } // MockDoerMockRecorder is the mock recorder for MockDoer type MockDoerMockRecorder struct { mock *MockDoer } // NewMockDoer creates a new mock instance func NewMockDoer(ctrl *gomock.Controller) *MockDoer { mock := \u0026MockDoer{ctrl: ctrl} mock.recorder = \u0026MockDoerMockRecorder{mock} return mock } // EXPECT returns an object that allows the caller to indicate expected use func (_m *MockDoer) EXPECT() *MockDoerMockRecorder { return _m.recorder } // DoSomething mocks base method func (_m *MockDoer) DoSomething(_param0 int, _param1 string) error { ret := _m.ctrl.Call(_m, \"DoSomething\", _param0, _param1) ret0, _ := ret[0].(error) return ret0 } // DoSomething indicates an expected call of DoSomething func (_mr *MockDoerMockRecorder) DoSomething(arg0, arg1 interface{}) *gomock.Call { return _mr.mock.ctrl.RecordCall(_mr.mock, \"DoSomething\", arg0, arg1) } 浏览一下代码，可以看到生成的EXPECT()方法和mock接口的方法在一个层级，这里是DoSomething，因为要避免名字冲突，所以这里把EXPECT定义成全大写。\n下面，我们在测试中创建一个mock controller。 mock controller的作用是跟踪以及对相关mocks对象的进行期望断言(asserting the expectations)。\n创建controller的方法就是，传入构建函数代表*testing.T的t，而后将其作为参数传入Doermock对象的构建函数:\n1 2 3 4 mockCtrl := gomock.NewController(t) defer mockCtrl.Finish() mockDoer := mocks.NewMockDoer(mockCtrl) 上述对Finish的defer后面再说。\n假设我们想要断言mockerDoer的Do方法将会被调用一次，传入123以及Hello GoMock作为参数并且返回nil。\n为了实现这个断言，我们在mockDoer对象上调用EXPECT()设置期望。EXPECT()其实返回的是一个mock recorder的对象，它包含了真实对象的所有同名方法。\n我们能够进行如下的链式调用:\n1 mockDoer.EXPECT().DoSomething(123, \"Hello GoMock\").Return(nil).Times(1) 从这个调用其实你也能理解每个的意义，如果要设置方法被调用的次数，除了上述的Times(number)，还有诸如MaxTimes(number)以及MinTimes(numbers)这种显性的限制。\n看上去差不多了，接下来写一个完整的user_test.go`:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package user_test import ( \"github.com/sgreben/testing-with-gomock/mocks\" \"github.com/sgreben/testing-with-gomock/user\" ) func TestUse(t *testing.T) { mockCtrl := gomock.NewController(t) defer mockCtrl.Finish() mockDoer := mocks.NewMockDoer(mockCtrl) testUser := \u0026user.User{Doer:mockDoer} // Expect Do to be called once with 123 and \"Hello GoMock\" as parameters, and return nil from the mocked call. mockDoer.EXPECT().DoSomething(123, \"Hello GoMock\").Return(nil).Times(1) testUser.Use() } 可能这个代码里对mock期望的断言并不明显，断言发生在defer掉的Finish()。相当于对Finish的调用发生在mock controller的声明的时候 - 这样我们不会忘记在后面加上期望断言。\n最后跑一下测试:\n$ go test -v github.com/sgreben/testing-with-gomock/user === RUN TestUse --- PASS: TestUse (0.00s) PASS ok github.com/sgreben/testing-with-gomock/user 0.007s 当然如果你想构建多个mock对象，你可以对mock controller进行复用，它的Finish相当于会发生在所有和controller关联的mock对象的期望断言被设置之后。\n我们也可以测试一下mock方法的返回值，这里改写一下测试返回一个dummyError：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func TestUseReturnsErrorFromDo(t *testing.T) { mockCtrl := gomock.NewController(t) defer mockCtrl.Finish() dummyError := errors.New(\"dummy error\") mockDoer := mocks.NewMockDoer(mockCtrl) testUser := \u0026user.User{Doer:mockDoer} // Expect Do to be called once with 123 and \"Hello GoMock\" as parameters, and return dummyError from the mocked call. mockDoer.EXPECT().DoSomething(123, \"Hello GoMock\").Return(dummyError).Times(1) err := testUser.Use() if err != dummyError { t.Fail() } } 通过go:generate使用GoMock 有些人可能发现一个workflow的问题，如果对每个package以及interface都用mockgen肯定是非常繁琐的，特别是如果我们开发的项目有大量的接口和包定义。为了解决这个问题，mockgen命令行能够被特殊的go:generate注释去替代。\n比如，在我们的例子里，我们能够在doer.go的package声明下面添加注释:\n1 2 3 4 5 6 7 package doer //go:generate mockgen -destination=../mocks/mock_doer.go -package=mocks github.com/sgreben/testing-with-gomock/doer Doer type Doer interface { DoSomething(int, string) error } 但是这种写法也有个问题，因为代码文件目录和mocks目录的不一致，导致我们需要添加../mocks类似的路径而不是简单的mocks/，我们可以在项目的根路径下生成所有mocks:\ngo generate ./... 写法上注意代码里//和go:generate之间没有空格。\n对于添加go:generate注释的原则以及一些mock的构建命名原则如下:\n每个包含需要mock的interfaces的文件中添加一个go:generate注释 如果要用mockgen要传入清晰的interface名 把mock文件放在mocks包下，名称改写X.go到mocks/mock_X.go 使用参数匹配器 有些情况下，你对mock中的特定参数不太关心，当然我们可以清楚地固定参数，也可以用参数匹配器去匹配参数，我们称之为Matcher，熟悉Ginkgo框架的同学应该很清楚。\nGoMock中预设了几个matchers：\ngomock.Any()： 匹配所有类型、所有值 gomock.Eq(x): 使用反射去匹配任何与x为DeepEqual的值 gomock.Nil()： 匹配nil gomock.Not(m): 这里m是一个Matcher，也就是匹配所有没有被m匹配的值 gomock.Not(x): 这里x不是一个Matcher，匹配所有与x不DeepEqual的值 举个例子，如果我们不关心Do方法的第一个参数:\n1 mockDoer.EXPECT().DoSomething(gomock.Any(), \"Hello GoMock\") GoMock会自动把非匹配类型的参数转化为Eq匹配器：\n1 mockDoer.EXPECT().DoSomething(gomock.Any(), gomock.Eq(\"Hello GoMock\")) 当然我们也可以自定义Matchers，实现接口就行, gomock/matchers.go :\n1 2 3 4 type Matcher interface { Matches(x interface{}) bool String() string } 这里的Matches方法是实例匹配发生的地方，String方法针对测试失败时生成human-readable的信息，我们可以自己写一个matcher去检查参数类型：\nmatch/oftype.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package match import ( \"reflect\" \"github.com/golang/mock/gomock\" ) type ofType struct{ t string } func OfType(t string) gomock.Matcher { return \u0026ofType{t} } func (o *ofType) Matches(x interface{}) bool { return reflect.TypeOf(x).String() == o.t } func (o *ofType) String() string { return \"is of type \" + o.t } 然后我们就可以使用我们的matcher:\n1 2 3 4 5 // Expect Do to be called once with 123 and any string as parameters, and return nil from the mocked call. mockDoer.EXPECT(). DoSomething(123, match.OfType(\"string\")). Return(nil). Times(1) 注意下上述我们分行写，要把.写在行末尾，不然编译器会报错。\n断言调用顺序 对一个对象的调用顺序也是很重要的，GoMock提供了.After方法显式地定义一个方法必须在另一个方法后面被调用:\n1 2 3 callFirst := mockDoer.EXPECT().DoSomething(1, \"first this\") callA := mockDoer.EXPECT().DoSomething(2, \"then this\").After(callFirst) callB := mockDoer.EXPECT().DoSomething(2, \"or this\").After(callFirst) 这个代码都能理解。\n此外还提供了一个更直观的手段去定义断言顺序，也就是gomock.InOrder，这种写法更容易阅读:\n1 2 3 4 5 6 gomock.InOrder( mockDoer.EXPECT().DoSomething(1, \"first this\"), mockDoer.EXPECT().DoSomething(2, \"then this\"), mockDoer.EXPECT().DoSomething(3, \"then this\"), mockDoer.EXPECT().DoSomething(4, \"finally this\"), ) 定义mock的actions 本质上就是mock其实不会执行其他行为，我们可以人为使用.Do方法，并且传入调用的函数，意味着如果调用的参数匹配上了，就会执行.Do提供的函数：\n1 2 3 4 5 6 mockDoer.EXPECT(). DoSomething(gomock.Any(), gomock.Any()). Return(nil). Do(func(x int, y string) { fmt.Println(\"Called with x =\",x,\"and y =\", y) }) 一些复杂的动作，比如下面这个例子，DoSomething方法的第一个int参数应该小于或者等于第二个string参数的长度:\n1 2 3 4 5 6 7 8 mockDoer.EXPECT(). DoSomething(gomock.Any(), gomock.Any()). Return(nil). Do(func(x int, y string) { if x \u003e len(y) { t.Fail() } }) 这种写法不能通过自定义matcher实现，因为我们关联了多个具体的值，而matcher每次只能访问一个参数。\nsql-mock(GORM) 常规的database/sql/driver的接口mocking可以用GoMock，但是像gorm之类的ORM框架就很难用常规的mock方法，以为有其他很多额外的苦力活。sql-mock的介绍为Sql mock driver for golang to test database interactions. 可以帮助解决这个问题。\n下面用BDD框架Ginkgo写测试用例，展示一个如何使用Sqlmock去测试一个简单blog应用的例子，这个例子的后端为pg并且使用了gorm。\n源码\n定义GORM数据模型与Repository 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // modle.go import \"github.com/lib/pq\" ... type Blog struct { ID uint Title string Content string Tags pq.StringArray // string array for tags CreatedAt time.Time } // repository.go import \"github.com/jinzhu/gorm\" ... type Repository struct { db *gorm.DB } func (p *Repository) ListAll() ([]*Blog, error) { var l []*Blog err := p.db.Find(\u0026l).Error return l, err } func (p *Repository) Load(id uint) (*Blog, error) { blog := \u0026Blog{} err := p.db.Where(`id = ?`, id).First(blog).Error return blog, err } ... Repository结构非常简单，有着*gorm.DB字段，所有的DB操作依赖于此。这里为了简洁把一些多余的代码省略了。除了Load、ListAll当然还有类似Save、Delete、SearchByTitle等方法。\n单元测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import ( ... . \"github.com/onsi/ginkgo\" . \"github.com/onsi/gomega\" \"github.com/DATA-DOG/go-sqlmock\" \"github.com/jinzhu/gorm\" ) var _ = Describe(\"Repository\", func() { var repository *Repository var mock sqlmock.Sqlmock BeforeEach(func() { var db *sql.DB var err error db, mock, err = sqlmock.New() // mock sql.DB Expect(err).ShouldNot(HaveOccurred()) gdb, err := gorm.Open(\"postgres\", db) // open gorm db Expect(err).ShouldNot(HaveOccurred()) repository = \u0026Repository{db: gdb} }) AfterEach(func() { err := mock.ExpectationsWereMet() // make sure all expectations were met Expect(err).ShouldNot(HaveOccurred()) }) It(\"test something\", func(){ ... }) }) 如果读者对Ginkgo的测试语法表示不熟悉的，可以去参阅posts里的BDD相关章节。在这里，BeforeEach中做一些测试初始化，例如Repository的实例化等。在AfterEach中加入各种断言。\nBeforeEach中的初始化分为几个步骤：\n创建*sql.DB的mock实例，利用sqlmock.New()创建mock控制器。 gorm.Open(\"postgres\", db)使用GORM。 创建Repository实例。 在AfterEach中，我们使用mock.ExpectationsWereMet()确保所有的期望都被满足。\n测试ListAll方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // repository.go ... func (p *Repository) ListAll() ([]*Blog, error) { var l []*Blog err := p.db.Find(\u0026l).Error return l, err } ... // repository_test.go ... Context(\"list all\", func() { It(\"empty\", func() { const sqlSelectAll = `SELECT * FROM \"blogs\"` mock.ExpectQuery(sqlSelectAll). WillReturnRows(sqlmock.NewRows(nil)) l, err := repository.ListAll() Expect(err).ShouldNot(HaveOccurred()) Expect(l).Should(BeEmpty()) }) }) ... 上述snippet中，ListAll找到DB中的所有记录，并map到*Blog的切片中。测试语句非常直观，我们设置了该查询语句返回的是nil，也就是空集合。跑一下测试：\n➜ ginkgo Running Suite: Pg Suite ======================= Random Seed: 1585542357 Will run 8 of 8 specs (/Users/dche423/dbtest/pg/repository.go:24) [2020-03-30 12:26:01] Query: could not match actual sql: \"SELECT * FROM \"blogs\"\" with expected regexp \"SELECT * FROM \"blogs\"\" • Failure [0.001 seconds] Repository /Users/dche423/dbtest/pg/repository_test.go:16 list all /Users/dche423/dbtest/pg/repository_test.go:37 empty [It] /Users/dche423/dbtest/pg/repository_test.go:38 ... Test Suite Failed ➜ 测试失败了…不过回显可以知道信息: could not match actual sql with expected regexp.。实际上Sqlmock使用sqlmock.QueryMatcherRegex为默认的SQL匹配器。在这个例子中，sqlmock.ExpectQuery输入一个正则表达式字符串而不是一个SQL的文本。所以我们有两种方式去解决这个问题:\n使用regexp.QuoteMeta， 也就是mock.ExpectQuery(regexp.QuoteMeta(sqlSelectAll)) 更改默认的SQL匹配器，当我们在创建mock实例的时候可以配置: sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual)) 其实一般来说，正则表达式匹配器能更灵活一些。\n测试Load方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // repository.go func (p *Repository) Load(id uint) (*Blog, error) { blog := \u0026Blog{} err := p.db.Where(`id = ?`, id).First(blog).Error return blog, err } ... // repository_test.go Context(\"load\", func() { It(\"found\", func() { blog := \u0026Blog{ ID: 1, Title: \"post\", ... } rows := sqlmock. NewRows([]string{\"id\", \"title\", \"content\", \"tags\", \"created_at\"}). AddRow(blog.ID, blog.Title, blog.Content, blog.Tags, blog.CreatedAt) const sqlSelectOne = `SELECT * FROM \"blogs\" WHERE (id = $1) ORDER BY \"blogs\".\"id\" ASC LIMIT 1` mock.ExpectQuery(regexp.QuoteMeta(sqlSelectOne)).WithArgs(blog.ID).WillReturnRows(rows) dbBlog, err := repository.Load(blog.ID) Expect(err).ShouldNot(HaveOccurred()) Expect(dbBlog).Should(Equal(blog)) }) It(\"not found\", func() { // ignore sql match mock.ExpectQuery(`.+`).WillReturnRows(sqlmock.NewRows(nil)) _, err := repository.Load(1) Expect(err).Should(Equal(gorm.ErrRecordNotFound)) }) }) ... Load方法输入一个blog id作为参数，找到这个id对应的第一条记录。\n我们测试两种场景:\n名为found的场景，我们创建blog实例并将其转换为sql.Row。随后调用ExpectQuery定义期望，在语句的最后，我们断言loaded blog实例和原来的一样。 注意：如果你不清楚GORM使用的是什么SQL，可以打开debug flag – gorm.DB的Debug() 名为not found的场景，这里使用正则匹配来简化，表示不管什么sql都返回空。这里我们期望的是当找不到对应的blog时候，gorm.ErrRecordNotFound会被抛出。 测试Save方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // repository.go ... func (p *Repository) Save(blog *Blog) error { return p.db.Save(blog).Error } // repository_test.go ... Context(\"save\", func() { var blog *Blog BeforeEach(func() { blog = \u0026Blog{ Title: \"post\", Content: \"hello\", Tags: pq.StringArray{\"a\", \"b\"}, CreatedAt: time.Now(), } }) It(\"insert\", func() { // gorm use query instead of exec // https://github.com/DATA-DOG/go-sqlmock/issues/118 const sqlInsert = ` INSERT INTO \"blogs\" (\"title\",\"content\",\"tags\",\"created_at\") VALUES ($1,$2,$3,$4) RETURNING \"blogs\".\"id\"` const newId = 1 mock.ExpectBegin() // begin transaction mock.ExpectQuery(regexp.QuoteMeta(sqlInsert)). WithArgs(blog.Title, blog.Content, blog.Tags, blog.CreatedAt). WillReturnRows(sqlmock.NewRows([]string{\"id\"}).AddRow(newId)) mock.ExpectCommit() // commit transaction Expect(blog.ID).Should(BeZero()) err := repository.Save(blog) Expect(err).ShouldNot(HaveOccurred()) Expect(blog.ID).Should(BeEquivalentTo(newId)) }) It(\"update\", func() { ...\t}) }) 当data模型有已有的主键，Save方法能够更新DB记录；反之则插入一条新的记录。上面的snippet表现的插入的测试。\n创建一个新的blog实例，并且不给其设置主键。而后定义mock.ExpectQuery。在Query开始前begin一个事务，在之后commit。一般情况下，非查询语句(Insert/Update)应该被mock.ExepectExec定义，但是这个是个特殊场景。因为某些原因，对于pg的语法，GORM使用QueryRow而非Exec。\n最后，使用Expect(blog.ID).Should(BeEquivalentTo(newId)) 来断言blog.ID在Save方法调用之后被设置了。其实一般来说，不太需要去对简单的Insert/Update语句进行单元测试，但是这里只是对一些GORM会进行的一些特殊场景进行说明，像其他的后端场景不用太多关注。\n依赖注入 Test Driven Development TDD Reference\nchannel TDD 过程 目标 目标： 写一个 CheckWebsites 的函数检查 URL 列表的状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 package concurrency type WebsiteChecker func(string) bool func CheckWebsites(wc WebsiteChecker, urls []string) map[string]bool { results := make(map[string]bool) for _, url := range urls { results[url] = wc(url) } return results } 它返回一个 map，由每个 url 检查后的得到的布尔值组成，成功响应的值为 true，错误响应的值为 false。\n你还必须传入一个 WebsiteChecker 处理单个 URL 并返回一个布尔值。它会被函数调用以检查所有的网站。\n使用 依赖注入，允许在不发起真实 HTTP 请求的情况下测试函数，这使测试变得可靠和快速。\n下面是简单的测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package concurrency import ( \"reflect\" \"testing\" ) func mockWebsiteChecker(url string) bool { if url == \"waat://furhurterwe.geds\" { return false } return true } func TestCheckWebsites(t *testing.T) { websites := []string{ \"http://google.com\", \"http://blog.gypsydave5.com\", \"waat://furhurterwe.geds\", } actualResults := CheckWebsites(mockWebsiteChecker, websites) want := len(websites) got := len(actualResults) if want != got { t.Fatalf(\"Wanted %v, got %v\", want, got) } expectedResults := map[string]bool{ \"http://google.com\": true, \"http://blog.gypsydave5.com\": true, \"waat://furhurterwe.geds\": false, } if !reflect.DeepEqual(expectedResults, actualResults) { t.Fatalf(\"Wanted %v, got %v\", expectedResults, actualResults) } } 该功能在生产环境中被用于检查数百个网站。但是它速度很慢，所以需要为程序提速。\n写一个测试 首先我们对 CheckWebsites 做一个基准测试，这样就能看到我们修改的影响。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package concurrency import ( \"testing\" \"time\" ) func slowStubWebsiteChecker(_ string) bool { time.Sleep(20 * time.Millisecond) return true } func BenchmarkCheckWebsites(b *testing.B) { urls := make([]string, 100) for i := 0; i \u003c len(urls); i++ { urls[i] = \"a url\" } for i := 0; i \u003c b.N; i++ { CheckWebsites(slowStubWebsiteChecker, urls) } } 基准测试使用一百个网址的 slice 对 CheckWebsites 进行测试，并使用 WebsiteChecker 的伪造实现。slowStubWebsiteChecker 故意放慢速度。它使用 time.Sleep 明确等待 20 毫秒，然后返回 true。\n当我们运行基准测试时使用 go test -bench=. 命令 (如果在 Windows Powershell 环境下使用 go test -bench=\".\")：\npkg: github.com/gypsydave5/learn-go-with-tests/concurrency/v0 BenchmarkCheckWebsites-4 1 2249228637 ns/op PASS ok github.com/gypsydave5/learn-go-with-tests/concurrency/v0 2.268s CheckWebsite 经过基准测试的时间为 2249228637 纳秒，大约 2.25 秒。\n让我们尝试去让它运行得更快。\n编写足够的代码让它通过 现在我们终于可以谈论并发了，以下内容是为了说明「不止一件事情正在进行中」。这是我们每天很自然在做的事情。\n比如，今天早上我泡了一杯茶。我放上水壶，然后在等待它煮沸时，从冰箱里取出了牛奶，把茶从柜子里拿出来，找到我最喜欢的杯子，把茶袋放进杯子里，然后等水壶沸了，把水倒进杯子里。\n我 没有 做的事情是放上水壶，然后呆呆地盯着水壶等水煮沸，然后在煮沸后再做其他事情。\n如果你能理解为什么第一种方式泡茶更快，那你就可以理解我们如何让 CheckWebsites 变得更快。与其等待网站响应之后再发送下一个网站的请求，不如告诉计算机在等待时就发起下一个请求。\n通常在 Go 中，当调用函数 doSomething() 时，我们等待它返回（即使它没有值返回，我们仍然等待它完成）。我们说这个操作是 阻塞 的 —— 它让我们等待它完成。Go 中不会阻塞的操作将在称为 goroutine 的单独 进程 中运行。将程序想象成从上到下读 Go 的 代码，当函数被调用执行读取操作时，进入每个函数「内部」。当一个单独的进程开始时，就像开启另一个 reader（阅读程序）在函数内部执行读取操作，原来的 reader 继续向下读取 Go 代码。\n要告诉 Go 开始一个新的 goroutine，我们把一个函数调用变成 go 声明，通过把关键字 go 放在它前面：go doSomething()。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package concurrency type WebsiteChecker func(string) bool func CheckWebsites(wc WebsiteChecker, urls []string) map[string]bool { results := make(map[string]bool) for _, url := range urls { go func() { results[url] = wc(url) }() } return results } 因为开启 goroutine 的唯一方法就是将 go 放在函数调用前面，所以当我们想要启动 goroutine 时，我们经常使用 匿名函数（anonymous functions）。一个匿名函数文字看起来和正常函数声明一样，但没有名字（意料之中）。你可以在 上面的 for 循环体中看到一个。\n匿名函数有许多有用的特性，其中两个上面正在使用。首先，它们可以在声明的同时执行 —— 这就是匿名函数末尾的 () 实现的。其次，它们维护对其所定义的词汇作用域的访问权 —— 在声明匿名函数时所有可用的变量也可在函数体内使用。\n上面匿名函数的主体和之前循环体中的完全一样。唯一的区别是循环的每次迭代都会启动一个新的 goroutine，与当前进程（WebsiteChecker 函数）同时发生，每个循环都会将结果添加到 results map 中。\n但是当我们执行 go test：\n-------- FAIL: TestCheckWebsites (0.00s) CheckWebsites_test.go:31: Wanted map[http://google.com:true http://blog.gypsydave5.com:true waat://furhurterwe.geds:false], got map[] FAIL exit status 1 FAIL github.com/gypsydave5/learn-go-with-tests/concurrency/v1 0.010s 不可预知的问题 你可能不会得到这个结果。你可能会得到一个 panic 信息，这个稍后再谈。如果你得到的是那些结果，不要担心，只要继续运行测试，直到你得到上述结果。或假装你得到了，这取决于你。欢迎来到并发编程的世界：如果处理不正确，很难预测会发生什么。别担心 —— 这就是我们编写测试的原因，当处理并发时，测试帮助我们预测可能发生的情况。\n让我们困惑的是，原来的测试 WebsiteChecker 现在返回空的 map。哪里出问题了？\n我们 for 循环开始的 goroutines 没有足够的时间将结果添加结果到 results map 中；WebsiteChecker 函数对于它们来说太快了，以至于它返回时仍为空的 map。\n为了解决这个问题，我们可以等待所有的 goroutine 完成他们的工作，然后返回。两秒钟应该能完成了，对吧？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package concurrency import \"time\" type WebsiteChecker func(string) bool func CheckWebsites(wc WebsiteChecker, urls []string) map[string]bool { results := make(map[string]bool) for _, url := range urls { go func() { results[url] = wc(url) }() } time.Sleep(2 * time.Second) return results } 现在当我们运行测试时获得的结果（如果没有得到 —— 参考上面的做法）：\n-------- FAIL: TestCheckWebsites (0.00s) CheckWebsites_test.go:31: Wanted map[http://google.com:true http://blog.gypsydave5.com:true waat://furhurterwe.geds:false], got map[waat://furhurterwe.geds:false] FAIL exit status 1 FAIL github.com/gypsydave5/learn-go-with-tests/concurrency/v1 0.010s 这不是很好 - 为什么只有一个结果？我们可以尝试通过增加等待的时间来解决这个问题 —— 如果你愿意，可以试试。但没什么作用。这里的问题是变量 url 被重复用于 for 循环的每次迭代 —— 每次都会从 urls 获取新值。但是我们的每个 goroutine 都是 url 变量的引用 —— 它们没有自己的独立副本。所以他们 都 会写入在迭代结束时的 url —— 最后一个 url。这就是为什么我们得到的结果是最后一个 url —- 注意：闭包情况下的引用关系一直是需要注意的\n解决这个问题:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import ( \"time\" ) type WebsiteChecker func(string) bool func CheckWebsites(wc WebsiteChecker, urls []string) map[string]bool { results := make(map[string]bool) for _, url := range urls { go func(u string) { results[u] = wc(u) }(url) } time.Sleep(2 * time.Second) return results } 通过给每个匿名函数一个参数 url(u)，然后用 url 作为参数调用匿名函数，我们确保 u 的值固定为循环迭代的 url 值，重新启动 goroutine。u 是 url 值的副本，因此无法更改。\n现在，如果你幸运的话，你会得到：\nPASS ok github.com/gypsydave5/learn-go-with-tests/concurrency/v1 2.012s 但是，如果你不走运（如果你运行基准测试，这很可能会发生，因为你将发起多次的尝试）。\nfatal error: concurrent map writes goroutine 8 [running]: runtime.throw(0x12c5895, 0x15) /usr/local/Cellar/go/1.9.3/libexec/src/runtime/panic.go:605 +0x95 fp=0xc420037700 sp=0xc4200376e0 pc=0x102d395 runtime.mapassign_faststr(0x1271d80, 0xc42007acf0, 0x12c6634, 0x17, 0x0) /usr/local/Cellar/go/1.9.3/libexec/src/runtime/hashmap_fast.go:783 +0x4f5 fp=0xc420037780 sp=0xc420037700 pc=0x100eb65 github.com/gypsydave5/learn-go-with-tests/concurrency/v3.WebsiteChecker.func1(0xc42007acf0, 0x12d3938, 0x12c6634, 0x17) /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:12 +0x71 fp=0xc4200377c0 sp=0xc420037780 pc=0x12308f1 runtime.goexit() /usr/local/Cellar/go/1.9.3/libexec/src/runtime/asm_amd64.s:2337 +0x1 fp=0xc4200377c8 sp=0xc4200377c0 pc=0x105cf01 created by github.com/gypsydave5/learn-go-with-tests/concurrency/v3.WebsiteChecker /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:11 +0xa1 ... many more scary lines of text ... 这看上去冗长、可怕，我们需要深呼吸并阅读错误：fatal error: concurrent map writes。有时候，当我们运行我们的测试时，两个 goroutines 完全同时写入 results map。Go 的 Maps 不喜欢多个事物试图一次性写入，所以就导致了 fatal error。\n这是一种 race condition（竞争条件），当软件的输出取决于事件发生的时间和顺序时，因为我们无法控制，bug 就会出现。因为我们无法准确控制每个 goroutine 写入结果 map 的时间，两个 goroutines 同一时间写入时程序将非常脆弱。\nGo 可以帮助我们通过其内置的 race detector 来发现竞争条件。要启用此功能，请使用 race 标志运行测试：go test -race。\n你应该得到一些如下所示的输出：\n================== WARNING: DATA RACE Write at 0x00c420084d20 by goroutine 8: runtime.mapassign_faststr() /usr/local/Cellar/go/1.9.3/libexec/src/runtime/hashmap_fast.go:774 +0x0 github.com/gypsydave5/learn-go-with-tests/concurrency/v3.WebsiteChecker.func1() /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:12 +0x82 Previous write at 0x00c420084d20 by goroutine 7: runtime.mapassign_faststr() /usr/local/Cellar/go/1.9.3/libexec/src/runtime/hashmap_fast.go:774 +0x0 github.com/gypsydave5/learn-go-with-tests/concurrency/v3.WebsiteChecker.func1() /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:12 +0x82 Goroutine 8 (running) created at: github.com/gypsydave5/learn-go-with-tests/concurrency/v3.WebsiteChecker() /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:11 +0xc4 github.com/gypsydave5/learn-go-with-tests/concurrency/v3.TestWebsiteChecker() /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker_test.go:27 +0xad testing.tRunner() /usr/local/Cellar/go/1.9.3/libexec/src/testing/testing.go:746 +0x16c Goroutine 7 (finished) created at: github.com/gypsydave5/learn-go-with-tests/concurrency/v3.WebsiteChecker() /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:11 +0xc4 github.com/gypsydave5/learn-go-with-tests/concurrency/v3.TestWebsiteChecker() /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker_test.go:27 +0xad testing.tRunner() /usr/local/Cellar/go/1.9.3/libexec/src/testing/testing.go:746 +0x16c ================== 细节还是难以阅读 - 但 WARNING: DATA RACE 相当明确。阅读错误的内容，我们可以看到两个不同的 goroutines 在 map 上执行写入操作：\nWrite at 0x00c420084d20 by goroutine 8: 正在写入相同的内存块\nPrevious write at 0x00c420084d20 by goroutine 7: 最重要的是，我们可以看到发生写入的代码行：\n/Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:12 和 goroutines 7 和 8 开始的代码行号：\n/Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:11 你需要知道的所有内容都会打印到你的终端上 - 你只需耐心阅读就可以了。\n使用channels处理race condition 我们可以通过使用 channels 协调我们的 goroutines 来解决这个数据竞争。channels 是一个 Go 数据结构，可以同时接收和发送值。这些操作以及细节允许不同进程之间的通信。\n在这种情况下，我们想要考虑父进程和每个 goroutine 之间的通信，goroutine 使用 url 来执行 WebsiteChecker 函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package concurrency type WebsiteChecker func(string) bool type result struct { string bool } func CheckWebsites(wc WebsiteChecker, urls []string) map[string]bool { results := make(map[string]bool) resultChannel := make(chan result) for _, url := range urls { go func(u string) { resultChannel \u003c- result{u, wc(u)} }(url) } for i := 0; i \u003c len(urls); i++ { result := \u003c-resultChannel results[result.string] = result.bool } return results } 除了 results map 之外，我们现在还有一个 resultChannel 的变量，同样使用 make 方法创建。chan result 是 channel 类型的 —— result 的 channel。新类型的 result 是将 WebsiteChecker 的返回值与正在检查的 url 相关联 —— 它是一个 string 和 bool 的结构。因为我们不需要任何一个要命名的值，它们中的每一个在结构中都是匿名的；这在很难知道用什么命名值的时候可能很有用。\n现在，当我们迭代 urls 时，不是直接写入 map，而是使用 send statement 将每个调用 wc 的 result 结构体发送到 resultChannel。这使用 \u003c- 操作符，channel 放在左边，值放在右边：\n1 2 // send statement resultChannel \u003c- result{u, wc(u) 下一个 for 循环为每个 url 迭代一次。 我们在内部使用 receive expression，它将从通道接收到的值分配给变量。这也使用 \u003c- 操作符，但现在两个操作数颠倒过来：现在 channel 在右边，我们指定的变量在左边：\n1 2 // receive expression result := \u003c-resultChannel 然后我们使用接收到的 result 更新 map。\n通过将结果发送到通道，我们可以控制每次写入 results map 的时间，确保每次写入一个结果。虽然 wc 的每个调用都发送给结果通道，但是它们在其自己的进程内并行发生，因为我们将结果通道中的值与接收表达式一起逐个处理一个结果。\n我们已经将想要加快速度的那部分代码并行化，同时确保不能并发的部分仍然是线性处理。我们使用 channel 在多个进程间通信。\n当我们运行基准时：\npkg: github.com/gypsydave5/learn-go-with-tests/concurrency/v2 BenchmarkCheckWebsites-8 100 23406615 ns/op PASS ok github.com/gypsydave5/learn-go-with-tests/concurrency/v2 2.377s 23406615 纳秒 —— 0.023 秒，速度大约是最初函数的一百倍，这是非常成功的。\n总结 某种程度说，我们已经参与了 CheckWebsites 函数的一个长期重构；输入和输出从未改变，它只是变得更快了。但是我们所做的测试以及我们编写的基准测试允许我们重构 CheckWebsites，让我们有信心保证软件仍然可以工作，同时也证明它确实变得更快了。\n在使它更快的过程中，我们明白了\ngoroutines 是 Go 的基本并发单元，它让我们可以同时检查多个网站。 anonymous functions（匿名函数），我们用它来启动每个检查网站的并发进程。 channels，用来组织和控制不同进程之间的交流，使我们能够避免 race condition（竞争条件） 的问题。 the race detector（竞争探测器） 帮助我们调试并发代码的问题。 ","wordCount":"3480","inLanguage":"en","image":"https://pillumina.github.io/imgs/icon_head.png","datePublished":"2020-12-19T11:22:18+08:00","dateModified":"2020-12-19T11:22:18+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://pillumina.github.io/posts/programming/golang/go-testing/"},"publisher":{"@type":"Organization","name":"CctoctoFX","logo":{"@type":"ImageObject","url":"https://pillumina.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pillumina.github.io/ accesskey=h title="CctoctoFX (Alt + H)"><img src=https://pillumina.github.io/apple-touch-icon.png alt aria-label=logo height=30>CctoctoFX</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pillumina.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://pillumina.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://pillumina.github.io/posts/aiinfra title="AI Infra"><span>AI Infra</span></a></li><li><a href=https://pillumina.github.io/posts/programming title=Programming><span>Programming</span></a></li><li><a href=https://pillumina.github.io/social title=Social><span>Social</span></a></li><li><a href=https://pillumina.github.io/open_courses title=Study><span>Study</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://pillumina.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://pillumina.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://pillumina.github.io/posts/programming/>Programming</a>&nbsp;»&nbsp;<a href=https://pillumina.github.io/posts/programming/golang/>Golang</a></div><h1 class="post-title entry-hint-parent">Golang TDD</h1><div class=post-meta><span title='2020-12-19 11:22:18 +0800 CST'>December 19, 2020</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;3480 words&nbsp;·&nbsp;Me</div></header><div class="toc side left"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#preface>Preface</a></li><li><a href=#单元测试基础>单元测试基础</a><ul><li><a href=#table-driven-testing>Table-Driven-Testing</a></li><li><a href=#t类型>T类型</a></li><li><a href=#报告方式>报告方式</a></li><li><a href=#parallel并行测试>Parallel并行测试</a></li><li><a href=#子测试与子基准测试run>子测试与子基准测试(Run)</a></li><li><a href=#test-coverage>Test Coverage</a></li><li><a href=#gotest变量参考>gotest变量(参考)</a></li><li><a href=#gotest结构体参考>gotest结构体(参考)</a></li></ul></li><li><a href=#压力测试基础>压力测试基础</a></li><li><a href=#性能测试进阶benchstat>性能测试进阶(benchstat)</a><ul><li><a href=#syncmap优化例子>sync.Map优化例子</a></li><li><a href=#编译器优化例子>编译器优化例子</a></li><li><a href=#假设性检验>假设性检验</a></li><li><a href=#局限和应对>局限和应对</a></li></ul></li><li><a href=#mocking>Mocking</a><ul><li><a href=#gomock>GoMock</a></li><li><a href=#sql-mockgorm>sql-mock(GORM)</a></li></ul></li><li><a href=#依赖注入>依赖注入</a></li><li><a href=#test-driven-development>Test Driven Development</a><ul><li><a href=#channel-tdd-过程>channel TDD 过程</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=preface>Preface<a hidden class=anchor aria-hidden=true href=#preface>#</a></h2><p>本文整理golang编码的单元测试常用示例，以及TDD的简要流程。</p><h2 id=单元测试基础>单元测试基础<a hidden class=anchor aria-hidden=true href=#单元测试基础>#</a></h2><p>单元测试文件以<code>_test.go</code>结尾，需要记住以下原则：</p><ul><li>文件名必须是<code>_test.go</code>结尾的，这样在执行<code>go test</code>的时候才会执行到相应的代码</li><li>你必须import <code>testing</code>这个包</li><li>所有的测试用例函数必须是<code>Test</code>开头</li><li>测试用例会按照源代码中写的顺序依次执行</li><li>测试函数<code>TestXxx()</code>的参数是<code>testing.T</code>，我们可以使用该类型来记录错误或者是测试状态</li><li>测试格式：<code>func TestXxx (t *testing.T)</code>,<code>Xxx</code>部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如<code>Testintdiv</code>是错误的函数名。</li><li>函数中通过调用<code>testing.T</code>的<code>Error</code>, <code>Errorf</code>, <code>FailNow</code>, <code>Fatal</code>, <code>FatalIf</code>方法，说明测试不通过，调用<code>Log</code>方法用来记录测试的信息。</li></ul><h3 id=table-driven-testing>Table-Driven-Testing<a hidden class=anchor aria-hidden=true href=#table-driven-testing>#</a></h3><p>测试讲究 case 覆盖，当我们要覆盖更多 case 时，显然通过修改代码的方式很笨拙。这时我们可以采用 Table-Driven 的方式写测试，标准库中有很多测试是使用这种方式写的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestFib</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>fibTests</span> <span class=p>=</span> <span class=p>[]</span><span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>in</span>       <span class=kt>int</span> <span class=c1>// input</span>
</span></span><span class=line><span class=cl>        <span class=nx>expected</span> <span class=kt>int</span> <span class=c1>// expected result</span>
</span></span><span class=line><span class=cl>    <span class=p>}{</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>3</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>5</span><span class=p>,</span> <span class=mi>5</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>6</span><span class=p>,</span> <span class=mi>8</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>7</span><span class=p>,</span> <span class=mi>13</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>tt</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>fibTests</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>actual</span> <span class=o>:=</span> <span class=nf>Fib</span><span class=p>(</span><span class=nx>tt</span><span class=p>.</span><span class=nx>in</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>actual</span> <span class=o>!=</span> <span class=nx>tt</span><span class=p>.</span><span class=nx>expected</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>t</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;Fib(%d) = %d; expected %d&#34;</span><span class=p>,</span> <span class=nx>tt</span><span class=p>.</span><span class=nx>in</span><span class=p>,</span> <span class=nx>actual</span><span class=p>,</span> <span class=nx>tt</span><span class=p>.</span><span class=nx>expected</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>由于我们使用的是 <code>t.Errorf</code>，即使其中某个 case 失败，也不会终止测试执行。</p><h3 id=t类型>T类型<a hidden class=anchor aria-hidden=true href=#t类型>#</a></h3><p>单元测试中，传递给测试函数的参数是 <code>*testing.T</code> 类型。它用于管理测试状态并支持格式化测试日志。测试日志会在执行测试的过程中不断累积，并在测试完成时转储至标准输出。</p><p>当测试函数返回时，或者当测试函数调用 <code>FailNow</code>、 <code>Fatal</code>、<code>Fatalf</code>、<code>SkipNow</code>、<code>Skip</code>、<code>Skipf</code> 中的任意一个时，则宣告该测试函数结束。跟 <code>Parallel</code> 方法一样，以上提到的这些方法只能在运行测试函数的 goroutine 中调用。</p><p>至于其他报告方法，比如 <code>Log</code> 以及 <code>Error</code> 的变种， 则可以在多个 goroutine 中同时进行调用。</p><h3 id=报告方式>报告方式<a hidden class=anchor aria-hidden=true href=#报告方式>#</a></h3><p>上面提到的系列包括方法，带 <code>f</code> 的是格式化的，格式化语法参考 <code>fmt</code> 包。</p><p>T 类型内嵌了 common 类型，common 提供这一系列方法，我们经常会用到的（注意，这里说的测试中断，都是指当前测试函数）：</p><p>1）当我们遇到一个断言错误的时候，标识这个测试失败，会使用到：</p><pre tabindex=0><code>Fail : 测试失败，测试继续，也就是之后的代码依然会执行
FailNow : 测试失败，测试中断
</code></pre><p>在 <code>FailNow</code> 方法实现的内部，是通过调用 <code>runtime.Goexit()</code> 来中断测试的。</p><p>2）当我们遇到一个断言错误，只希望跳过这个错误，但是不希望标识测试失败，会使用到：</p><pre tabindex=0><code>SkipNow : 跳过测试，测试中断
</code></pre><p>在 <code>SkipNow</code> 方法实现的内部，是通过调用 <code>runtime.Goexit()</code> 来中断测试的。</p><p>3）当我们只希望打印信息，会用到 :</p><pre tabindex=0><code>Log : 输出信息
Logf : 输出格式化的信息
</code></pre><p>注意：默认情况下，单元测试成功时，它们打印的信息不会输出，可以通过加上 <code>-v</code> 选项，输出这些信息。但对于基准测试，它们总是会被输出。</p><p>4）当我们希望跳过这个测试，并且打印出信息，会用到：</p><pre tabindex=0><code>Skip : 相当于 Log + SkipNow
Skipf : 相当于 Logf + SkipNow
</code></pre><p>5）当我们希望断言失败的时候，标识测试失败，并打印出必要的信息，但是测试继续，会用到：</p><pre tabindex=0><code>Error : 相当于 Log + Fail
Errorf : 相当于 Logf + Fail
</code></pre><p>6）当我们希望断言失败的时候，标识测试失败，打印出必要的信息，但中断测试，会用到：</p><pre tabindex=0><code>Fatal : 相当于 Log + FailNow
Fatalf : 相当于 Logf + FailNow
</code></pre><h3 id=parallel并行测试>Parallel并行测试<a hidden class=anchor aria-hidden=true href=#parallel并行测试>#</a></h3><p>这里简单测试一个对Map的读写并行测试。<strong>注意：Parallel方法表示只与其他带有Parallel方法的测试并行进行测试。</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>data</span>   <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>locker</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>WriteToMap</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>locker</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>data</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=nx>v</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ReadFromMap</span><span class=p>(</span><span class=nx>k</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>locker</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>data</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>测试用例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>pairs</span> <span class=p>=</span> <span class=p>[]</span><span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>k</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>v</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}{</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=s>&#34;polaris&#34;</span><span class=p>,</span> <span class=s>&#34;calvin1&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=s>&#34;studygolang&#34;</span><span class=p>,</span> <span class=s>&#34;oops1&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=s>&#34;stdlib&#34;</span><span class=p>,</span> <span class=s>&#34;go demo1&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=s>&#34;polaris1&#34;</span><span class=p>,</span> <span class=s>&#34;calvin2&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=s>&#34;studygolang1&#34;</span><span class=p>,</span> <span class=s>&#34;oops2&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=s>&#34;stdlib1&#34;</span><span class=p>,</span> <span class=s>&#34;go demo2&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=s>&#34;polaris2&#34;</span><span class=p>,</span> <span class=s>&#34; calvin3&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 注意 TestWriteToMap 需要在 TestReadFromMap 之前</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestWriteToMap</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Parallel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>tt</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>pairs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>WriteToMap</span><span class=p>(</span><span class=nx>tt</span><span class=p>.</span><span class=nx>k</span><span class=p>,</span> <span class=nx>tt</span><span class=p>.</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestReadFromMap</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Parallel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>tt</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>pairs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>actual</span> <span class=o>:=</span> <span class=nf>ReadFromMap</span><span class=p>(</span><span class=nx>tt</span><span class=p>.</span><span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>actual</span> <span class=o>!=</span> <span class=nx>tt</span><span class=p>.</span><span class=nx>v</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>t</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;the value of key(%s) is %s, expected: %s&#34;</span><span class=p>,</span> <span class=nx>tt</span><span class=p>.</span><span class=nx>k</span><span class=p>,</span> <span class=nx>actual</span><span class=p>,</span> <span class=nx>tt</span><span class=p>.</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>试验步骤：</p><ol><li>注释掉 WriteToMap 和 ReadFromMap 中 locker 保护的代码，同时注释掉测试代码中的 t.Parallel，执行测试，测试通过，即使加上 <code>-race</code>，测试依然通过；</li><li>只注释掉 WriteToMap 和 ReadFromMap 中 locker 保护的代码，执行测试，测试失败（如果未失败，加上 <code>-race</code> 一定会失败）；</li></ol><p>如果代码能够进行并行测试，在写测试时，尽量加上 Parallel，这样可以测试出一些可能的问题。</p><h3 id=子测试与子基准测试run>子测试与子基准测试(Run)<a hidden class=anchor aria-hidden=true href=#子测试与子基准测试run>#</a></h3><p>Go1.7开始引入的特性，即能够执行嵌套测试，对于过滤执行特性测试用例非常有用。</p><p>T 和 B 的 <code>Run</code> 方法允许定义子单元测试和子基准测试，而不必为它们单独定义函数。这便于创建基于 Table-Driven 的基准测试和层级测试。它还提供了一种共享通用 <code>setup</code> 和 <code>tear-down</code> 代码的方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestFoo</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// &lt;setup code&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=s>&#34;A=1&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span> <span class=o>...</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=s>&#34;A=2&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span> <span class=o>...</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=s>&#34;B=1&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span> <span class=o>...</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=c1>// &lt;tear-down code&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>每个子测试和子基准测试都有一个唯一的名称：由顶层测试的名称与传递给 <code>Run</code> 的名称组成，以斜杠分隔，并具有可选的尾随序列号，用于消除歧义。</p><p>命令行标志 <code>-run</code> 和 <code>-bench</code> 的参数是非固定的正则表达式，用于匹配测试名称。对于由斜杠分隔的测试名称，例如子测试的名称，它名称本身即可作为参数，依次匹配由斜杠分隔的每部分名称。因为参数是非固定的，一个空的表达式匹配任何字符串，所以下述例子中的 “匹配” 意味着 “顶层/子测试名称包含有”：</p><pre tabindex=0><code>go test -run &#39;&#39;      # 执行所有测试。
go test -run Foo     # 执行匹配 &#34;Foo&#34; 的顶层测试，例如 &#34;TestFooBar&#34;。
go test -run Foo/A=  # 对于匹配 &#34;Foo&#34; 的顶层测试，执行其匹配 &#34;A=&#34; 的子测试。
go test -run /A=1    # 执行所有匹配 &#34;A=1&#34; 的子测试。
</code></pre><p>子测试也可用于程序<strong>并行控制</strong>。只有子测试全部执行完毕后，父测试才会完成。在下述例子中，所有子测试之间并行运行，此处的 “并行” 只限于这些子测试之间，并不影响定义在其他顶层测试中的子测试：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestGroupedParallel</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>tc</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>tests</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>tc</span> <span class=o>:=</span> <span class=nx>tc</span> <span class=c1>// capture range variable</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=nx>tc</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>t</span><span class=p>.</span><span class=nf>Parallel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=o>...</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在所有子测试并行运行完毕之前，<code>Run</code> 方法不会返回。下述例子提供了一种方法，用于在子测试并行运行完毕后清理资源：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestTeardownParallel</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// This Run will not return until the parallel tests finish.</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=s>&#34;group&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=s>&#34;Test1&#34;</span><span class=p>,</span> <span class=nx>parallelTest1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=s>&#34;Test2&#34;</span><span class=p>,</span> <span class=nx>parallelTest2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=s>&#34;Test3&#34;</span><span class=p>,</span> <span class=nx>parallelTest3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=c1>// &lt;tear-down code&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=test-coverage>Test Coverage<a hidden class=anchor aria-hidden=true href=#test-coverage>#</a></h3><p>测试覆盖率，这里讨论的是基于代码的测试覆盖率。</p><p>Go 从 1.2 开始，引入了对测试覆盖率的支持，使用的是与 cover 相关的工具（<code>go test -cover</code>、<code>go tool cover</code>）。虽然 <code>testing</code> 包提供了 cover 相关函数，不过它们是给 cover 的工具使用的。</p><p>关于测试覆盖率的更多信息，可以参考官方的博文：<a href=https://blog.golang.org/cover>The cover story</a></p><h3 id=gotest变量参考>gotest变量(参考)<a hidden class=anchor aria-hidden=true href=#gotest变量参考>#</a></h3><p>gotest 的变量有这些：</p><ul><li>test.short : 一个快速测试的标记，在测试用例中可以使用 testing.Short() 来绕开一些测试</li><li>test.outputdir : 输出目录</li><li>test.coverprofile : 测试覆盖率参数，指定输出文件</li><li>test.run : 指定正则来运行某个 / 某些测试用例</li><li>test.memprofile : 内存分析参数，指定输出文件</li><li>test.memprofilerate : 内存分析参数，内存分析的抽样率</li><li>test.cpuprofile : cpu 分析输出参数，为空则不做 cpu 分析</li><li>test.blockprofile : 阻塞事件的分析参数，指定输出文件</li><li>test.blockprofilerate : 阻塞事件的分析参数，指定抽样频率</li><li>test.timeout : 超时时间</li><li>test.cpu : 指定 cpu 数量</li><li>test.parallel : 指定运行测试用例的并行数</li></ul><h3 id=gotest结构体参考>gotest结构体(参考)<a hidden class=anchor aria-hidden=true href=#gotest结构体参考>#</a></h3><ul><li>B : 压力测试</li><li>BenchmarkResult : 压力测试结果</li><li>Cover : 代码覆盖率相关结构体</li><li>CoverBlock : 代码覆盖率相关结构体</li><li>InternalBenchmark : 内部使用的结构体</li><li>InternalExample : 内部使用的结构体</li><li>InternalTest : 内部使用的结构体</li><li>M : main 测试使用的结构体</li><li>PB : Parallel benchmarks 并行测试使用的结构体</li><li>T : 普通测试用例</li><li>TB : 测试用例的接口</li></ul><h2 id=压力测试基础>压力测试基础<a hidden class=anchor aria-hidden=true href=#压力测试基础>#</a></h2><p>压测检测函数(方法)的性能，和编写UT类似，所以不再赘述，但需要注意以下几点：</p><ul><li>压力测试用例必须遵循如下格式，其中XXX可以是任意字母数字的组合，但是首字母不能是小写字母</li></ul><pre tabindex=0><code>	func BenchmarkXXX(b *testing.B) { ... }
</code></pre><ul><li><code>go test</code>不会默认执行压力测试的函数，如果要执行压力测试需要带上参数<code>-test.bench</code>，语法:<code>-test.bench="test_name_regex"</code>,例如<code>go test -test.bench=".*"</code>表示测试全部的压力测试函数</li><li>在压力测试用例中,请记得在循环体内使用<code>testing.B.N</code>,以使测试可以正常的运行</li><li>文件名也必须以<code>_test.go</code>结尾</li></ul><p>下面是一个压测的例子，测试除法函数的性能：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>gotest</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;testing&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Benchmark_Division</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span> <span class=c1>//use b.N for looping </span>
</span></span><span class=line><span class=cl>		<span class=nf>Division</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Benchmark_TimeConsumingFunction</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span><span class=p>.</span><span class=nf>StopTimer</span><span class=p>()</span> <span class=c1>//调用该函数停止压力测试的时间计数</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>//做一些初始化的工作,例如读取文件数据,数据库连接之类的,</span>
</span></span><span class=line><span class=cl>	<span class=c1>//这样这些时间不影响我们测试函数本身的性能</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>b</span><span class=p>.</span><span class=nf>StartTimer</span><span class=p>()</span> <span class=c1>//重新开始时间</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>Division</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>我们执行命令<code>go test webbench_test.go -test.bench=".*"</code>，可以看到如下结果：</p><pre tabindex=0><code>Benchmark_Division-4   	                     500000000	      7.76 ns/op	     456 B/op	      14 allocs/op
Benchmark_TimeConsumingFunction-4            500000000	      7.80 ns/op	     224 B/op	       4 allocs/op
PASS
ok  	gotest	9.364s
</code></pre><p>上面的结果显示我们没有执行任何<code>TestXXX</code>的单元测试函数，显示的结果只执行了压力测试函数，第一条显示了<code>Benchmark_Division</code>执行了500000000次，每次的执行平均时间是7.76纳秒，第二条显示了<code>Benchmark_TimeConsumingFunction</code>执行了500000000，每次的平均执行时间是7.80纳秒。最后一条显示总共的执行时间。</p><h2 id=性能测试进阶benchstat>性能测试进阶(benchstat)<a hidden class=anchor aria-hidden=true href=#性能测试进阶benchstat>#</a></h2><h3 id=syncmap优化例子>sync.Map优化例子<a hidden class=anchor aria-hidden=true href=#syncmap优化例子>#</a></h3><p>在sync.Map中存储一个值，然后再并发删除该值:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkDeleteCollision</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=nf>benchMap</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=nx>bench</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>setup</span><span class=p>:</span> <span class=kd>func</span><span class=p>(</span><span class=nx>_</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>,</span> <span class=nx>m</span> <span class=nx>mapInterface</span><span class=p>){</span><span class=nx>m</span><span class=p>,</span><span class=nf>LoadOrStore</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)},</span>
</span></span><span class=line><span class=cl>    <span class=nx>perG</span><span class=p>:</span> <span class=kd>func</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>,</span> <span class=nx>pb</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>PB</span><span class=p>,</span> <span class=nx>i</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>m</span> <span class=nx>mapInterface</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span><span class=p>;</span> <span class=nx>pb</span><span class=p>.</span><span class=nf>Next</span><span class=p>();</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span><span class=nx>m</span><span class=p>.</span><span class=nf>Delete</span><span class=p>(</span><span class=mi>0</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><pre tabindex=0><code>优化 src/sync/map.go
275 -delete(m.dirty, key)
275 +e, ok = m.dirty[key]
276 +m.misslocked()
</code></pre><pre tabindex=0><code>$ git stash
$ git test -run=none -bench=BenchmarkDeleteCollision -count=20 | tee old.txt
$ git stash pop
$ git test -run=none -bench=BenchmarkDeleteCollision -count=20 | tee new.txt
$ benchstat old.txt new.ext
</code></pre><h3 id=编译器优化例子>编译器优化例子<a hidden class=anchor aria-hidden=true href=#编译器优化例子>#</a></h3><p>查看编译器优化，测试函数被编译成了什么</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>compile</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>comp1</span><span class=p>(</span><span class=nx>s1</span><span class=p>,</span> <span class=nx>s2</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span><span class=kt>bool</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>string</span><span class=p>(</span><span class=nx>s1</span><span class=p>)</span> <span class=o>==</span> <span class=nb>string</span><span class=p>(</span><span class=nx>s2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>comp2</span><span class=p>(</span><span class=nx>s1</span><span class=p>,</span> <span class=nx>s2</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span><span class=kt>bool</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>conv</span><span class=p>(</span><span class=nx>s1</span><span class=p>)</span> <span class=o>==</span> <span class=nf>conv</span><span class=p>(</span><span class=nx>s2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>conv</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=kt>string</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>string</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><pre tabindex=0><code>$GOSSAFUNC=com1 go build 
// 会生成ssa.html，open它即可看到comp1函数编译后的代码
</code></pre><h3 id=假设性检验>假设性检验<a hidden class=anchor aria-hidden=true href=#假设性检验>#</a></h3><ul><li>统计是一套在总体分布函数完全未知或者只知道形式、不知道参数的情况下，为了由样本推断总体的某些未知特性，形成的一套方法论。</li><li>多次抽样：对同一个性能基准测试运行多次，根据中心极限定理，如果理论均值存在，则抽样噪声服从正态分布。</li><li>当重复执行完某个性能基准测试后，benchstat先帮我们剔除掉了一些异常值，我们得到了关于某段代码在可控的环境条件E下的性能分布的一组样本。</li><li>T检验：参数检验，假设数据服从正态分布，且方差相同 (最严格)</li><li>Welch T检验(ttest)： 参数检验，假设服从正态分布，但方差不一定相同</li><li>Mann-Whitney U检验(utest， benchstat的default): 非参数检验，假设最少，最通用，值假设两组样本来自于同一个总体（例如两个性能测试是否在同一个机器跑的），只有均值的差异。当对数据的假设减少时，结论的不确定性增大，p值会因此增大，进而使得性能基准测试的条件更加严格。</li></ul><h3 id=局限和应对>局限和应对<a hidden class=anchor aria-hidden=true href=#局限和应对>#</a></h3><p><code>perflock</code>降低系统噪音，作用是限制CPU时钟频率，从而一定程度上消除系统对性能测试程序的影响，仅支持Linux。</p><pre tabindex=0><code>$ go get github.com/aclements/perflock/cmd/perflock
$ sudo install $GOPATH/bin/perflock /usr/bin/perflock
$ sudo -b perflock -daemon
$ perflock

$ perflock -governer 70% go test -test=none -bench=.
</code></pre><h2 id=mocking>Mocking<a hidden class=anchor aria-hidden=true href=#mocking>#</a></h2><h3 id=gomock>GoMock<a hidden class=anchor aria-hidden=true href=#gomock>#</a></h3><p>GoMock为很常用的测试mock框架，虽然我自己不常用:0（因为我自身并不非常喜欢mock), 并且对在生产开发环境使用mock有点意见，代码增长（和Injection类似），以及如果不单独部署一个mock server很多修改并不能很好得share。</p><p>虽然如此，这里还是记录一下GoMock的quick start。</p><h4 id=install>Install<a hidden class=anchor aria-hidden=true href=#install>#</a></h4><p>首先就是安装<code>gomock</code>包，以及<code>mockgen</code>代码生成工具，后者其实并不是必要的，但是如果没有自己就要写一个容易出错并且繁琐的mock代码。</p><pre tabindex=0><code>go get github.com/golang/mock/gomock
go get github.com/golang/mock/mockgen
</code></pre><p>检查一下有没有成功，会打印一些使用帮助信息:</p><pre tabindex=0><code>$GOPATH/bin/mockgen
</code></pre><h4 id=基本使用>基本使用<a hidden class=anchor aria-hidden=true href=#基本使用>#</a></h4><p>基本上使用<code>gomock</code>遵循以下几个步骤：</p><ol><li>使用<code>mockgen</code>去对你想要mock的interface生成mock对象</li><li>在测试代码中，创建一个<code>gomock.Controller</code>实例，并且将其传入mock对象的constructor中获取一个mock对象</li><li>在你的mock中调用<code>EXPECT()</code>去设置测试期望以及返回值</li><li>在mock controller调用<code>FINISH()</code>去设置进行mock期望的assert（断言）</li></ol><p>下面记录一个小的demo展示上述的workflow，为了让展示简单，我们可以只是聚焦两个文件- 一个接口文件<code>doer.go</code>中的<code>Doer</code>接口（希望mock的），以及<code>user.go</code>文件中的结构体<code>User</code>，这个接口体用到了<code>Doer</code>接口。</p><p><code>doer.go</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>doer</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Doer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>DoSomething</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>user.go</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>user</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;github.com/sgreben/testing-with-gomock/doer&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>User</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Doer</span> <span class=nx>doer</span><span class=p>.</span><span class=nx>Doer</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>u</span> <span class=o>*</span><span class=nx>User</span><span class=p>)</span> <span class=nf>Use</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>u</span><span class=p>.</span><span class=nx>Doer</span><span class=p>.</span><span class=nf>DoSomething</span><span class=p>(</span><span class=mi>123</span><span class=p>,</span> <span class=s>&#34;Hello GoMock&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>下面是project的layout：</p><pre tabindex=0><code>&#39;-- doer
    &#39;-- doer.go
&#39;-- user
    &#39;-- user.go
</code></pre><p>我们接下来要在mocks文件夹内添加<code>Doer</code>的mock，并且新增一个<code>user_test.go</code>文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=err>&#39;</span><span class=o>--</span> <span class=nx>doer</span>
</span></span><span class=line><span class=cl>    <span class=err>&#39;</span><span class=o>--</span> <span class=nx>doer</span><span class=p>.</span><span class=k>go</span>
</span></span><span class=line><span class=cl><span class=err>&#39;</span><span class=o>--</span> <span class=nx>mocks</span>
</span></span><span class=line><span class=cl>    <span class=err>&#39;</span><span class=o>--</span> <span class=nx>mock_doer</span><span class=p>.</span><span class=k>go</span>
</span></span><span class=line><span class=cl><span class=err>&#39;</span><span class=o>--</span> <span class=nx>user</span>
</span></span><span class=line><span class=cl>    <span class=err>&#39;</span><span class=o>--</span> <span class=nx>user</span><span class=p>.</span><span class=k>go</span>
</span></span><span class=line><span class=cl>    <span class=err>&#39;</span><span class=o>--</span> <span class=nx>user_test</span><span class=p>.</span><span class=k>go</span>
</span></span></code></pre></td></tr></table></div></div><p>为了生成这个<code>mock_doer.go</code>，我们创建mocks目录后调用：</p><pre tabindex=0><code>mockgen -destination=mocks/mock_doer.go -package=mocks github.com/sgreben/testing-with-gomock/doer Doer
</code></pre><p>这里的<code>mockgen</code>传入以下几个参数:</p><ol><li><code>-destination=mocks/mock_doer.go</code> 目标路径</li><li><code>-package=mocks</code>：在<code>mocks</code>package内生成mocks</li><li><code>github.com/sgreben/testing-with-gomock/doer</code>： 为这个package生成mocks (包名而已，根据实际情况定)</li><li><code>Doer</code>: 为这个interface生成mocks，如果想要mock多个接口，可以传入以逗号分隔的列表<code>Doer1,Doer2</code>，对接口的声明必须清楚。</li></ol><p><em>注意如果<code>$GOPATH/bin</code>不在<code>$PATH</code>中，<code>mockgen</code>要改成<code>$GOPATH/bin/mockgen</code></em></p><p>最终<code>mockgen</code>会生成<code>mock_doer.go</code>这个文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Code generated by MockGen. DO NOT EDIT.</span>
</span></span><span class=line><span class=cl><span class=c1>// Source: github.com/sgreben/testing-with-gomock/doer (interfaces: Doer)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>package</span> <span class=nx>mocks</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>gomock</span> <span class=s>&#34;github.com/golang/mock/gomock&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// MockDoer is a mock of Doer interface</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MockDoer</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctrl</span>     <span class=o>*</span><span class=nx>gomock</span><span class=p>.</span><span class=nx>Controller</span>
</span></span><span class=line><span class=cl>	<span class=nx>recorder</span> <span class=o>*</span><span class=nx>MockDoerMockRecorder</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// MockDoerMockRecorder is the mock recorder for MockDoer</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MockDoerMockRecorder</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mock</span> <span class=o>*</span><span class=nx>MockDoer</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// NewMockDoer creates a new mock instance</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewMockDoer</span><span class=p>(</span><span class=nx>ctrl</span> <span class=o>*</span><span class=nx>gomock</span><span class=p>.</span><span class=nx>Controller</span><span class=p>)</span> <span class=o>*</span><span class=nx>MockDoer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mock</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>MockDoer</span><span class=p>{</span><span class=nx>ctrl</span><span class=p>:</span> <span class=nx>ctrl</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>mock</span><span class=p>.</span><span class=nx>recorder</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>MockDoerMockRecorder</span><span class=p>{</span><span class=nx>mock</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>mock</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// EXPECT returns an object that allows the caller to indicate expected use</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>_m</span> <span class=o>*</span><span class=nx>MockDoer</span><span class=p>)</span> <span class=nf>EXPECT</span><span class=p>()</span> <span class=o>*</span><span class=nx>MockDoerMockRecorder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>_m</span><span class=p>.</span><span class=nx>recorder</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// DoSomething mocks base method</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>_m</span> <span class=o>*</span><span class=nx>MockDoer</span><span class=p>)</span> <span class=nf>DoSomething</span><span class=p>(</span><span class=nx>_param0</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>_param1</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ret</span> <span class=o>:=</span> <span class=nx>_m</span><span class=p>.</span><span class=nx>ctrl</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span><span class=nx>_m</span><span class=p>,</span> <span class=s>&#34;DoSomething&#34;</span><span class=p>,</span> <span class=nx>_param0</span><span class=p>,</span> <span class=nx>_param1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>ret0</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>ret</span><span class=p>[</span><span class=mi>0</span><span class=p>].(</span><span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>ret0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// DoSomething indicates an expected call of DoSomething</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>_mr</span> <span class=o>*</span><span class=nx>MockDoerMockRecorder</span><span class=p>)</span> <span class=nf>DoSomething</span><span class=p>(</span><span class=nx>arg0</span><span class=p>,</span> <span class=nx>arg1</span> <span class=kd>interface</span><span class=p>{})</span> <span class=o>*</span><span class=nx>gomock</span><span class=p>.</span><span class=nx>Call</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>_mr</span><span class=p>.</span><span class=nx>mock</span><span class=p>.</span><span class=nx>ctrl</span><span class=p>.</span><span class=nf>RecordCall</span><span class=p>(</span><span class=nx>_mr</span><span class=p>.</span><span class=nx>mock</span><span class=p>,</span> <span class=s>&#34;DoSomething&#34;</span><span class=p>,</span> <span class=nx>arg0</span><span class=p>,</span> <span class=nx>arg1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>浏览一下代码，可以看到生成的<code>EXPECT()</code>方法和mock接口的方法在一个层级，这里是<code>DoSomething</code>，因为要避免名字冲突，所以这里把<code>EXPECT</code>定义成全大写。</p><p>下面，我们在测试中创建一个<em>mock controller</em>。 mock controller的作用是跟踪以及对相关mocks对象的进行期望断言(asserting the expectations)。</p><p>创建controller的方法就是，传入构建函数代表<code>*testing.T</code>的<code>t</code>，而后将其作为参数传入<code>Doer</code>mock对象的构建函数:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>mockCtrl</span> <span class=o>:=</span> <span class=nx>gomock</span><span class=p>.</span><span class=nf>NewController</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>defer</span> <span class=nx>mockCtrl</span><span class=p>.</span><span class=nf>Finish</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>mockDoer</span> <span class=o>:=</span> <span class=nx>mocks</span><span class=p>.</span><span class=nf>NewMockDoer</span><span class=p>(</span><span class=nx>mockCtrl</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>上述对<code>Finish</code>的defer后面再说。</p><p>假设我们想要断言<code>mockerDoer</code>的<code>Do</code>方法将会被调用一次，传入<code>123</code>以及<code>Hello GoMock</code>作为参数并且返回<code>nil</code>。</p><p>为了实现这个断言，我们在<code>mockDoer</code>对象上调用<code>EXPECT()</code>设置期望。<code>EXPECT()</code>其实返回的是一个<code>mock recorder</code>的对象，它包含了真实对象的所有同名方法。</p><p>我们能够进行如下的链式调用:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>mockDoer</span><span class=p>.</span><span class=nf>EXPECT</span><span class=p>().</span><span class=nf>DoSomething</span><span class=p>(</span><span class=mi>123</span><span class=p>,</span> <span class=s>&#34;Hello GoMock&#34;</span><span class=p>).</span><span class=nf>Return</span><span class=p>(</span><span class=kc>nil</span><span class=p>).</span><span class=nf>Times</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>从这个调用其实你也能理解每个的意义，如果要设置方法被调用的次数，除了上述的<code>Times(number)</code>，还有诸如<code>MaxTimes(number)</code>以及<code>MinTimes(numbers)</code>这种显性的限制。</p><p>看上去差不多了，接下来写一个完整的user_test.go`:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>user_test</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;github.com/sgreben/testing-with-gomock/mocks&#34;</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;github.com/sgreben/testing-with-gomock/user&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestUse</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>mockCtrl</span> <span class=o>:=</span> <span class=nx>gomock</span><span class=p>.</span><span class=nf>NewController</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>mockCtrl</span><span class=p>.</span><span class=nf>Finish</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>mockDoer</span> <span class=o>:=</span> <span class=nx>mocks</span><span class=p>.</span><span class=nf>NewMockDoer</span><span class=p>(</span><span class=nx>mockCtrl</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>testUser</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>user</span><span class=p>.</span><span class=nx>User</span><span class=p>{</span><span class=nx>Doer</span><span class=p>:</span><span class=nx>mockDoer</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Expect Do to be called once with 123 and &#34;Hello GoMock&#34; as parameters, and return nil from the mocked call.</span>
</span></span><span class=line><span class=cl>    <span class=nx>mockDoer</span><span class=p>.</span><span class=nf>EXPECT</span><span class=p>().</span><span class=nf>DoSomething</span><span class=p>(</span><span class=mi>123</span><span class=p>,</span> <span class=s>&#34;Hello GoMock&#34;</span><span class=p>).</span><span class=nf>Return</span><span class=p>(</span><span class=kc>nil</span><span class=p>).</span><span class=nf>Times</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>testUser</span><span class=p>.</span><span class=nf>Use</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>可能这个代码里对mock期望的断言并不明显，断言发生在defer掉的<code>Finish()</code>。相当于对<code>Finish</code>的调用发生在mock controller的声明的时候 - 这样我们不会忘记在后面加上期望断言。</p><p>最后跑一下测试:</p><pre tabindex=0><code>$ go test -v github.com/sgreben/testing-with-gomock/user
=== RUN   TestUse
--- PASS: TestUse (0.00s)
PASS
ok      github.com/sgreben/testing-with-gomock/user     0.007s
</code></pre><p>当然如果你想构建多个mock对象，你可以对mock controller进行复用，它的<code>Finish</code>相当于会发生在所有和controller关联的mock对象的期望断言被设置之后。</p><p>我们也可以测试一下mock方法的返回值，这里改写一下测试返回一个<code>dummyError</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestUseReturnsErrorFromDo</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>mockCtrl</span> <span class=o>:=</span> <span class=nx>gomock</span><span class=p>.</span><span class=nf>NewController</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>mockCtrl</span><span class=p>.</span><span class=nf>Finish</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>dummyError</span> <span class=o>:=</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;dummy error&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>mockDoer</span> <span class=o>:=</span> <span class=nx>mocks</span><span class=p>.</span><span class=nf>NewMockDoer</span><span class=p>(</span><span class=nx>mockCtrl</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>testUser</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>user</span><span class=p>.</span><span class=nx>User</span><span class=p>{</span><span class=nx>Doer</span><span class=p>:</span><span class=nx>mockDoer</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Expect Do to be called once with 123 and &#34;Hello GoMock&#34; as parameters, and return dummyError from the mocked call.</span>
</span></span><span class=line><span class=cl>    <span class=nx>mockDoer</span><span class=p>.</span><span class=nf>EXPECT</span><span class=p>().</span><span class=nf>DoSomething</span><span class=p>(</span><span class=mi>123</span><span class=p>,</span> <span class=s>&#34;Hello GoMock&#34;</span><span class=p>).</span><span class=nf>Return</span><span class=p>(</span><span class=nx>dummyError</span><span class=p>).</span><span class=nf>Times</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>err</span> <span class=o>:=</span> <span class=nx>testUser</span><span class=p>.</span><span class=nf>Use</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=nx>dummyError</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span><span class=p>.</span><span class=nf>Fail</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=通过gogenerate使用gomock>通过<code>go:generate</code>使用<em>GoMock</em><a hidden class=anchor aria-hidden=true href=#通过gogenerate使用gomock>#</a></h4><p>有些人可能发现一个workflow的问题，如果对每个package以及interface都用mockgen肯定是非常繁琐的，特别是如果我们开发的项目有大量的接口和包定义。为了解决这个问题，<code>mockgen</code>命令行能够被特殊的<code>go:generate</code>注释去替代。</p><p>比如，在我们的例子里，我们能够在<code>doer.go</code>的<code>package</code>声明下面添加注释:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>doer</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//go:generate mockgen -destination=../mocks/mock_doer.go -package=mocks github.com/sgreben/testing-with-gomock/doer Doer</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Doer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>DoSomething</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>但是这种写法也有个问题，因为代码文件目录和mocks目录的不一致，导致我们需要添加<code>../mocks</code>类似的路径而不是简单的<code>mocks/</code>，我们可以在项目的根路径下生成所有mocks:</p><pre tabindex=0><code>go generate ./...
</code></pre><p>写法上注意代码里<code>//</code>和<code>go:generate</code>之间没有空格。</p><p>对于添加<code>go:generate</code>注释的原则以及一些mock的构建命名原则如下:</p><ol><li>每个包含需要mock的interfaces的文件中添加一个<code>go:generate</code>注释</li><li>如果要用<code>mockgen</code>要传入清晰的interface名</li><li>把mock文件放在<code>mocks</code>包下，名称改写<code>X.go</code>到<code>mocks/mock_X.go</code></li></ol><h4 id=使用参数匹配器>使用参数匹配器<a hidden class=anchor aria-hidden=true href=#使用参数匹配器>#</a></h4><p>有些情况下，你对mock中的特定参数不太关心，当然我们可以清楚地固定参数，也可以用参数匹配器去匹配参数，我们称之为<code>Matcher</code>，熟悉Ginkgo框架的同学应该很清楚。</p><p><code>GoMock</code>中预设了几个matchers：</p><ol><li><code>gomock.Any()</code>： 匹配所有类型、所有值</li><li><code>gomock.Eq(x)</code>: 使用反射去匹配任何与<code>x</code>为<code>DeepEqual</code>的值</li><li><code>gomock.Nil()</code>： 匹配<code>nil</code></li><li><code>gomock.Not(m)</code>: 这里<code>m</code>是一个Matcher，也就是匹配所有没有被<code>m</code>匹配的值</li><li><code>gomock.Not(x)</code>: 这里<code>x</code>不是一个Matcher，匹配所有与<code>x</code>不<code>DeepEqual</code>的值</li></ol><p>举个例子，如果我们不关心<code>Do</code>方法的第一个参数:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>mockDoer</span><span class=p>.</span><span class=nf>EXPECT</span><span class=p>().</span><span class=nf>DoSomething</span><span class=p>(</span><span class=nx>gomock</span><span class=p>.</span><span class=nf>Any</span><span class=p>(),</span> <span class=s>&#34;Hello GoMock&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><code>GoMock</code>会自动把非匹配类型的参数转化为<code>Eq</code>匹配器：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>mockDoer</span><span class=p>.</span><span class=nf>EXPECT</span><span class=p>().</span><span class=nf>DoSomething</span><span class=p>(</span><span class=nx>gomock</span><span class=p>.</span><span class=nf>Any</span><span class=p>(),</span> <span class=nx>gomock</span><span class=p>.</span><span class=nf>Eq</span><span class=p>(</span><span class=s>&#34;Hello GoMock&#34;</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>当然我们也可以自定义Matchers，实现接口就行, <code>gomock/matchers.go</code> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Matcher</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Matches</span><span class=p>(</span><span class=nx>x</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>    <span class=nf>String</span><span class=p>()</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这里的<code>Matches</code>方法是实例匹配发生的地方，<code>String</code>方法针对测试失败时生成human-readable的信息，我们可以自己写一个matcher去检查参数类型：</p><p><code>match/oftype.go</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>match</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;reflect&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/golang/mock/gomock&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ofType</span> <span class=kd>struct</span><span class=p>{</span> <span class=nx>t</span> <span class=kt>string</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>OfType</span><span class=p>(</span><span class=nx>t</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>gomock</span><span class=p>.</span><span class=nx>Matcher</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>ofType</span><span class=p>{</span><span class=nx>t</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>o</span> <span class=o>*</span><span class=nx>ofType</span><span class=p>)</span> <span class=nf>Matches</span><span class=p>(</span><span class=nx>x</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>TypeOf</span><span class=p>(</span><span class=nx>x</span><span class=p>).</span><span class=nf>String</span><span class=p>()</span> <span class=o>==</span> <span class=nx>o</span><span class=p>.</span><span class=nx>t</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>o</span> <span class=o>*</span><span class=nx>ofType</span><span class=p>)</span> <span class=nf>String</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s>&#34;is of type &#34;</span> <span class=o>+</span> <span class=nx>o</span><span class=p>.</span><span class=nx>t</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>然后我们就可以使用我们的matcher:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Expect Do to be called once with 123 and any string as parameters, and return nil from the mocked call.</span>
</span></span><span class=line><span class=cl><span class=nx>mockDoer</span><span class=p>.</span><span class=nf>EXPECT</span><span class=p>().</span>
</span></span><span class=line><span class=cl>    <span class=nf>DoSomething</span><span class=p>(</span><span class=mi>123</span><span class=p>,</span> <span class=nx>match</span><span class=p>.</span><span class=nf>OfType</span><span class=p>(</span><span class=s>&#34;string&#34;</span><span class=p>)).</span>
</span></span><span class=line><span class=cl>    <span class=nf>Return</span><span class=p>(</span><span class=kc>nil</span><span class=p>).</span>
</span></span><span class=line><span class=cl>    <span class=nf>Times</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>注意下上述我们分行写，要把<code>.</code>写在行末尾，不然编译器会报错。</p><h4 id=断言调用顺序>断言调用顺序<a hidden class=anchor aria-hidden=true href=#断言调用顺序>#</a></h4><p>对一个对象的调用顺序也是很重要的，<em>GoMock</em>提供了<code>.After</code>方法显式地定义一个方法必须在另一个方法后面被调用:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>callFirst</span> <span class=o>:=</span> <span class=nx>mockDoer</span><span class=p>.</span><span class=nf>EXPECT</span><span class=p>().</span><span class=nf>DoSomething</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;first this&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>callA</span> <span class=o>:=</span> <span class=nx>mockDoer</span><span class=p>.</span><span class=nf>EXPECT</span><span class=p>().</span><span class=nf>DoSomething</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;then this&#34;</span><span class=p>).</span><span class=nf>After</span><span class=p>(</span><span class=nx>callFirst</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>callB</span> <span class=o>:=</span> <span class=nx>mockDoer</span><span class=p>.</span><span class=nf>EXPECT</span><span class=p>().</span><span class=nf>DoSomething</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;or this&#34;</span><span class=p>).</span><span class=nf>After</span><span class=p>(</span><span class=nx>callFirst</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>这个代码都能理解。</p><p>此外还提供了一个更直观的手段去定义断言顺序，也就是<code>gomock.InOrder</code>，这种写法更容易阅读:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>gomock</span><span class=p>.</span><span class=nf>InOrder</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>mockDoer</span><span class=p>.</span><span class=nf>EXPECT</span><span class=p>().</span><span class=nf>DoSomething</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;first this&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=nx>mockDoer</span><span class=p>.</span><span class=nf>EXPECT</span><span class=p>().</span><span class=nf>DoSomething</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;then this&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=nx>mockDoer</span><span class=p>.</span><span class=nf>EXPECT</span><span class=p>().</span><span class=nf>DoSomething</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=s>&#34;then this&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=nx>mockDoer</span><span class=p>.</span><span class=nf>EXPECT</span><span class=p>().</span><span class=nf>DoSomething</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=s>&#34;finally this&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=定义mock的actions>定义mock的actions<a hidden class=anchor aria-hidden=true href=#定义mock的actions>#</a></h4><p>本质上就是mock其实不会执行其他行为，我们可以人为使用<code>.Do</code>方法，并且传入调用的函数，意味着如果调用的参数匹配上了，就会执行<code>.Do</code>提供的函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>mockDoer</span><span class=p>.</span><span class=nf>EXPECT</span><span class=p>().</span>
</span></span><span class=line><span class=cl>    <span class=nf>DoSomething</span><span class=p>(</span><span class=nx>gomock</span><span class=p>.</span><span class=nf>Any</span><span class=p>(),</span> <span class=nx>gomock</span><span class=p>.</span><span class=nf>Any</span><span class=p>()).</span>
</span></span><span class=line><span class=cl>    <span class=nf>Return</span><span class=p>(</span><span class=kc>nil</span><span class=p>).</span>
</span></span><span class=line><span class=cl>    <span class=nf>Do</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>y</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Called with x =&#34;</span><span class=p>,</span><span class=nx>x</span><span class=p>,</span><span class=s>&#34;and y =&#34;</span><span class=p>,</span> <span class=nx>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span></code></pre></td></tr></table></div></div><p>一些复杂的动作，比如下面这个例子，<code>DoSomething</code>方法的第一个<code>int</code>参数应该小于或者等于第二个<code>string</code>参数的长度:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>mockDoer</span><span class=p>.</span><span class=nf>EXPECT</span><span class=p>().</span>
</span></span><span class=line><span class=cl>    <span class=nf>DoSomething</span><span class=p>(</span><span class=nx>gomock</span><span class=p>.</span><span class=nf>Any</span><span class=p>(),</span> <span class=nx>gomock</span><span class=p>.</span><span class=nf>Any</span><span class=p>()).</span>
</span></span><span class=line><span class=cl>    <span class=nf>Return</span><span class=p>(</span><span class=kc>nil</span><span class=p>).</span>
</span></span><span class=line><span class=cl>    <span class=nf>Do</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>y</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>x</span> <span class=p>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>t</span><span class=p>.</span><span class=nf>Fail</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>这种写法不能通过自定义matcher实现，因为我们关联了多个具体的值，而matcher每次只能访问一个参数。</strong></p><h3 id=sql-mockgorm>sql-mock(GORM)<a hidden class=anchor aria-hidden=true href=#sql-mockgorm>#</a></h3><p>常规的<code>database/sql/driver</code>的接口mocking可以用GoMock，但是像<code>gorm</code>之类的ORM框架就很难用常规的mock方法，以为有其他很多额外的苦力活。sql-mock的介绍为<code>Sql mock driver for golang to test database interactions. </code>可以帮助解决这个问题。</p><p>下面用BDD框架<code>Ginkgo</code>写测试用例，展示一个如何使用<code>Sqlmock</code>去测试一个简单blog应用的例子，这个例子的后端为<code>pg</code>并且使用了<code>gorm</code>。</p><p><a href=https://github.com/dche423/dbtest>源码</a></p><h4 id=定义gorm数据模型与repository>定义GORM数据模型与Repository<a hidden class=anchor aria-hidden=true href=#定义gorm数据模型与repository>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// modle.go</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;github.com/lib/pq&#34;</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Blog</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ID</span>        <span class=kt>uint</span>
</span></span><span class=line><span class=cl>	<span class=nx>Title</span>     <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>Content</span>   <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>Tags</span>      <span class=nx>pq</span><span class=p>.</span><span class=nx>StringArray</span> <span class=c1>// string array for tags</span>
</span></span><span class=line><span class=cl>	<span class=nx>CreatedAt</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// repository.go</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;github.com/jinzhu/gorm&#34;</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Repository</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>db</span> <span class=o>*</span><span class=nx>gorm</span><span class=p>.</span><span class=nx>DB</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Repository</span><span class=p>)</span> <span class=nf>ListAll</span><span class=p>()</span> <span class=p>([]</span><span class=o>*</span><span class=nx>Blog</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>l</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Blog</span>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>db</span><span class=p>.</span><span class=nf>Find</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>).</span><span class=nx>Error</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>l</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Repository</span><span class=p>)</span> <span class=nf>Load</span><span class=p>(</span><span class=nx>id</span> <span class=kt>uint</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>Blog</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>blog</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Blog</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>db</span><span class=p>.</span><span class=nf>Where</span><span class=p>(</span><span class=s>`id = ?`</span><span class=p>,</span> <span class=nx>id</span><span class=p>).</span><span class=nf>First</span><span class=p>(</span><span class=nx>blog</span><span class=p>).</span><span class=nx>Error</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>blog</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Repository</code>结构非常简单，有着<code>*gorm.DB</code>字段，所有的DB操作依赖于此。这里为了简洁把一些多余的代码省略了。除了<code>Load</code>、<code>ListAll</code>当然还有类似<code>Save</code>、<code>Delete</code>、<code>SearchByTitle</code>等方法。</p><h4 id=单元测试>单元测试<a hidden class=anchor aria-hidden=true href=#单元测试>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>	<span class=p>.</span> <span class=s>&#34;github.com/onsi/ginkgo&#34;</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span> <span class=s>&#34;github.com/onsi/gomega&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/DATA-DOG/go-sqlmock&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/jinzhu/gorm&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>_</span> <span class=p>=</span> <span class=nf>Describe</span><span class=p>(</span><span class=s>&#34;Repository&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>repository</span> <span class=o>*</span><span class=nx>Repository</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>mock</span> <span class=nx>sqlmock</span><span class=p>.</span><span class=nx>Sqlmock</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>BeforeEach</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>db</span> <span class=o>*</span><span class=nx>sql</span><span class=p>.</span><span class=nx>DB</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>err</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>db</span><span class=p>,</span> <span class=nx>mock</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>sqlmock</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span> <span class=c1>// mock sql.DB</span>
</span></span><span class=line><span class=cl>		<span class=nf>Expect</span><span class=p>(</span><span class=nx>err</span><span class=p>).</span><span class=nf>ShouldNot</span><span class=p>(</span><span class=nf>HaveOccurred</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>gdb</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>gorm</span><span class=p>.</span><span class=nf>Open</span><span class=p>(</span><span class=s>&#34;postgres&#34;</span><span class=p>,</span> <span class=nx>db</span><span class=p>)</span> <span class=c1>// open gorm db</span>
</span></span><span class=line><span class=cl>		<span class=nf>Expect</span><span class=p>(</span><span class=nx>err</span><span class=p>).</span><span class=nf>ShouldNot</span><span class=p>(</span><span class=nf>HaveOccurred</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>repository</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>Repository</span><span class=p>{</span><span class=nx>db</span><span class=p>:</span> <span class=nx>gdb</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nf>AfterEach</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=o>:=</span> <span class=nx>mock</span><span class=p>.</span><span class=nf>ExpectationsWereMet</span><span class=p>()</span> <span class=c1>// make sure all expectations were met</span>
</span></span><span class=line><span class=cl>		<span class=nf>Expect</span><span class=p>(</span><span class=nx>err</span><span class=p>).</span><span class=nf>ShouldNot</span><span class=p>(</span><span class=nf>HaveOccurred</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>	<span class=nf>It</span><span class=p>(</span><span class=s>&#34;test something&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	    <span class=o>...</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></td></tr></table></div></div><p>如果读者对<code>Ginkgo</code>的测试语法表示不熟悉的，可以去参阅posts里的<code>BDD</code>相关章节。在这里，<code>BeforeEach</code>中做一些测试初始化，例如<code>Repository</code>的实例化等。在<code>AfterEach</code>中加入各种断言。</p><p><code>BeforeEach</code>中的初始化分为几个步骤：</p><ol><li>创建<code>*sql.DB</code>的mock实例，利用<code>sqlmock.New()</code>创建mock控制器。</li><li><code>gorm.Open("postgres", db)</code>使用GORM。</li><li>创建<code>Repository</code>实例。</li></ol><p>在<code>AfterEach</code>中，我们使用<code>mock.ExpectationsWereMet()</code>确保所有的期望都被满足。</p><h4 id=测试listall方法>测试ListAll方法<a hidden class=anchor aria-hidden=true href=#测试listall方法>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// repository.go</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Repository</span><span class=p>)</span> <span class=nf>ListAll</span><span class=p>()</span> <span class=p>([]</span><span class=o>*</span><span class=nx>Blog</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>l</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Blog</span>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>db</span><span class=p>.</span><span class=nf>Find</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>).</span><span class=nx>Error</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>l</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// repository_test.go</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=nf>Context</span><span class=p>(</span><span class=s>&#34;list all&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>It</span><span class=p>(</span><span class=s>&#34;empty&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=kd>const</span> <span class=nx>sqlSelectAll</span> <span class=p>=</span> <span class=s>`SELECT * FROM &#34;blogs&#34;`</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=nx>mock</span><span class=p>.</span><span class=nf>ExpectQuery</span><span class=p>(</span><span class=nx>sqlSelectAll</span><span class=p>).</span>
</span></span><span class=line><span class=cl>			<span class=nf>WillReturnRows</span><span class=p>(</span><span class=nx>sqlmock</span><span class=p>.</span><span class=nf>NewRows</span><span class=p>(</span><span class=kc>nil</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>l</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>repository</span><span class=p>.</span><span class=nf>ListAll</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nf>Expect</span><span class=p>(</span><span class=nx>err</span><span class=p>).</span><span class=nf>ShouldNot</span><span class=p>(</span><span class=nf>HaveOccurred</span><span class=p>())</span>
</span></span><span class=line><span class=cl>		<span class=nf>Expect</span><span class=p>(</span><span class=nx>l</span><span class=p>).</span><span class=nf>Should</span><span class=p>(</span><span class=nf>BeEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span></code></pre></td></tr></table></div></div><p>上述snippet中，<code>ListAll</code>找到DB中的所有记录，并map到<code>*Blog</code>的切片中。测试语句非常直观，我们设置了该查询语句返回的是<code>nil</code>，也就是空集合。跑一下测试：</p><pre tabindex=0><code>➜ ginkgo     
Running Suite: Pg Suite
=======================
Random Seed: 1585542357
Will run 8 of 8 specs


(/Users/dche423/dbtest/pg/repository.go:24) 
[2020-03-30 12:26:01]  Query: could not match actual sql: &#34;SELECT * FROM &#34;blogs&#34;&#34; with expected regexp &#34;SELECT * FROM &#34;blogs&#34;&#34; 
• Failure [0.001 seconds]
Repository
/Users/dche423/dbtest/pg/repository_test.go:16
  list all
  /Users/dche423/dbtest/pg/repository_test.go:37
    empty [It]
    /Users/dche423/dbtest/pg/repository_test.go:38

...
Test Suite Failed
➜  
</code></pre><p>测试失败了&mldr;不过回显可以知道信息: <code>could not match actual sql with expected regexp.</code>。实际上Sqlmock使用<code>sqlmock.QueryMatcherRegex</code>为默认的SQL匹配器。在这个例子中，<code>sqlmock.ExpectQuery</code>输入一个正则表达式字符串而不是一个SQL的文本。所以我们有两种方式去解决这个问题:</p><ol><li>使用<code>regexp.QuoteMeta</code>， 也就是<code>mock.ExpectQuery(regexp.QuoteMeta(sqlSelectAll))</code></li><li>更改默认的SQL匹配器，当我们在创建mock实例的时候可以配置: <code>sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))</code></li></ol><p>其实一般来说，正则表达式匹配器能更灵活一些。</p><h4 id=测试load方法>测试Load方法<a hidden class=anchor aria-hidden=true href=#测试load方法>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// repository.go</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Repository</span><span class=p>)</span> <span class=nf>Load</span><span class=p>(</span><span class=nx>id</span> <span class=kt>uint</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>Blog</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>blog</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Blog</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>db</span><span class=p>.</span><span class=nf>Where</span><span class=p>(</span><span class=s>`id = ?`</span><span class=p>,</span> <span class=nx>id</span><span class=p>).</span><span class=nf>First</span><span class=p>(</span><span class=nx>blog</span><span class=p>).</span><span class=nx>Error</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>blog</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// repository_test.go</span>
</span></span><span class=line><span class=cl><span class=nf>Context</span><span class=p>(</span><span class=s>&#34;load&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>It</span><span class=p>(</span><span class=s>&#34;found&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>blog</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Blog</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=nx>ID</span><span class=p>:</span>        <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=nx>Title</span><span class=p>:</span>     <span class=s>&#34;post&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=o>...</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=nx>rows</span> <span class=o>:=</span> <span class=nx>sqlmock</span><span class=p>.</span>
</span></span><span class=line><span class=cl>                        <span class=nf>NewRows</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;id&#34;</span><span class=p>,</span> <span class=s>&#34;title&#34;</span><span class=p>,</span> <span class=s>&#34;content&#34;</span><span class=p>,</span> <span class=s>&#34;tags&#34;</span><span class=p>,</span> <span class=s>&#34;created_at&#34;</span><span class=p>}).</span>
</span></span><span class=line><span class=cl>                        <span class=nf>AddRow</span><span class=p>(</span><span class=nx>blog</span><span class=p>.</span><span class=nx>ID</span><span class=p>,</span> <span class=nx>blog</span><span class=p>.</span><span class=nx>Title</span><span class=p>,</span> <span class=nx>blog</span><span class=p>.</span><span class=nx>Content</span><span class=p>,</span> <span class=nx>blog</span><span class=p>.</span><span class=nx>Tags</span><span class=p>,</span> <span class=nx>blog</span><span class=p>.</span><span class=nx>CreatedAt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=kd>const</span> <span class=nx>sqlSelectOne</span> <span class=p>=</span> <span class=s>`SELECT * FROM &#34;blogs&#34; WHERE (id = $1) ORDER BY &#34;blogs&#34;.&#34;id&#34; ASC LIMIT 1`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=nx>mock</span><span class=p>.</span><span class=nf>ExpectQuery</span><span class=p>(</span><span class=nx>regexp</span><span class=p>.</span><span class=nf>QuoteMeta</span><span class=p>(</span><span class=nx>sqlSelectOne</span><span class=p>)).</span><span class=nf>WithArgs</span><span class=p>(</span><span class=nx>blog</span><span class=p>.</span><span class=nx>ID</span><span class=p>).</span><span class=nf>WillReturnRows</span><span class=p>(</span><span class=nx>rows</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=nx>dbBlog</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>repository</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=nx>blog</span><span class=p>.</span><span class=nx>ID</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nf>Expect</span><span class=p>(</span><span class=nx>err</span><span class=p>).</span><span class=nf>ShouldNot</span><span class=p>(</span><span class=nf>HaveOccurred</span><span class=p>())</span>
</span></span><span class=line><span class=cl>                <span class=nf>Expect</span><span class=p>(</span><span class=nx>dbBlog</span><span class=p>).</span><span class=nf>Should</span><span class=p>(</span><span class=nf>Equal</span><span class=p>(</span><span class=nx>blog</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>It</span><span class=p>(</span><span class=s>&#34;not found&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// ignore sql match</span>
</span></span><span class=line><span class=cl>                <span class=nx>mock</span><span class=p>.</span><span class=nf>ExpectQuery</span><span class=p>(</span><span class=s>`.+`</span><span class=p>).</span><span class=nf>WillReturnRows</span><span class=p>(</span><span class=nx>sqlmock</span><span class=p>.</span><span class=nf>NewRows</span><span class=p>(</span><span class=kc>nil</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>repository</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nf>Expect</span><span class=p>(</span><span class=nx>err</span><span class=p>).</span><span class=nf>Should</span><span class=p>(</span><span class=nf>Equal</span><span class=p>(</span><span class=nx>gorm</span><span class=p>.</span><span class=nx>ErrRecordNotFound</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Load</code>方法输入一个blog id作为参数，找到这个id对应的第一条记录。</p><p>我们测试两种场景:</p><ul><li>名为<code>found</code>的场景，我们创建blog实例并将其转换为<code>sql.Row</code>。随后调用<code>ExpectQuery</code>定义期望，在语句的最后，我们断言loaded blog实例和原来的一样。 <strong>注意：如果你不清楚GORM使用的是什么SQL，可以打开debug flag &ndash; gorm.DB的Debug()</strong></li><li>名为<code>not found</code>的场景，这里使用正则匹配来简化，表示不管什么sql都返回空。这里我们期望的是当找不到对应的blog时候，<code>gorm.ErrRecordNotFound</code>会被抛出。</li></ul><h4 id=测试save方法>测试Save方法<a hidden class=anchor aria-hidden=true href=#测试save方法>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// repository.go</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Repository</span><span class=p>)</span> <span class=nf>Save</span><span class=p>(</span><span class=nx>blog</span> <span class=o>*</span><span class=nx>Blog</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>p</span><span class=p>.</span><span class=nx>db</span><span class=p>.</span><span class=nf>Save</span><span class=p>(</span><span class=nx>blog</span><span class=p>).</span><span class=nx>Error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// repository_test.go</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=nf>Context</span><span class=p>(</span><span class=s>&#34;save&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kd>var</span> <span class=nx>blog</span> <span class=o>*</span><span class=nx>Blog</span>
</span></span><span class=line><span class=cl>      <span class=nf>BeforeEach</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>              <span class=nx>blog</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>Blog</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                      <span class=nx>Title</span><span class=p>:</span>     <span class=s>&#34;post&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                      <span class=nx>Content</span><span class=p>:</span>   <span class=s>&#34;hello&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                      <span class=nx>Tags</span><span class=p>:</span>      <span class=nx>pq</span><span class=p>.</span><span class=nx>StringArray</span><span class=p>{</span><span class=s>&#34;a&#34;</span><span class=p>,</span> <span class=s>&#34;b&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>                      <span class=nx>CreatedAt</span><span class=p>:</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>              <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=nf>It</span><span class=p>(</span><span class=s>&#34;insert&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>              <span class=c1>// gorm use query instead of exec</span>
</span></span><span class=line><span class=cl>              <span class=c1>// https://github.com/DATA-DOG/go-sqlmock/issues/118</span>
</span></span><span class=line><span class=cl>              <span class=kd>const</span> <span class=nx>sqlInsert</span> <span class=p>=</span> <span class=s>`
</span></span></span><span class=line><span class=cl><span class=s>                              INSERT INTO &#34;blogs&#34; (&#34;title&#34;,&#34;content&#34;,&#34;tags&#34;,&#34;created_at&#34;) 
</span></span></span><span class=line><span class=cl><span class=s>                                      VALUES ($1,$2,$3,$4) RETURNING &#34;blogs&#34;.&#34;id&#34;`</span>
</span></span><span class=line><span class=cl>              <span class=kd>const</span> <span class=nx>newId</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>              <span class=nx>mock</span><span class=p>.</span><span class=nf>ExpectBegin</span><span class=p>()</span> <span class=c1>// begin transaction</span>
</span></span><span class=line><span class=cl>              <span class=nx>mock</span><span class=p>.</span><span class=nf>ExpectQuery</span><span class=p>(</span><span class=nx>regexp</span><span class=p>.</span><span class=nf>QuoteMeta</span><span class=p>(</span><span class=nx>sqlInsert</span><span class=p>)).</span>
</span></span><span class=line><span class=cl>                      <span class=nf>WithArgs</span><span class=p>(</span><span class=nx>blog</span><span class=p>.</span><span class=nx>Title</span><span class=p>,</span> <span class=nx>blog</span><span class=p>.</span><span class=nx>Content</span><span class=p>,</span> <span class=nx>blog</span><span class=p>.</span><span class=nx>Tags</span><span class=p>,</span> <span class=nx>blog</span><span class=p>.</span><span class=nx>CreatedAt</span><span class=p>).</span>
</span></span><span class=line><span class=cl>                      <span class=nf>WillReturnRows</span><span class=p>(</span><span class=nx>sqlmock</span><span class=p>.</span><span class=nf>NewRows</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;id&#34;</span><span class=p>}).</span><span class=nf>AddRow</span><span class=p>(</span><span class=nx>newId</span><span class=p>))</span>
</span></span><span class=line><span class=cl>              <span class=nx>mock</span><span class=p>.</span><span class=nf>ExpectCommit</span><span class=p>()</span> <span class=c1>// commit transaction</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>              <span class=nf>Expect</span><span class=p>(</span><span class=nx>blog</span><span class=p>.</span><span class=nx>ID</span><span class=p>).</span><span class=nf>Should</span><span class=p>(</span><span class=nf>BeZero</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>              <span class=nx>err</span> <span class=o>:=</span> <span class=nx>repository</span><span class=p>.</span><span class=nf>Save</span><span class=p>(</span><span class=nx>blog</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=nf>Expect</span><span class=p>(</span><span class=nx>err</span><span class=p>).</span><span class=nf>ShouldNot</span><span class=p>(</span><span class=nf>HaveOccurred</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>              <span class=nf>Expect</span><span class=p>(</span><span class=nx>blog</span><span class=p>.</span><span class=nx>ID</span><span class=p>).</span><span class=nf>Should</span><span class=p>(</span><span class=nf>BeEquivalentTo</span><span class=p>(</span><span class=nx>newId</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>})</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nf>It</span><span class=p>(</span><span class=s>&#34;update&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  	<span class=o>...</span>		
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl>  	
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></td></tr></table></div></div><p>当data模型有已有的主键，<code>Save</code>方法能够更新DB记录；反之则插入一条新的记录。上面的snippet表现的插入的测试。</p><p>创建一个新的blog实例，并且不给其设置主键。而后定义<code>mock.ExpectQuery</code>。在Query开始前begin一个事务，在之后commit。<em>一般情况下，非查询语句(<code>Insert/Update</code>)应该被<code>mock.ExepectExec</code>定义，但是这个是个特殊场景。因为某些原因，对于pg的语法，GORM使用<code>QueryRow</code>而非<code>Exec</code>。</em></p><p>最后，使用<code>Expect(blog.ID).Should(BeEquivalentTo(newId))</code> 来断言<code>blog.ID</code>在<code>Save</code>方法调用之后被设置了。其实一般来说，不太需要去对简单的<code>Insert/Update</code>语句进行单元测试，但是这里只是对一些GORM会进行的一些特殊场景进行说明，像其他的后端场景不用太多关注。</p><h2 id=依赖注入>依赖注入<a hidden class=anchor aria-hidden=true href=#依赖注入>#</a></h2><h2 id=test-driven-development>Test Driven Development<a hidden class=anchor aria-hidden=true href=#test-driven-development>#</a></h2><p><a href=https://studygolang.gitbook.io/learn-go-with-tests/go-ji-chu/maps>TDD Reference</a></p><h3 id=channel-tdd-过程>channel TDD 过程<a hidden class=anchor aria-hidden=true href=#channel-tdd-过程>#</a></h3><h4 id=目标>目标<a hidden class=anchor aria-hidden=true href=#目标>#</a></h4><p>目标： 写一个 <code>CheckWebsites</code> 的函数检查 URL 列表的状态。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>concurrency</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WebsiteChecker</span> <span class=kd>func</span><span class=p>(</span><span class=kt>string</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>CheckWebsites</span><span class=p>(</span><span class=nx>wc</span> <span class=nx>WebsiteChecker</span><span class=p>,</span> <span class=nx>urls</span> <span class=p>[]</span><span class=kt>string</span><span class=p>)</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>results</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>url</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>urls</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>results</span><span class=p>[</span><span class=nx>url</span><span class=p>]</span> <span class=p>=</span> <span class=nf>wc</span><span class=p>(</span><span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>results</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>它返回一个 map，由每个 url 检查后的得到的布尔值组成，成功响应的值为 <code>true</code>，错误响应的值为 <code>false</code>。</p><p>你还必须传入一个 <code>WebsiteChecker</code> 处理单个 URL 并返回一个布尔值。它会被函数调用以检查所有的网站。</p><p>使用 <a href=https://github.com/studygolang/learn-go-with-tests/tree/d8b18269a68c1cf4b8e8b0900f2815dc9d66d87e/zh-CN/zh-CN/dependency-injection.md>依赖注入</a>，允许在不发起真实 HTTP 请求的情况下测试函数，这使测试变得可靠和快速。</p><p>下面是简单的测试：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>concurrency</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;reflect&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;testing&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>mockWebsiteChecker</span><span class=p>(</span><span class=nx>url</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>url</span> <span class=o>==</span> <span class=s>&#34;waat://furhurterwe.geds&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestCheckWebsites</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>websites</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;http://google.com&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;http://blog.gypsydave5.com&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;waat://furhurterwe.geds&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>actualResults</span> <span class=o>:=</span> <span class=nf>CheckWebsites</span><span class=p>(</span><span class=nx>mockWebsiteChecker</span><span class=p>,</span> <span class=nx>websites</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>want</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>websites</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>got</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>actualResults</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>want</span> <span class=o>!=</span> <span class=nx>got</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;Wanted %v, got %v&#34;</span><span class=p>,</span> <span class=nx>want</span><span class=p>,</span> <span class=nx>got</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>expectedResults</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;http://google.com&#34;</span><span class=p>:</span>          <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;http://blog.gypsydave5.com&#34;</span><span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;waat://furhurterwe.geds&#34;</span><span class=p>:</span>    <span class=kc>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>!</span><span class=nx>reflect</span><span class=p>.</span><span class=nf>DeepEqual</span><span class=p>(</span><span class=nx>expectedResults</span><span class=p>,</span> <span class=nx>actualResults</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;Wanted %v, got %v&#34;</span><span class=p>,</span> <span class=nx>expectedResults</span><span class=p>,</span> <span class=nx>actualResults</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>该功能在生产环境中被用于检查数百个网站。但是它速度很慢，所以需要为程序提速。</p><h4 id=写一个测试>写一个测试<a hidden class=anchor aria-hidden=true href=#写一个测试>#</a></h4><p>首先我们对 <code>CheckWebsites</code> 做一个基准测试，这样就能看到我们修改的影响。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>concurrency</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;testing&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>slowStubWebsiteChecker</span><span class=p>(</span><span class=nx>_</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>20</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkCheckWebsites</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>urls</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>string</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>urls</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>urls</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;a url&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>CheckWebsites</span><span class=p>(</span><span class=nx>slowStubWebsiteChecker</span><span class=p>,</span> <span class=nx>urls</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>基准测试使用一百个网址的 slice 对 <code>CheckWebsites</code> 进行测试，并使用 <code>WebsiteChecker</code> 的伪造实现。<code>slowStubWebsiteChecker</code> 故意放慢速度。它使用 <code>time.Sleep</code> 明确等待 20 毫秒，然后返回 true。</p><p>当我们运行基准测试时使用 <code>go test -bench=.</code> 命令 (如果在 Windows Powershell 环境下使用 <code>go test -bench="."</code>)：</p><pre tabindex=0><code>pkg: github.com/gypsydave5/learn-go-with-tests/concurrency/v0
BenchmarkCheckWebsites-4               1        2249228637 ns/op
PASS
ok      github.com/gypsydave5/learn-go-with-tests/concurrency/v0        2.268s
</code></pre><p><code>CheckWebsite</code> 经过基准测试的时间为 2249228637 纳秒，大约 2.25 秒。</p><p>让我们尝试去让它运行得更快。</p><h4 id=编写足够的代码让它通过>编写足够的代码让它通过<a hidden class=anchor aria-hidden=true href=#编写足够的代码让它通过>#</a></h4><p>现在我们终于可以谈论并发了，以下内容是为了说明「不止一件事情正在进行中」。这是我们每天很自然在做的事情。</p><p>比如，今天早上我泡了一杯茶。我放上水壶，然后在等待它煮沸时，从冰箱里取出了牛奶，把茶从柜子里拿出来，找到我最喜欢的杯子，把茶袋放进杯子里，然后等水壶沸了，把水倒进杯子里。</p><p>我 <em>没有</em> 做的事情是放上水壶，然后呆呆地盯着水壶等水煮沸，然后在煮沸后再做其他事情。</p><p>如果你能理解为什么第一种方式泡茶更快，那你就可以理解我们如何让 <code>CheckWebsites</code> 变得更快。与其等待网站响应之后再发送下一个网站的请求，不如告诉计算机在等待时就发起下一个请求。</p><p>通常在 Go 中，当调用函数 <code>doSomething()</code> 时，我们等待它返回（即使它没有值返回，我们仍然等待它完成）。我们说这个操作是 <em>阻塞</em> 的 —— 它让我们等待它完成。Go 中不会阻塞的操作将在称为 <em>goroutine</em> 的单独 <em>进程</em> 中运行。将程序想象成从上到下读 Go 的 代码，当函数被调用执行读取操作时，进入每个函数「内部」。当一个单独的进程开始时，就像开启另一个 reader（阅读程序）在函数内部执行读取操作，原来的 reader 继续向下读取 Go 代码。</p><p>要告诉 Go 开始一个新的 goroutine，我们把一个函数调用变成 <code>go</code> 声明，通过把关键字 <code>go</code> 放在它前面：<code>go doSomething()</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>concurrency</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WebsiteChecker</span> <span class=kd>func</span><span class=p>(</span><span class=kt>string</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>CheckWebsites</span><span class=p>(</span><span class=nx>wc</span> <span class=nx>WebsiteChecker</span><span class=p>,</span> <span class=nx>urls</span> <span class=p>[]</span><span class=kt>string</span><span class=p>)</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>results</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>url</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>urls</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>results</span><span class=p>[</span><span class=nx>url</span><span class=p>]</span> <span class=p>=</span> <span class=nf>wc</span><span class=p>(</span><span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>results</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>因为开启 goroutine 的唯一方法就是将 <code>go</code> 放在函数调用前面，所以当我们想要启动 goroutine 时，我们经常使用 <em>匿名函数（anonymous functions）</em>。一个匿名函数文字看起来和正常函数声明一样，但没有名字（意料之中）。你可以在 上面的 <code>for</code> 循环体中看到一个。</p><p>匿名函数有许多有用的特性，其中两个上面正在使用。首先，它们可以在声明的同时执行 —— 这就是匿名函数末尾的 <code>()</code> 实现的。其次，它们维护对其所定义的词汇作用域的访问权 —— 在声明匿名函数时所有可用的变量也可在函数体内使用。</p><p>上面匿名函数的主体和之前循环体中的完全一样。唯一的区别是循环的每次迭代都会启动一个新的 goroutine，与当前进程（<code>WebsiteChecker</code> 函数）同时发生，每个循环都会将结果添加到 <code>results</code> map 中。</p><p>但是当我们执行 <code>go test</code>：</p><pre tabindex=0><code>-------- FAIL: TestCheckWebsites (0.00s)
        CheckWebsites_test.go:31: Wanted map[http://google.com:true http://blog.gypsydave5.com:true waat://furhurterwe.geds:false], got map[]
FAIL
exit status 1
FAIL    github.com/gypsydave5/learn-go-with-tests/concurrency/v1        0.010s
</code></pre><h4 id=不可预知的问题>不可预知的问题<a hidden class=anchor aria-hidden=true href=#不可预知的问题>#</a></h4><p>你可能不会得到这个结果。你可能会得到一个 panic 信息，这个稍后再谈。如果你得到的是那些结果，不要担心，只要继续运行测试，直到你得到上述结果。或假装你得到了，这取决于你。欢迎来到并发编程的世界：如果处理不正确，很难预测会发生什么。别担心 —— 这就是我们编写测试的原因，当处理并发时，测试帮助我们预测可能发生的情况。</p><p>让我们困惑的是，原来的测试 <code>WebsiteChecker</code> 现在返回空的 map。哪里出问题了？</p><p>我们 <code>for</code> 循环开始的 <code>goroutines</code> 没有足够的时间将结果添加结果到 <code>results</code> map 中；<code>WebsiteChecker</code> 函数对于它们来说太快了，以至于它返回时仍为空的 map。</p><p>为了解决这个问题，我们可以等待所有的 goroutine 完成他们的工作，然后返回。两秒钟应该能完成了，对吧？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>concurrency</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WebsiteChecker</span> <span class=kd>func</span><span class=p>(</span><span class=kt>string</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>CheckWebsites</span><span class=p>(</span><span class=nx>wc</span> <span class=nx>WebsiteChecker</span><span class=p>,</span> <span class=nx>urls</span> <span class=p>[]</span><span class=kt>string</span><span class=p>)</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>results</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>url</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>urls</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>results</span><span class=p>[</span><span class=nx>url</span><span class=p>]</span> <span class=p>=</span> <span class=nf>wc</span><span class=p>(</span><span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>results</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>现在当我们运行测试时获得的结果（如果没有得到 —— 参考上面的做法）：</p><pre tabindex=0><code>-------- FAIL: TestCheckWebsites (0.00s)
        CheckWebsites_test.go:31: Wanted map[http://google.com:true http://blog.gypsydave5.com:true waat://furhurterwe.geds:false], got map[waat://furhurterwe.geds:false]
FAIL
exit status 1
FAIL    github.com/gypsydave5/learn-go-with-tests/concurrency/v1        0.010s
</code></pre><p>这不是很好 - 为什么只有一个结果？我们可以尝试通过增加等待的时间来解决这个问题 —— 如果你愿意，可以试试。但没什么作用。这里的问题是变量 <code>url</code> 被重复用于 <code>for</code> 循环的每次迭代 —— 每次都会从 <code>urls</code> 获取新值。但是我们的每个 goroutine 都是 <code>url</code> 变量的引用 —— 它们没有自己的独立副本。所以他们 <em>都</em> 会写入在迭代结束时的 <code>url</code> —— 最后一个 url。这就是为什么我们得到的结果是最后一个 url &mdash;- <strong>注意：闭包情况下的引用关系一直是需要注意的</strong></p><p>解决这个问题:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WebsiteChecker</span> <span class=kd>func</span><span class=p>(</span><span class=kt>string</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>CheckWebsites</span><span class=p>(</span><span class=nx>wc</span> <span class=nx>WebsiteChecker</span><span class=p>,</span> <span class=nx>urls</span> <span class=p>[]</span><span class=kt>string</span><span class=p>)</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>results</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>url</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>urls</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>u</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>results</span><span class=p>[</span><span class=nx>u</span><span class=p>]</span> <span class=p>=</span> <span class=nf>wc</span><span class=p>(</span><span class=nx>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>results</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>通过给每个匿名函数一个参数 url(<code>u</code>)，然后用 <code>url</code> 作为参数调用匿名函数，我们确保 <code>u</code> 的值固定为循环迭代的 <code>url</code> 值，重新启动 <code>goroutine</code>。<code>u</code> 是 <code>url</code> 值的副本，因此无法更改。</p><p>现在，如果你幸运的话，你会得到：</p><pre tabindex=0><code>PASS
ok      github.com/gypsydave5/learn-go-with-tests/concurrency/v1        2.012s
</code></pre><p>但是，如果你不走运（如果你运行基准测试，这很可能会发生，因为你将发起多次的尝试）。</p><pre tabindex=0><code>fatal error: concurrent map writes

goroutine 8 [running]:
runtime.throw(0x12c5895, 0x15)
        /usr/local/Cellar/go/1.9.3/libexec/src/runtime/panic.go:605 +0x95 fp=0xc420037700 sp=0xc4200376e0 pc=0x102d395
runtime.mapassign_faststr(0x1271d80, 0xc42007acf0, 0x12c6634, 0x17, 0x0)
        /usr/local/Cellar/go/1.9.3/libexec/src/runtime/hashmap_fast.go:783 +0x4f5 fp=0xc420037780 sp=0xc420037700 pc=0x100eb65
github.com/gypsydave5/learn-go-with-tests/concurrency/v3.WebsiteChecker.func1(0xc42007acf0, 0x12d3938, 0x12c6634, 0x17)
        /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:12 +0x71 fp=0xc4200377c0 sp=0xc420037780 pc=0x12308f1
runtime.goexit()
        /usr/local/Cellar/go/1.9.3/libexec/src/runtime/asm_amd64.s:2337 +0x1 fp=0xc4200377c8 sp=0xc4200377c0 pc=0x105cf01
created by github.com/gypsydave5/learn-go-with-tests/concurrency/v3.WebsiteChecker
        /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:11 +0xa1

        ... many more scary lines of text ...
</code></pre><p>这看上去冗长、可怕，我们需要深呼吸并阅读错误：<code>fatal error: concurrent map writes</code>。有时候，当我们运行我们的测试时，两个 goroutines 完全同时写入 <code>results</code> map。Go 的 Maps 不喜欢多个事物试图一次性写入，所以就导致了 <code>fatal error</code>。</p><p>这是一种 <em>race condition（竞争条件）</em>，当软件的输出取决于事件发生的时间和顺序时，因为我们无法控制，bug 就会出现。因为我们无法准确控制每个 goroutine 写入结果 map 的时间，两个 goroutines 同一时间写入时程序将非常脆弱。</p><p>Go 可以帮助我们通过其内置的 <a href=https://blog.golang.org/race-detector>race detector</a> 来发现竞争条件。要启用此功能，请使用 <code>race</code> 标志运行测试：<code>go test -race</code>。</p><p>你应该得到一些如下所示的输出：</p><pre tabindex=0><code>==================
WARNING: DATA RACE
Write at 0x00c420084d20 by goroutine 8:
  runtime.mapassign_faststr()
      /usr/local/Cellar/go/1.9.3/libexec/src/runtime/hashmap_fast.go:774 +0x0
  github.com/gypsydave5/learn-go-with-tests/concurrency/v3.WebsiteChecker.func1()
      /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:12 +0x82

Previous write at 0x00c420084d20 by goroutine 7:
  runtime.mapassign_faststr()
      /usr/local/Cellar/go/1.9.3/libexec/src/runtime/hashmap_fast.go:774 +0x0
  github.com/gypsydave5/learn-go-with-tests/concurrency/v3.WebsiteChecker.func1()
      /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:12 +0x82

Goroutine 8 (running) created at:
  github.com/gypsydave5/learn-go-with-tests/concurrency/v3.WebsiteChecker()
      /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:11 +0xc4
  github.com/gypsydave5/learn-go-with-tests/concurrency/v3.TestWebsiteChecker()
      /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker_test.go:27 +0xad
  testing.tRunner()
      /usr/local/Cellar/go/1.9.3/libexec/src/testing/testing.go:746 +0x16c

Goroutine 7 (finished) created at:
  github.com/gypsydave5/learn-go-with-tests/concurrency/v3.WebsiteChecker()
      /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:11 +0xc4
  github.com/gypsydave5/learn-go-with-tests/concurrency/v3.TestWebsiteChecker()
      /Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker_test.go:27 +0xad
  testing.tRunner()
      /usr/local/Cellar/go/1.9.3/libexec/src/testing/testing.go:746 +0x16c
==================
</code></pre><p>细节还是难以阅读 - 但 <code>WARNING: DATA RACE</code> 相当明确。阅读错误的内容，我们可以看到两个不同的 goroutines 在 map 上执行写入操作：</p><pre tabindex=0><code>Write at 0x00c420084d20 by goroutine 8:
</code></pre><p>正在写入相同的内存块</p><pre tabindex=0><code>Previous write at 0x00c420084d20 by goroutine 7:
</code></pre><p>最重要的是，我们可以看到发生写入的代码行：</p><pre tabindex=0><code>/Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:12
</code></pre><p>和 goroutines 7 和 8 开始的代码行号：</p><pre tabindex=0><code>/Users/gypsydave5/go/src/github.com/gypsydave5/learn-go-with-tests/concurrency/v3/websiteChecker.go:11
</code></pre><p>你需要知道的所有内容都会打印到你的终端上 - 你只需耐心阅读就可以了。</p><h4 id=使用channels处理race-condition>使用channels处理race condition<a hidden class=anchor aria-hidden=true href=#使用channels处理race-condition>#</a></h4><p>我们可以通过使用 <em>channels</em> 协调我们的 goroutines 来解决这个数据竞争。channels 是一个 Go 数据结构，可以同时接收和发送值。这些操作以及细节允许不同进程之间的通信。</p><p>在这种情况下，我们想要考虑父进程和每个 goroutine 之间的通信，goroutine 使用 url 来执行 <code>WebsiteChecker</code> 函数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>concurrency</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WebsiteChecker</span> <span class=kd>func</span><span class=p>(</span><span class=kt>string</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>result</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>CheckWebsites</span><span class=p>(</span><span class=nx>wc</span> <span class=nx>WebsiteChecker</span><span class=p>,</span> <span class=nx>urls</span> <span class=p>[]</span><span class=kt>string</span><span class=p>)</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>results</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>resultChannel</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>url</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>urls</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>u</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>resultChannel</span> <span class=o>&lt;-</span> <span class=nx>result</span><span class=p>{</span><span class=nx>u</span><span class=p>,</span> <span class=nf>wc</span><span class=p>(</span><span class=nx>u</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>urls</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>result</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>resultChannel</span>
</span></span><span class=line><span class=cl>        <span class=nx>results</span><span class=p>[</span><span class=nx>result</span><span class=p>.</span><span class=kt>string</span><span class=p>]</span> <span class=p>=</span> <span class=nx>result</span><span class=p>.</span><span class=kt>bool</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>results</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>除了 <code>results</code> map 之外，我们现在还有一个 <code>resultChannel</code> 的变量，同样使用 <code>make</code> 方法创建。<code>chan result</code> 是 channel 类型的 —— <code>result</code> 的 channel。新类型的 <code>result</code> 是将 <code>WebsiteChecker</code> 的返回值与正在检查的 url 相关联 —— 它是一个 <code>string</code> 和 <code>bool</code> 的结构。因为我们不需要任何一个要命名的值，它们中的每一个在结构中都是匿名的；这在很难知道用什么命名值的时候可能很有用。</p><p>现在，当我们迭代 urls 时，不是直接写入 <code>map</code>，而是使用 <em>send statement</em> 将每个调用 <code>wc</code> 的 <code>result</code> 结构体发送到 <code>resultChannel</code>。这使用 <code>&lt;-</code> 操作符，channel 放在左边，值放在右边：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// send statement</span>
</span></span><span class=line><span class=cl><span class=nx>resultChannel</span> <span class=o>&lt;-</span> <span class=nx>result</span><span class=p>{</span><span class=nx>u</span><span class=p>,</span> <span class=nf>wc</span><span class=p>(</span><span class=nx>u</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>下一个 <code>for</code> 循环为每个 url 迭代一次。 我们在内部使用 <em>receive expression</em>，它将从通道接收到的值分配给变量。这也使用 <code>&lt;-</code> 操作符，但现在两个操作数颠倒过来：现在 channel 在右边，我们指定的变量在左边：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// receive expression</span>
</span></span><span class=line><span class=cl><span class=nx>result</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>resultChannel</span>
</span></span></code></pre></td></tr></table></div></div><p>然后我们使用接收到的 <code>result</code> 更新 map。</p><p>通过将结果发送到通道，我们可以控制每次写入 <code>results</code> map 的时间，确保每次写入一个结果。虽然 <code>wc</code> 的每个调用都发送给结果通道，但是它们在其自己的进程内并行发生，因为我们将结果通道中的值与接收表达式一起逐个处理一个结果。</p><p>我们已经将想要加快速度的那部分代码并行化，同时确保不能并发的部分仍然是线性处理。我们使用 channel 在多个进程间通信。</p><p>当我们运行基准时：</p><pre tabindex=0><code>pkg: github.com/gypsydave5/learn-go-with-tests/concurrency/v2
BenchmarkCheckWebsites-8             100          23406615 ns/op
PASS
ok      github.com/gypsydave5/learn-go-with-tests/concurrency/v2        2.377s
</code></pre><p>23406615 纳秒 —— 0.023 秒，速度大约是最初函数的一百倍，这是非常成功的。</p><h4 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h4><p>某种程度说，我们已经参与了 <code>CheckWebsites</code> 函数的一个长期重构；输入和输出从未改变，它只是变得更快了。但是我们所做的测试以及我们编写的基准测试允许我们重构 <code>CheckWebsites</code>，让我们有信心保证软件仍然可以工作，同时也证明它确实变得更快了。</p><p>在使它更快的过程中，我们明白了</p><ul><li><em>goroutines</em> 是 Go 的基本并发单元，它让我们可以同时检查多个网站。</li><li><em>anonymous functions（匿名函数）</em>，我们用它来启动每个检查网站的并发进程。</li><li><em>channels</em>，用来组织和控制不同进程之间的交流，使我们能够避免 <em>race condition（竞争条件）</em> 的问题。</li><li><em>the race detector（竞争探测器）</em> 帮助我们调试并发代码的问题。</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://pillumina.github.io/posts/programming/links/><span class=title>« Prev</span><br><span>书单记录</span>
</a><a class=next href=https://pillumina.github.io/posts/programming/golang/schedualing/><span class=title>Next »</span><br><span>Golang并发调度</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang TDD on x" href="https://x.com/intent/tweet/?text=Golang%20TDD&amp;url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgo-testing%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang TDD on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgo-testing%2f&amp;title=Golang%20TDD&amp;summary=Golang%20TDD&amp;source=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgo-testing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang TDD on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgo-testing%2f&title=Golang%20TDD"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang TDD on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgo-testing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang TDD on whatsapp" href="https://api.whatsapp.com/send?text=Golang%20TDD%20-%20https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgo-testing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang TDD on telegram" href="https://telegram.me/share/url?text=Golang%20TDD&amp;url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgo-testing%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang TDD on ycombinator" href="https://news.ycombinator.com/submitlink?t=Golang%20TDD&u=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fgolang%2fgo-testing%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://pillumina.github.io/>CctoctoFX</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg></a><div class=reading-progress-bar></div><script src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){const t=document.querySelector(".reading-progress-bar");if(!t)return;const n=document.querySelector(".post-single");if(!n)return;function s(){const e=n.getBoundingClientRect(),s=e.height,o=window.innerHeight,i=window.scrollY||window.pageYOffset,a=i/(s-o)*100;t.style.width=`${Math.min(100,Math.max(0,a))}%`}let e=!1;window.addEventListener("scroll",function(){e||(window.requestAnimationFrame(function(){s(),e=!1}),e=!0)}),s()}),document.addEventListener("DOMContentLoaded",function(){mediumZoom("article img:not(.nozoom)",{margin:24,background:"var(--theme)",scrollOffset:0})})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>