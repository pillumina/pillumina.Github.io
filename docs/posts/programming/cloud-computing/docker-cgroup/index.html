<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker Fundamentals: Cgroup | CctoctoFX</title><meta name=keywords content><meta name=description content="Linux Namespace的技术解决了环境隔离的问题，不过这是虚拟化最基本的一步，我们另外需要解决对计算机资源使用上的隔离。说人话，就是虽然Namespace把我关到一个特定的环境，但是里面进程使用的CPU、内存、磁盘等计算资源实际上没有被限制。这个问题的解决，就要用到CGroup技术。
Linux CGroup全称是Linux Control Group，也是其内核的一个功能，用于限制、控制和分离一个进程group的资源。最早这个项目是2006年由谷歌的工程师发起的，最开始名称是process containers（工程容器），后面觉得内核中容器这个名词被用烂了，就改名为cgroup。
CGroup可以让你对系统中运行的进程的用户组分配资源-CPU时间、系统内存、网络带宽亦或者是这些的组合。同时，也可以监控你配置的cgroup，拒绝cgroup访问某些资源。主要提供的功能如下：


Resource Limitation： 限制资源使用


Prioritization: 优先级控制，例如CPU使用和磁盘IO吞吐


Accounting：审计统计，主要用于计费


Control：挂起进程，恢复执行进程
在真正的实践当中，system admin一般会利用CGroup做以下的事：


对进程集合进行隔离，限制他们所消费的资源，例如绑定CPU core


为这组进程分配足够使用的内存


为这组进程分配响应的网络带宽和磁盘存储限制


限制访问某些设备（白名单）
Linux实际上把CGroup实现成了一个文件系统，你可以mount。在linux环境输入下面的可以看到cgroup已经为你mount好：




 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12


derios@ubuntu:~$ mount -t cgroup
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset)
cgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu)
cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio)
cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio)
cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb)


可以看到，在/sys/fs下有cgroup目录，这个目录下面有各种子目录：cpu，cpuset，memory&mldr;。这些都是cgroup的子系统，分别用来干不同的事。"><meta name=author content="Me"><link rel=canonical href=https://pillumina.github.io/posts/programming/cloud-computing/docker-cgroup/><link crossorigin=anonymous href=/assets/css/stylesheet.9d388901283682bb45dd422fcaa0d0a2054a3c8ff47c9cc6b2baab15508b1b90.css integrity="sha256-nTiJASg2grtF3UIvyqDQogVKPI/0fJzGsrqrFVCLG5A=" rel="preload stylesheet" as=style><link rel=icon href=https://pillumina.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pillumina.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pillumina.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://pillumina.github.io/apple-touch-icon.png><link rel=mask-icon href=https://pillumina.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://pillumina.github.io/posts/programming/cloud-computing/docker-cgroup/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>const config={startOnLoad:!0,theme:"neutral",themeVariables:{lineColor:"#0f0f0f"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(0[0],document.querySelectorAll(".language-mermaid"))}</script><link rel=stylesheet href=/css/custom.min.bda7229c4269a242639e058fb11a4782f02f8d77071ba16609befee67cc41c49.css integrity="sha256-vacinEJpokJjngWPsRpHgvAvjXcHG6FmCb7+5nzEHEk="><script>document.addEventListener("DOMContentLoaded",function(){const t=document.querySelectorAll("h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]"),n=document.querySelectorAll(".toc a");if(t.length===0||n.length===0)return;const s={};t.forEach(e=>{s[e.id]=e.offsetTop});function i(){const t=window.scrollY+100;let e="";for(const[n,o]of Object.entries(s))if(t>=o)e=n;else break;return e}function o(){const e=i();if(n.forEach(e=>{e.classList.remove("active")}),e){const t=document.querySelector(`.toc a[href="#${e}"]`);t&&t.classList.add("active")}}let e=!1;window.addEventListener("scroll",function(){e||(window.requestAnimationFrame(function(){o(),e=!1}),e=!0)}),o()})</script><meta property="og:url" content="https://pillumina.github.io/posts/programming/cloud-computing/docker-cgroup/"><meta property="og:site_name" content="CctoctoFX"><meta property="og:title" content="Docker Fundamentals: Cgroup"><meta property="og:description" content="Linux Namespace的技术解决了环境隔离的问题，不过这是虚拟化最基本的一步，我们另外需要解决对计算机资源使用上的隔离。说人话，就是虽然Namespace把我关到一个特定的环境，但是里面进程使用的CPU、内存、磁盘等计算资源实际上没有被限制。这个问题的解决，就要用到CGroup技术。
Linux CGroup全称是Linux Control Group，也是其内核的一个功能，用于限制、控制和分离一个进程group的资源。最早这个项目是2006年由谷歌的工程师发起的，最开始名称是process containers（工程容器），后面觉得内核中容器这个名词被用烂了，就改名为cgroup。
CGroup可以让你对系统中运行的进程的用户组分配资源-CPU时间、系统内存、网络带宽亦或者是这些的组合。同时，也可以监控你配置的cgroup，拒绝cgroup访问某些资源。主要提供的功能如下：
Resource Limitation： 限制资源使用
Prioritization: 优先级控制，例如CPU使用和磁盘IO吞吐
Accounting：审计统计，主要用于计费
Control：挂起进程，恢复执行进程
在真正的实践当中，system admin一般会利用CGroup做以下的事：
对进程集合进行隔离，限制他们所消费的资源，例如绑定CPU core
为这组进程分配足够使用的内存
为这组进程分配响应的网络带宽和磁盘存储限制
限制访问某些设备（白名单）
Linux实际上把CGroup实现成了一个文件系统，你可以mount。在linux环境输入下面的可以看到cgroup已经为你mount好：
1 2 3 4 5 6 7 8 9 10 11 12 derios@ubuntu:~$ mount -t cgroup cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset) cgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu) cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct) cgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory) cgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices) cgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer) cgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio) cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio) cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls) cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event) cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb) 可以看到，在/sys/fs下有cgroup目录，这个目录下面有各种子目录：cpu，cpuset，memory…。这些都是cgroup的子系统，分别用来干不同的事。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-05T11:22:18+08:00"><meta property="article:modified_time" content="2021-04-05T11:22:18+08:00"><meta property="og:image" content="https://pillumina.github.io/imgs/icon_head.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://pillumina.github.io/imgs/icon_head.png"><meta name=twitter:title content="Docker Fundamentals: Cgroup"><meta name=twitter:description content="Linux Namespace的技术解决了环境隔离的问题，不过这是虚拟化最基本的一步，我们另外需要解决对计算机资源使用上的隔离。说人话，就是虽然Namespace把我关到一个特定的环境，但是里面进程使用的CPU、内存、磁盘等计算资源实际上没有被限制。这个问题的解决，就要用到CGroup技术。
Linux CGroup全称是Linux Control Group，也是其内核的一个功能，用于限制、控制和分离一个进程group的资源。最早这个项目是2006年由谷歌的工程师发起的，最开始名称是process containers（工程容器），后面觉得内核中容器这个名词被用烂了，就改名为cgroup。
CGroup可以让你对系统中运行的进程的用户组分配资源-CPU时间、系统内存、网络带宽亦或者是这些的组合。同时，也可以监控你配置的cgroup，拒绝cgroup访问某些资源。主要提供的功能如下：


Resource Limitation： 限制资源使用


Prioritization: 优先级控制，例如CPU使用和磁盘IO吞吐


Accounting：审计统计，主要用于计费


Control：挂起进程，恢复执行进程
在真正的实践当中，system admin一般会利用CGroup做以下的事：


对进程集合进行隔离，限制他们所消费的资源，例如绑定CPU core


为这组进程分配足够使用的内存


为这组进程分配响应的网络带宽和磁盘存储限制


限制访问某些设备（白名单）
Linux实际上把CGroup实现成了一个文件系统，你可以mount。在linux环境输入下面的可以看到cgroup已经为你mount好：




 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12


derios@ubuntu:~$ mount -t cgroup
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset)
cgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu)
cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio)
cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio)
cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb)


可以看到，在/sys/fs下有cgroup目录，这个目录下面有各种子目录：cpu，cpuset，memory&mldr;。这些都是cgroup的子系统，分别用来干不同的事。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://pillumina.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming","item":"https://pillumina.github.io/posts/programming/"},{"@type":"ListItem","position":3,"name":"Kubernetes \u0026 Docker","item":"https://pillumina.github.io/posts/programming/cloud-computing/"},{"@type":"ListItem","position":4,"name":"Docker Fundamentals: Cgroup","item":"https://pillumina.github.io/posts/programming/cloud-computing/docker-cgroup/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker Fundamentals: Cgroup","name":"Docker Fundamentals: Cgroup","description":"Linux Namespace的技术解决了环境隔离的问题，不过这是虚拟化最基本的一步，我们另外需要解决对计算机资源使用上的隔离。说人话，就是虽然Namespace把我关到一个特定的环境，但是里面进程使用的CPU、内存、磁盘等计算资源实际上没有被限制。这个问题的解决，就要用到CGroup技术。\nLinux CGroup全称是Linux Control Group，也是其内核的一个功能，用于限制、控制和分离一个进程group的资源。最早这个项目是2006年由谷歌的工程师发起的，最开始名称是process containers（工程容器），后面觉得内核中容器这个名词被用烂了，就改名为cgroup。\nCGroup可以让你对系统中运行的进程的用户组分配资源-CPU时间、系统内存、网络带宽亦或者是这些的组合。同时，也可以监控你配置的cgroup，拒绝cgroup访问某些资源。主要提供的功能如下：\nResource Limitation： 限制资源使用\nPrioritization: 优先级控制，例如CPU使用和磁盘IO吞吐\nAccounting：审计统计，主要用于计费\nControl：挂起进程，恢复执行进程\n在真正的实践当中，system admin一般会利用CGroup做以下的事：\n对进程集合进行隔离，限制他们所消费的资源，例如绑定CPU core\n为这组进程分配足够使用的内存\n为这组进程分配响应的网络带宽和磁盘存储限制\n限制访问某些设备（白名单）\nLinux实际上把CGroup实现成了一个文件系统，你可以mount。在linux环境输入下面的可以看到cgroup已经为你mount好：\n1 2 3 4 5 6 7 8 9 10 11 12 derios@ubuntu:~$ mount -t cgroup cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset) cgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu) cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct) cgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory) cgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices) cgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer) cgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio) cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio) cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls) cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event) cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb) 可以看到，在/sys/fs下有cgroup目录，这个目录下面有各种子目录：cpu，cpuset，memory\u0026hellip;。这些都是cgroup的子系统，分别用来干不同的事。\n","keywords":[],"articleBody":"Linux Namespace的技术解决了环境隔离的问题，不过这是虚拟化最基本的一步，我们另外需要解决对计算机资源使用上的隔离。说人话，就是虽然Namespace把我关到一个特定的环境，但是里面进程使用的CPU、内存、磁盘等计算资源实际上没有被限制。这个问题的解决，就要用到CGroup技术。\nLinux CGroup全称是Linux Control Group，也是其内核的一个功能，用于限制、控制和分离一个进程group的资源。最早这个项目是2006年由谷歌的工程师发起的，最开始名称是process containers（工程容器），后面觉得内核中容器这个名词被用烂了，就改名为cgroup。\nCGroup可以让你对系统中运行的进程的用户组分配资源-CPU时间、系统内存、网络带宽亦或者是这些的组合。同时，也可以监控你配置的cgroup，拒绝cgroup访问某些资源。主要提供的功能如下：\nResource Limitation： 限制资源使用\nPrioritization: 优先级控制，例如CPU使用和磁盘IO吞吐\nAccounting：审计统计，主要用于计费\nControl：挂起进程，恢复执行进程\n在真正的实践当中，system admin一般会利用CGroup做以下的事：\n对进程集合进行隔离，限制他们所消费的资源，例如绑定CPU core\n为这组进程分配足够使用的内存\n为这组进程分配响应的网络带宽和磁盘存储限制\n限制访问某些设备（白名单）\nLinux实际上把CGroup实现成了一个文件系统，你可以mount。在linux环境输入下面的可以看到cgroup已经为你mount好：\n1 2 3 4 5 6 7 8 9 10 11 12 derios@ubuntu:~$ mount -t cgroup cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset) cgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu) cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct) cgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory) cgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices) cgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer) cgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio) cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio) cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls) cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event) cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb) 可以看到，在/sys/fs下有cgroup目录，这个目录下面有各种子目录：cpu，cpuset，memory…。这些都是cgroup的子系统，分别用来干不同的事。\n如果没有看到上面的目录，你可以自己mount:\n1 2 3 4 5 6 7 8 mkdir cgroup mount -t tmpfs cgroup_root ./cgroup mkdir cgroup/cpuset mount -t cgroup -ocpuset cpuset ./cgroup/cpuset/ mkdir cgroup/cpu mount -t cgroup -ocpu cpu ./cgroup/cpu/ mkdir cgroup/memory mount -t cgroup -omemory memory ./cgroup/memory/ mount成功以后，你会看见这些目录下有文件，比如下面展现的cpu和cpuset子系统:\n1 2 3 4 5 6 7 8 9 10 11 12 13 derios@ubuntu:~$ ls /sys/fs/cgroup/cpu /sys/fs/cgroup/cpuset/ /sys/fs/cgroup/cpu: cgroup.clone_children cgroup.sane_behavior cpu.shares release_agent cgroup.event_control cpu.cfs_period_us cpu.stat tasks cgroup.procs cpu.cfs_quota_us notify_on_release user /sys/fs/cgroup/cpuset/: cgroup.clone_children cpuset.mem_hardwall cpuset.sched_load_balance cgroup.event_control cpuset.memory_migrate cpuset.sched_relax_domain_level cgroup.procs cpuset.memory_pressure notify_on_release cgroup.sane_behavior cpuset.memory_pressure_enabled release_agent cpuset.cpu_exclusive cpuset.memory_spread_page tasks cpuset.cpus cpuset.memory_spread_slab user cpuset.mem_exclusive cpuset.mems 你可以进入/sys/fs/cgroup的各个目录下去创建个dir，你会发现一旦你创建了，这个子目录下又有很多文件：\n1 2 3 4 5 derios@ubuntu:/sys/fs/cgroup/cpu$ sudo mkdir haoel [sudo] password for derios: derios@ubuntu:/sys/fs/cgroup/cpu$ ls ./haoel cgroup.clone_children cgroup.procs cpu.cfs_quota_us cpu.stat tasks cgroup.event_control cpu.cfs_period_us cpu.shares notify_on_release CPU限制 假设我们写了个吃CPU的程序：\n1 2 3 4 5 6 int main(void) { int i = 0; for(;;) i++; return 0; } 用sudo执行毫无疑问cpu飚到100%：\n1 2 PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 3529 root 20 0 4196 736 656 R 99.6 0.1 0:23.13 deadloop 在上面我们在/sys/fs/cgroup/cpu下面创建了haoel的group，我们首先设置下cpu限制\n1 2 3 derios@ubuntu:~# cat /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us -1 root@ubuntu:~# echo 20000 \u003e /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us 我们top出来看到这个线程的pid是3529，我们加到这个cgroup中:\n1 # echo 3529 \u003e\u003e /sys/fs/cgroup/cpu/haoel/tasks 然后再看top，可以发现CPU使用率一下降成了20%（设置的20000代表着20%）：\n1 2 PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 3529 root 20 0 4196 736 656 R 19.9 0.1 8:06.11 deadloop 下面贴一个我google的代码示例，用于参考看看注释:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #define _GNU_SOURCE /* See feature_test_macros(7) */ #include #include #include #include #include #include #include const int NUM_THREADS = 5; void *thread_main(void *threadid) { /* 把自己加入cgroup中（syscall(SYS_gettid)为得到线程的系统tid） */ char cmd[128]; sprintf(cmd, \"echo %ld \u003e\u003e /sys/fs/cgroup/cpu/haoel/tasks\", syscall(SYS_gettid)); system(cmd); sprintf(cmd, \"echo %ld \u003e\u003e /sys/fs/cgroup/cpuset/haoel/tasks\", syscall(SYS_gettid)); system(cmd); long tid; tid = (long)threadid; printf(\"Hello World! It's me, thread #%ld, pid #%ld!\\n\", tid, syscall(SYS_gettid)); int a=0; while(1) { a++; } pthread_exit(NULL); } int main (int argc, char *argv[]) { int num_threads; if (argc \u003e 1){ num_threads = atoi(argv[1]); } if (num_threads\u003c=0 || num_threads\u003e=100){ num_threads = NUM_THREADS; } /* 设置CPU利用率为50% */ mkdir(\"/sys/fs/cgroup/cpu/haoel\", 755); system(\"echo 50000 \u003e /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us\"); mkdir(\"/sys/fs/cgroup/cpuset/haoel\", 755); /* 限制CPU只能使用#2核和#3核 */ system(\"echo \\\"2,3\\\" \u003e /sys/fs/cgroup/cpuset/haoel/cpuset.cpus\"); pthread_t* threads = (pthread_t*) malloc (sizeof(pthread_t)*num_threads); int rc; long t; for(t=0; t\u003cnum_threads; t++){ printf(\"In main: creating thread %ld\\n\", t); rc = pthread_create(\u0026threads[t], NULL, thread_main, (void *)t); if (rc){ printf(\"ERROR; return code from pthread_create() is %d\\n\", rc); exit(-1); } } /* Last thing that main() should do */ pthread_exit(NULL); free(threads); } 内存使用限制 我们构造一下无限分配内存的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include #include #include #include #include int main(void) { int size = 0; int chunk_size = 512; void *p = NULL; while(1) { if ((p = malloc(p, chunk_size)) == NULL) { printf(\"out of memory!!\\n\"); break; } memset(p, 1, chunk_size); size += chunk_size; printf(\"[%d] - memory is allocated [%8d] bytes \\n\", getpid(), size); sleep(1); } return 0; } 这个代码是个dead loop，每隔1秒会分配512字节的内存。然后我们再cgroup搞事情：\n1 2 3 4 5 6 # 创建memory cgroup $ mkdir /sys/fs/cgroup/memory/haoel $ echo 64k \u003e /sys/fs/cgroup/memory/haoel/memory.limit_in_bytes # 把上面的进程的pid加入这个cgroup $ echo [pid] \u003e /sys/fs/cgroup/memory/haoel/tasks 可以看到上面的进程会因为内存oom被kill。\n磁盘IO限制 我们先查看下磁盘IO，模拟一下（从/dev/sda1读取数据，输出到/dev/null上）：\n1 sudo dd if=/dev/sda1 of=/dev/null 通过iotop命令可以看到相关的io速度为55MB/s：\n1 2 TID PRIO USER DISK READ DISK WRITE SWAPIN IO\u003e COMMAND 8128 be/4 root 55.74 M/s 0.00 B/s 0.00 % 85.65 % dd if=/de~=/dev/null... 然后，我们先创建一个blkio（块设备IO）的cgroup:\n1 mkdir /sys/fs/cgroup/blkio/haoel 并把读IO限制到1MB/s，并把前面那个dd命令的pid放进去（注：8:0 是设备号，你可以通过ls -l /dev/sda1获得）：\n1 2 root@ubuntu:~# echo '8:0 1048576' \u003e /sys/fs/cgroup/blkio/haoel/blkio.throttle.read_bps_device root@ubuntu:~# echo 8128 \u003e /sys/fs/cgroup/blkio/haoel/tasks 再用iotop命令，你马上就能看到读速度被限制到了1MB/s左右:\n1 2 TID PRIO USER DISK READ DISK WRITE SWAPIN IO\u003e COMMAND 8128 be/4 root 973.20 K/s 0.00 B/s 0.00 % 94.41 % dd if=/de~=/dev/null... CGroup的子系统 OK，有了以上比较感性的认识，我们来看看control group到底有哪些子系统：\nblkio — 这个子系统为块设备设定输入/输出限制，比如物理设备（磁盘，固态硬盘，USB 等等）。\ncpu — 这个子系统使用调度程序提供对 CPU 的 cgroup 任务访问。\ncpuacct — 这个子系统自动生成 cgroup 中任务所使用的 CPU 报告。\ncpuset — 这个子系统为 cgroup 中的任务分配独立 CPU（在多核系统）和内存节点。\ndevices — 这个子系统可允许或者拒绝 cgroup 中的任务访问设备。\nfreezer — 这个子系统挂起或者恢复 cgroup 中的任务。\nmemory — 这个子系统设定 cgroup 中任务使用的内存限制，并自动生成内存资源使用报告。\nnet_cls — 这个子系统使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制程序（tc）识别从具体 cgroup 中生成的数据包。\nnet_prio — 这个子系统用来设计网络流量的优先级\nhugetlb — 这个子系统主要针对于HugeTLB系统进行限制，这是一个大页文件系统。\n在我的Ubuntu14.04虚拟机下看不到net_cls和net_prio这两个cgroup，需要手动mount：\n1 2 3 4 5 6 7 $ sudo modprobe cls_cgroup $ sudo mkdir /sys/fs/cgroup/net_cls $ sudo mount -t cgroup -o net_cls none /sys/fs/cgroup/net_cls $ sudo modprobe netprio_cgroup $ sudo mkdir /sys/fs/cgroup/net_prio $ sudo mount -t cgroup -o net_prio none /sys/fs/cgroup/net_prio CGroup术语 CGroup有下述术语：\n任务（Tasks）：就是系统的一个进程。 控制组（Control Group）：一组按照某种标准划分的进程，比如官方文档中的Professor和Student，或是WWW和System之类的，其表示了某进程组。Cgroups中的资源控制都是以控制组为单位实现。一个进程可以加入到某个控制组。而资源的限制是定义在这个组上，就像上面示例中我用的haoel一样。简单点说，cgroup的呈现就是一个目录带一系列的可配置文件。 层级（Hierarchy）：控制组可以组织成hierarchical的形式，既一颗控制组的树（目录结构）。控制组树上的子节点继承父结点的属性。简单点说，hierarchy就是在一个或多个子系统上的cgroups目录树。 子系统（Subsystem）：一个子系统就是一个资源控制器，比如CPU子系统就是控制CPU时间分配的一个控制器。子系统必须附加到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。Cgroup的子系统可以有很多，也在不断增加中。 ","wordCount":"848","inLanguage":"en","image":"https://pillumina.github.io/imgs/icon_head.png","datePublished":"2021-04-05T11:22:18+08:00","dateModified":"2021-04-05T11:22:18+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://pillumina.github.io/posts/programming/cloud-computing/docker-cgroup/"},"publisher":{"@type":"Organization","name":"CctoctoFX","logo":{"@type":"ImageObject","url":"https://pillumina.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pillumina.github.io/ accesskey=h title="CctoctoFX (Alt + H)"><img src=https://pillumina.github.io/apple-touch-icon.png alt aria-label=logo height=30>CctoctoFX</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pillumina.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://pillumina.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://pillumina.github.io/posts/aiinfra title="AI Infra"><span>AI Infra</span></a></li><li><a href=https://pillumina.github.io/posts/programming title=Programming><span>Programming</span></a></li><li><a href=https://pillumina.github.io/social title=Social><span>Social</span></a></li><li><a href=https://pillumina.github.io/open_courses title=Study><span>Study</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://pillumina.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://pillumina.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://pillumina.github.io/posts/programming/>Programming</a>&nbsp;»&nbsp;<a href=https://pillumina.github.io/posts/programming/cloud-computing/>Kubernetes & Docker</a></div><h1 class="post-title entry-hint-parent">Docker Fundamentals: Cgroup</h1><div class=post-meta><span title='2021-04-05 11:22:18 +0800 CST'>April 5, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;848 words&nbsp;·&nbsp;Me</div></header><div class="toc side left"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#cpu限制>CPU限制</a></li><li><a href=#内存使用限制>内存使用限制</a></li><li><a href=#磁盘io限制>磁盘IO限制</a></li><li><a href=#cgroup的子系统>CGroup的子系统</a></li><li><a href=#cgroup术语>CGroup术语</a></li></ul></nav></div></details></div><div class=post-content><p>Linux Namespace的技术解决了环境隔离的问题，不过这是虚拟化最基本的一步，我们另外需要解决<strong>对计算机资源使用上的隔离</strong>。说人话，就是虽然Namespace把我关到一个特定的环境，但是里面进程使用的CPU、内存、磁盘等计算资源实际上没有被限制。这个问题的解决，就要用到CGroup技术。</p><p>Linux CGroup全称是Linux Control Group，也是其内核的一个功能，用于限制、控制和分离一个进程group的资源。最早这个项目是2006年由谷歌的工程师发起的，最开始名称是process containers（工程容器），后面觉得内核中容器这个名词被用烂了，就改名为cgroup。</p><p>CGroup可以让你对系统中运行的进程的用户组分配资源-CPU时间、系统内存、网络带宽亦或者是这些的组合。同时，也可以监控你配置的cgroup，拒绝cgroup访问某些资源。主要提供的功能如下：</p><ul><li><p><code>Resource Limitation</code>： 限制资源使用</p></li><li><p><code>Prioritization</code>: 优先级控制，例如CPU使用和磁盘IO吞吐</p></li><li><p><code>Accounting</code>：审计统计，主要用于计费</p></li><li><p><code>Control</code>：挂起进程，恢复执行进程</p><p>在真正的实践当中，system admin一般会利用CGroup做以下的事：</p></li><li><p>对进程集合进行隔离，限制他们所消费的资源，例如绑定CPU core</p></li><li><p>为这组进程分配足够使用的内存</p></li><li><p>为这组进程分配响应的网络带宽和磁盘存储限制</p></li><li><p>限制访问某些设备（白名单）</p><p>Linux实际上把CGroup实现成了一个文件系统，你可以mount。在linux环境输入下面的可以看到cgroup已经为你mount好：</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~$ mount -t cgroup
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/cpuset <span class=nb>type</span> cgroup <span class=o>(</span>rw,relatime,cpuset<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/cpu <span class=nb>type</span> cgroup <span class=o>(</span>rw,relatime,cpu<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/cpuacct <span class=nb>type</span> cgroup <span class=o>(</span>rw,relatime,cpuacct<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/memory <span class=nb>type</span> cgroup <span class=o>(</span>rw,relatime,memory<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/devices <span class=nb>type</span> cgroup <span class=o>(</span>rw,relatime,devices<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/freezer <span class=nb>type</span> cgroup <span class=o>(</span>rw,relatime,freezer<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/blkio <span class=nb>type</span> cgroup <span class=o>(</span>rw,relatime,blkio<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/net_prio <span class=nb>type</span> cgroup <span class=o>(</span>rw,net_prio<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/net_cls <span class=nb>type</span> cgroup <span class=o>(</span>rw,net_cls<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/perf_event <span class=nb>type</span> cgroup <span class=o>(</span>rw,relatime,perf_event<span class=o>)</span>
</span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup/hugetlb <span class=nb>type</span> cgroup <span class=o>(</span>rw,relatime,hugetlb<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到，在<code>/sys/fs</code>下有<code>cgroup</code>目录，这个目录下面有各种子目录：<code>cpu</code>，<code>cpuset</code>，<code>memory</code>&mldr;。这些都是cgroup的子系统，分别用来干不同的事。</p><p>如果没有看到上面的目录，你可以自己mount:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>mkdir cgroup
</span></span><span class=line><span class=cl>mount -t tmpfs cgroup_root ./cgroup
</span></span><span class=line><span class=cl>mkdir cgroup/cpuset
</span></span><span class=line><span class=cl>mount -t cgroup -ocpuset cpuset ./cgroup/cpuset/
</span></span><span class=line><span class=cl>mkdir cgroup/cpu
</span></span><span class=line><span class=cl>mount -t cgroup -ocpu cpu ./cgroup/cpu/
</span></span><span class=line><span class=cl>mkdir cgroup/memory
</span></span><span class=line><span class=cl>mount -t cgroup -omemory memory ./cgroup/memory/
</span></span></code></pre></td></tr></table></div></div><p>mount成功以后，你会看见这些目录下有文件，比如下面展现的cpu和cpuset子系统:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~$ ls /sys/fs/cgroup/cpu /sys/fs/cgroup/cpuset/ 
</span></span><span class=line><span class=cl>/sys/fs/cgroup/cpu:
</span></span><span class=line><span class=cl>cgroup.clone_children  cgroup.sane_behavior  cpu.shares         release_agent
</span></span><span class=line><span class=cl>cgroup.event_control   cpu.cfs_period_us     cpu.stat           tasks
</span></span><span class=line><span class=cl>cgroup.procs           cpu.cfs_quota_us      notify_on_release  user
</span></span><span class=line><span class=cl>/sys/fs/cgroup/cpuset/:
</span></span><span class=line><span class=cl>cgroup.clone_children  cpuset.mem_hardwall             cpuset.sched_load_balance
</span></span><span class=line><span class=cl>cgroup.event_control   cpuset.memory_migrate           cpuset.sched_relax_domain_level
</span></span><span class=line><span class=cl>cgroup.procs           cpuset.memory_pressure          notify_on_release
</span></span><span class=line><span class=cl>cgroup.sane_behavior   cpuset.memory_pressure_enabled  release_agent
</span></span><span class=line><span class=cl>cpuset.cpu_exclusive   cpuset.memory_spread_page       tasks
</span></span><span class=line><span class=cl>cpuset.cpus            cpuset.memory_spread_slab       user
</span></span><span class=line><span class=cl>cpuset.mem_exclusive   cpuset.mems
</span></span></code></pre></td></tr></table></div></div><p>你可以进入<code>/sys/fs/cgroup</code>的各个目录下去创建个dir，你会发现一旦你创建了，这个子目录下又有很多文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:/sys/fs/cgroup/cpu$ sudo mkdir haoel
</span></span><span class=line><span class=cl><span class=o>[</span>sudo<span class=o>]</span> password <span class=k>for</span> derios: 
</span></span><span class=line><span class=cl>derios@ubuntu:/sys/fs/cgroup/cpu$ ls ./haoel
</span></span><span class=line><span class=cl>cgroup.clone_children  cgroup.procs       cpu.cfs_quota_us  cpu.stat           tasks
</span></span><span class=line><span class=cl>cgroup.event_control   cpu.cfs_period_us  cpu.shares        notify_on_release
</span></span></code></pre></td></tr></table></div></div><h2 id=cpu限制>CPU限制<a hidden class=anchor aria-hidden=true href=#cpu限制>#</a></h2><p>假设我们写了个吃CPU的程序：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(;;)</span> <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>用sudo执行毫无疑问cpu飚到100%：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     
</span></span><span class=line><span class=cl> <span class=m>3529</span> root      <span class=m>20</span>   <span class=m>0</span>    <span class=m>4196</span>    <span class=m>736</span>    <span class=m>656</span> R 99.6  0.1   0:23.13 deadloop   
</span></span></code></pre></td></tr></table></div></div><p>在上面我们在<code>/sys/fs/cgroup/cpu</code>下面创建了<code>haoel</code>的group，我们首先设置下cpu限制</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~# cat /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us 
</span></span><span class=line><span class=cl>-1
</span></span><span class=line><span class=cl>root@ubuntu:~# <span class=nb>echo</span> <span class=m>20000</span> &gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us
</span></span></code></pre></td></tr></table></div></div><p>我们top出来看到这个线程的pid是3529，我们加到这个cgroup中:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># echo 3529 &gt;&gt; /sys/fs/cgroup/cpu/haoel/tasks</span>
</span></span></code></pre></td></tr></table></div></div><p>然后再看top，可以发现CPU使用率一下降成了20%（设置的20000代表着20%）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     
</span></span><span class=line><span class=cl> <span class=m>3529</span> root      <span class=m>20</span>   <span class=m>0</span>    <span class=m>4196</span>    <span class=m>736</span>    <span class=m>656</span> R 19.9  0.1   8:06.11 deadloop    
</span></span></code></pre></td></tr></table></div></div><p>下面贴一个我google的代码示例，用于参考看看注释:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#define _GNU_SOURCE         </span><span class=cm>/* See feature_test_macros(7) */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/syscall.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>NUM_THREADS</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thread_main</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>threadid</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 把自己加入cgroup中（syscall(SYS_gettid)为得到线程的系统tid） */</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>cmd</span><span class=p>[</span><span class=mi>128</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>sprintf</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=s>&#34;echo %ld &gt;&gt; /sys/fs/cgroup/cpu/haoel/tasks&#34;</span><span class=p>,</span> <span class=n>syscall</span><span class=p>(</span><span class=n>SYS_gettid</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=n>cmd</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=n>sprintf</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=s>&#34;echo %ld &gt;&gt; /sys/fs/cgroup/cpuset/haoel/tasks&#34;</span><span class=p>,</span> <span class=n>syscall</span><span class=p>(</span><span class=n>SYS_gettid</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=n>cmd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>tid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tid</span> <span class=o>=</span> <span class=p>(</span><span class=kt>long</span><span class=p>)</span><span class=n>threadid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Hello World! It&#39;s me, thread #%ld, pid #%ld!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>tid</span><span class=p>,</span> <span class=n>syscall</span><span class=p>(</span><span class=n>SYS_gettid</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_exit</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>num_threads</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>num_threads</span> <span class=o>=</span> <span class=n>atoi</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>num_threads</span><span class=o>&lt;=</span><span class=mi>0</span> <span class=o>||</span> <span class=n>num_threads</span><span class=o>&gt;=</span><span class=mi>100</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>num_threads</span> <span class=o>=</span> <span class=n>NUM_THREADS</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 设置CPU利用率为50% */</span>
</span></span><span class=line><span class=cl>    <span class=n>mkdir</span><span class=p>(</span><span class=s>&#34;/sys/fs/cgroup/cpu/haoel&#34;</span><span class=p>,</span> <span class=mi>755</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;echo 50000 &gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>mkdir</span><span class=p>(</span><span class=s>&#34;/sys/fs/cgroup/cpuset/haoel&#34;</span><span class=p>,</span> <span class=mi>755</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 限制CPU只能使用#2核和#3核 */</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;echo </span><span class=se>\&#34;</span><span class=s>2,3</span><span class=se>\&#34;</span><span class=s> &gt; /sys/fs/cgroup/cpuset/haoel/cpuset.cpus&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pthread_t</span><span class=o>*</span> <span class=n>threads</span> <span class=o>=</span> <span class=p>(</span><span class=n>pthread_t</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span> <span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>pthread_t</span><span class=p>)</span><span class=o>*</span><span class=n>num_threads</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>t</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>t</span><span class=o>&lt;</span><span class=n>num_threads</span><span class=p>;</span> <span class=n>t</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;In main: creating thread %ld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>rc</span> <span class=o>=</span> <span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>threads</span><span class=p>[</span><span class=n>t</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>thread_main</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>rc</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;ERROR; return code from pthread_create() is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>rc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Last thing that main() should do */</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_exit</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>threads</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=内存使用限制>内存使用限制<a hidden class=anchor aria-hidden=true href=#内存使用限制>#</a></h2><p>我们构造一下无限分配内存的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>chunk_size</span> <span class=o>=</span> <span class=mi>512</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=n>p</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>chunk_size</span><span class=p>))</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;out of memory!!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>memset</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>chunk_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>size</span> <span class=o>+=</span> <span class=n>chunk_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;[%d] - memory is allocated [%8d] bytes </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>(),</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这个代码是个dead loop，每隔1秒会分配512字节的内存。然后我们再cgroup搞事情：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 创建memory cgroup</span>
</span></span><span class=line><span class=cl>$ mkdir /sys/fs/cgroup/memory/haoel
</span></span><span class=line><span class=cl>$ <span class=nb>echo</span> 64k &gt; /sys/fs/cgroup/memory/haoel/memory.limit_in_bytes
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 把上面的进程的pid加入这个cgroup</span>
</span></span><span class=line><span class=cl>$ <span class=nb>echo</span> <span class=o>[</span>pid<span class=o>]</span> &gt; /sys/fs/cgroup/memory/haoel/tasks 
</span></span></code></pre></td></tr></table></div></div><p>可以看到上面的进程会因为内存oom被kill。</p><h2 id=磁盘io限制>磁盘IO限制<a hidden class=anchor aria-hidden=true href=#磁盘io限制>#</a></h2><p>我们先查看下磁盘IO，模拟一下（从/dev/sda1读取数据，输出到/dev/null上）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>sudo dd <span class=k>if</span><span class=o>=</span>/dev/sda1 <span class=nv>of</span><span class=o>=</span>/dev/null
</span></span></code></pre></td></tr></table></div></div><p>通过<code>iotop</code>命令可以看到相关的io速度为55MB/s：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND          
</span></span><span class=line><span class=cl> <span class=m>8128</span> be/4 root       55.74 M/s    0.00 B/s  0.00 % 85.65 % dd <span class=k>if</span><span class=o>=</span>/de~<span class=o>=</span>/dev/null...
</span></span></code></pre></td></tr></table></div></div><p>然后，我们先创建一个blkio（块设备IO）的cgroup:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>mkdir /sys/fs/cgroup/blkio/haoel
</span></span></code></pre></td></tr></table></div></div><p>并把读IO限制到1MB/s，并把前面那个dd命令的pid放进去（注：8:0 是设备号，你可以通过ls -l /dev/sda1获得）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>root@ubuntu:~# <span class=nb>echo</span> <span class=s1>&#39;8:0 1048576&#39;</span>  &gt; /sys/fs/cgroup/blkio/haoel/blkio.throttle.read_bps_device 
</span></span><span class=line><span class=cl>root@ubuntu:~# <span class=nb>echo</span> <span class=m>8128</span> &gt; /sys/fs/cgroup/blkio/haoel/tasks
</span></span></code></pre></td></tr></table></div></div><p>再用iotop命令，你马上就能看到读速度被限制到了1MB/s左右:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND          
</span></span><span class=line><span class=cl> <span class=m>8128</span> be/4 root      973.20 K/s    0.00 B/s  0.00 % 94.41 % dd <span class=k>if</span><span class=o>=</span>/de~<span class=o>=</span>/dev/null...
</span></span></code></pre></td></tr></table></div></div><h2 id=cgroup的子系统>CGroup的子系统<a hidden class=anchor aria-hidden=true href=#cgroup的子系统>#</a></h2><p>OK，有了以上比较感性的认识，我们来看看control group到底有哪些子系统：</p><ul><li><p>blkio — 这个子系统为块设备设定输入/输出限制，比如物理设备（磁盘，固态硬盘，USB 等等）。</p></li><li><p>cpu — 这个子系统使用调度程序提供对 CPU 的 cgroup 任务访问。</p></li><li><p>cpuacct — 这个子系统自动生成 cgroup 中任务所使用的 CPU 报告。</p></li><li><p>cpuset — 这个子系统为 cgroup 中的任务分配独立 CPU（在多核系统）和内存节点。</p></li><li><p>devices — 这个子系统可允许或者拒绝 cgroup 中的任务访问设备。</p></li><li><p>freezer — 这个子系统挂起或者恢复 cgroup 中的任务。</p></li><li><p>memory — 这个子系统设定 cgroup 中任务使用的内存限制，并自动生成内存资源使用报告。</p></li><li><p>net_cls — 这个子系统使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制程序（tc）识别从具体 cgroup 中生成的数据包。</p></li><li><p>net_prio — 这个子系统用来设计网络流量的优先级</p></li><li><p>hugetlb — 这个子系统主要针对于HugeTLB系统进行限制，这是一个大页文件系统。</p><p>在我的Ubuntu14.04虚拟机下看不到net_cls和net_prio这两个cgroup，需要手动mount：</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo modprobe cls_cgroup
</span></span><span class=line><span class=cl>$ sudo mkdir /sys/fs/cgroup/net_cls
</span></span><span class=line><span class=cl>$ sudo mount -t cgroup -o net_cls none /sys/fs/cgroup/net_cls
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ sudo modprobe netprio_cgroup
</span></span><span class=line><span class=cl>$ sudo mkdir /sys/fs/cgroup/net_prio
</span></span><span class=line><span class=cl>$ sudo mount -t cgroup -o net_prio none /sys/fs/cgroup/net_prio
</span></span></code></pre></td></tr></table></div></div><h2 id=cgroup术语>CGroup术语<a hidden class=anchor aria-hidden=true href=#cgroup术语>#</a></h2><p>CGroup有下述术语：</p><ul><li><strong>任务（Tasks）</strong>：就是系统的一个进程。</li><li><strong>控制组（Control Group）</strong>：一组按照某种标准划分的进程，比如官方文档中的Professor和Student，或是WWW和System之类的，其表示了某进程组。Cgroups中的资源控制都是以控制组为单位实现。一个进程可以加入到某个控制组。而资源的限制是定义在这个组上，就像上面示例中我用的haoel一样。简单点说，cgroup的呈现就是一个目录带一系列的可配置文件。</li><li><strong>层级（Hierarchy）</strong>：控制组可以组织成hierarchical的形式，既一颗控制组的树（目录结构）。控制组树上的子节点继承父结点的属性。简单点说，hierarchy就是在一个或多个子系统上的cgroups目录树。</li><li><strong>子系统（Subsystem）</strong>：一个子系统就是一个资源控制器，比如CPU子系统就是控制CPU时间分配的一个控制器。子系统必须附加到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。Cgroup的子系统可以有很多，也在不断增加中。</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://pillumina.github.io/posts/programming/programmer-career/><span class=title>« Prev</span><br><span>(转)程序员如何把控自己的职业</span>
</a><a class=next href=https://pillumina.github.io/posts/programming/cloud-computing/docker-namespace/><span class=title>Next »</span><br><span>Docker Fundamentals: Namespace</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Fundamentals: Cgroup on x" href="https://x.com/intent/tweet/?text=Docker%20Fundamentals%3a%20Cgroup&amp;url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-cgroup%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Fundamentals: Cgroup on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-cgroup%2f&amp;title=Docker%20Fundamentals%3a%20Cgroup&amp;summary=Docker%20Fundamentals%3a%20Cgroup&amp;source=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-cgroup%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Fundamentals: Cgroup on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-cgroup%2f&title=Docker%20Fundamentals%3a%20Cgroup"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Fundamentals: Cgroup on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-cgroup%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Fundamentals: Cgroup on whatsapp" href="https://api.whatsapp.com/send?text=Docker%20Fundamentals%3a%20Cgroup%20-%20https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-cgroup%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Fundamentals: Cgroup on telegram" href="https://telegram.me/share/url?text=Docker%20Fundamentals%3a%20Cgroup&amp;url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-cgroup%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Fundamentals: Cgroup on ycombinator" href="https://news.ycombinator.com/submitlink?t=Docker%20Fundamentals%3a%20Cgroup&u=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-cgroup%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://pillumina.github.io/>CctoctoFX</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg></a><div class=reading-progress-bar></div><script src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){const t=document.querySelector(".reading-progress-bar");if(!t)return;const n=document.querySelector(".post-single");if(!n)return;function s(){const e=n.getBoundingClientRect(),s=e.height,o=window.innerHeight,i=window.scrollY||window.pageYOffset,a=i/(s-o)*100;t.style.width=`${Math.min(100,Math.max(0,a))}%`}let e=!1;window.addEventListener("scroll",function(){e||(window.requestAnimationFrame(function(){s(),e=!1}),e=!0)}),s()}),document.addEventListener("DOMContentLoaded",function(){mediumZoom("article img:not(.nozoom)",{margin:24,background:"var(--theme)",scrollOffset:0})})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>