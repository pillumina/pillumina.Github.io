<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker Fundamentals: Namespace | CctoctoFX</title><meta name=keywords content><meta name=description content="容器技术出现已经很久，只不过Docker容器平台的出现它变火了。Docker是第一个让容器能在不同机器之间移植的系统，它简化了打包应用的流程，也简化了打包应用的库和各种依赖。思考下整个OS的file system能直接被打包成一个简单的可移植的包，一开始的时候概念上还是很有趣的。
有时候我认为自己的阅读比较碎片化(short-term memory越来越少)，所以我想把之前学习容器知识的一些基础技术再整理出来，也算是给自己学习的反馈。这个基础系列从Linux Namespace开始，后续会陆续介绍比如cgroup、aufs、devicemapper等技术。
参考
Namespace in operation
Linux namespace man page
Introduction to linux namespace
什么是Namespace
简单来说，linux namespace是Linux提供的一种内核级别环境隔离的方法。在早期的Unix中，提供了一种叫做chroot的系统调用：通过修改root目录把用户关到一个特定的目录下面。这种就是简单的隔离方式，也就是chroot内部的file system无法访问外部的内容。Linux Namespace在此基础之上，提供了对UTS、IPC、mount、network、PID、User等隔离机制。
这里可以简单举例，比如Linux的超级父进程的PID为1，如果我们可以把用户的进程空间关到某个进程分支之下，并且像chroot那样能够让下面的进程看到那个超级父进程的PID为1，而不同PID Namespace中的进程无法看到彼此，这样就能达到进程隔离。
Linux Namespace有以下的种类，供给后续参考（刚看有个印象就行）：

  
      
          分类
          系统调用参数
          相关内核版本
      
  
  
      
          Mount namespaces
          CLONE_NEWNS
          Linux 2.4.19
      
      
          UTS namespaces
          CLONE_NEWUTS
          Linux 2.6.19
      
      
          IPC namespaces
          CLONE_NEWIPC
          Linux 2.6.19
      
      
          PID namespaces
          CLONE_NEWPID
          Linux 2.6.24
      
      
          Network namespaces
          CLONE_NEWNET
          始于Linux 2.6.24 完成于 Linux 2.6.29
      
      
          User namespaces
          CLONE_NEWUSER
          始于 Linux 2.6.23 完成于 Linux 3.8)
      
  

其主要涉及到三个系统调用：

clone()： 实现线程的系统调用，用来创建新的线程，并可通过涉及上述参数做到隔离
unshare()： 让某一个线程脱离某namespace
setns(): 把某一个线程加到某namespace

如果读者你想看具体的实例，请自己man一下(关注一下自己的linux虚拟机内核)，或者google一下，我这里贴一个clone()的source code："><meta name=author content="Me"><link rel=canonical href=https://pillumina.github.io/posts/programming/cloud-computing/docker-namespace/><link crossorigin=anonymous href=/assets/css/stylesheet.9d388901283682bb45dd422fcaa0d0a2054a3c8ff47c9cc6b2baab15508b1b90.css integrity="sha256-nTiJASg2grtF3UIvyqDQogVKPI/0fJzGsrqrFVCLG5A=" rel="preload stylesheet" as=style><link rel=icon href=https://pillumina.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pillumina.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pillumina.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://pillumina.github.io/apple-touch-icon.png><link rel=mask-icon href=https://pillumina.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://pillumina.github.io/posts/programming/cloud-computing/docker-namespace/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>const config={startOnLoad:!0,theme:"neutral",themeVariables:{lineColor:"#0f0f0f"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(0[0],document.querySelectorAll(".language-mermaid"))}</script><link rel=stylesheet href=/css/custom.min.7ca191baf9a98cba901e2771d1f5485af2e39a950ce60a50254e72e853eb373d.css integrity="sha256-fKGRuvmpjLqQHidx0fVIWvLjmpUM5gpQJU5y6FPrNz0="><script>document.addEventListener("DOMContentLoaded",function(){const t=document.querySelectorAll("h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]"),n=document.querySelectorAll(".toc a");if(t.length===0||n.length===0)return;const s={};t.forEach(e=>{s[e.id]=e.offsetTop});function i(){const t=window.scrollY+100;let e="";for(const[n,o]of Object.entries(s))if(t>=o)e=n;else break;return e}function o(){const e=i();if(n.forEach(e=>{e.classList.remove("active")}),e){const t=document.querySelector(`.toc a[href="#${e}"]`);t&&t.classList.add("active")}}let e=!1;window.addEventListener("scroll",function(){e||(window.requestAnimationFrame(function(){o(),e=!1}),e=!0)}),o()})</script><meta property="og:url" content="https://pillumina.github.io/posts/programming/cloud-computing/docker-namespace/"><meta property="og:site_name" content="CctoctoFX"><meta property="og:title" content="Docker Fundamentals: Namespace"><meta property="og:description" content="容器技术出现已经很久，只不过Docker容器平台的出现它变火了。Docker是第一个让容器能在不同机器之间移植的系统，它简化了打包应用的流程，也简化了打包应用的库和各种依赖。思考下整个OS的file system能直接被打包成一个简单的可移植的包，一开始的时候概念上还是很有趣的。
有时候我认为自己的阅读比较碎片化(short-term memory越来越少)，所以我想把之前学习容器知识的一些基础技术再整理出来，也算是给自己学习的反馈。这个基础系列从Linux Namespace开始，后续会陆续介绍比如cgroup、aufs、devicemapper等技术。
参考 Namespace in operation
Linux namespace man page
Introduction to linux namespace
什么是Namespace 简单来说，linux namespace是Linux提供的一种内核级别环境隔离的方法。在早期的Unix中，提供了一种叫做chroot的系统调用：通过修改root目录把用户关到一个特定的目录下面。这种就是简单的隔离方式，也就是chroot内部的file system无法访问外部的内容。Linux Namespace在此基础之上，提供了对UTS、IPC、mount、network、PID、User等隔离机制。
这里可以简单举例，比如Linux的超级父进程的PID为1，如果我们可以把用户的进程空间关到某个进程分支之下，并且像chroot那样能够让下面的进程看到那个超级父进程的PID为1，而不同PID Namespace中的进程无法看到彼此，这样就能达到进程隔离。
Linux Namespace有以下的种类，供给后续参考（刚看有个印象就行）：
分类 系统调用参数 相关内核版本 Mount namespaces CLONE_NEWNS Linux 2.4.19 UTS namespaces CLONE_NEWUTS Linux 2.6.19 IPC namespaces CLONE_NEWIPC Linux 2.6.19 PID namespaces CLONE_NEWPID Linux 2.6.24 Network namespaces CLONE_NEWNET 始于Linux 2.6.24 完成于 Linux 2.6.29 User namespaces CLONE_NEWUSER 始于 Linux 2.6.23 完成于 Linux 3.8) 其主要涉及到三个系统调用：
clone()： 实现线程的系统调用，用来创建新的线程，并可通过涉及上述参数做到隔离 unshare()： 让某一个线程脱离某namespace setns(): 把某一个线程加到某namespace 如果读者你想看具体的实例，请自己man一下(关注一下自己的linux虚拟机内核)，或者google一下，我这里贴一个clone()的source code："><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-01T11:22:18+08:00"><meta property="article:modified_time" content="2021-04-01T11:22:18+08:00"><meta property="og:image" content="https://pillumina.github.io/imgs/icon_head.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://pillumina.github.io/imgs/icon_head.png"><meta name=twitter:title content="Docker Fundamentals: Namespace"><meta name=twitter:description content="容器技术出现已经很久，只不过Docker容器平台的出现它变火了。Docker是第一个让容器能在不同机器之间移植的系统，它简化了打包应用的流程，也简化了打包应用的库和各种依赖。思考下整个OS的file system能直接被打包成一个简单的可移植的包，一开始的时候概念上还是很有趣的。
有时候我认为自己的阅读比较碎片化(short-term memory越来越少)，所以我想把之前学习容器知识的一些基础技术再整理出来，也算是给自己学习的反馈。这个基础系列从Linux Namespace开始，后续会陆续介绍比如cgroup、aufs、devicemapper等技术。
参考
Namespace in operation
Linux namespace man page
Introduction to linux namespace
什么是Namespace
简单来说，linux namespace是Linux提供的一种内核级别环境隔离的方法。在早期的Unix中，提供了一种叫做chroot的系统调用：通过修改root目录把用户关到一个特定的目录下面。这种就是简单的隔离方式，也就是chroot内部的file system无法访问外部的内容。Linux Namespace在此基础之上，提供了对UTS、IPC、mount、network、PID、User等隔离机制。
这里可以简单举例，比如Linux的超级父进程的PID为1，如果我们可以把用户的进程空间关到某个进程分支之下，并且像chroot那样能够让下面的进程看到那个超级父进程的PID为1，而不同PID Namespace中的进程无法看到彼此，这样就能达到进程隔离。
Linux Namespace有以下的种类，供给后续参考（刚看有个印象就行）：

  
      
          分类
          系统调用参数
          相关内核版本
      
  
  
      
          Mount namespaces
          CLONE_NEWNS
          Linux 2.4.19
      
      
          UTS namespaces
          CLONE_NEWUTS
          Linux 2.6.19
      
      
          IPC namespaces
          CLONE_NEWIPC
          Linux 2.6.19
      
      
          PID namespaces
          CLONE_NEWPID
          Linux 2.6.24
      
      
          Network namespaces
          CLONE_NEWNET
          始于Linux 2.6.24 完成于 Linux 2.6.29
      
      
          User namespaces
          CLONE_NEWUSER
          始于 Linux 2.6.23 完成于 Linux 3.8)
      
  

其主要涉及到三个系统调用：

clone()： 实现线程的系统调用，用来创建新的线程，并可通过涉及上述参数做到隔离
unshare()： 让某一个线程脱离某namespace
setns(): 把某一个线程加到某namespace

如果读者你想看具体的实例，请自己man一下(关注一下自己的linux虚拟机内核)，或者google一下，我这里贴一个clone()的source code："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://pillumina.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming","item":"https://pillumina.github.io/posts/programming/"},{"@type":"ListItem","position":3,"name":"Kubernetes \u0026 Docker","item":"https://pillumina.github.io/posts/programming/cloud-computing/"},{"@type":"ListItem","position":4,"name":"Docker Fundamentals: Namespace","item":"https://pillumina.github.io/posts/programming/cloud-computing/docker-namespace/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker Fundamentals: Namespace","name":"Docker Fundamentals: Namespace","description":"容器技术出现已经很久，只不过Docker容器平台的出现它变火了。Docker是第一个让容器能在不同机器之间移植的系统，它简化了打包应用的流程，也简化了打包应用的库和各种依赖。思考下整个OS的file system能直接被打包成一个简单的可移植的包，一开始的时候概念上还是很有趣的。\n有时候我认为自己的阅读比较碎片化(short-term memory越来越少)，所以我想把之前学习容器知识的一些基础技术再整理出来，也算是给自己学习的反馈。这个基础系列从Linux Namespace开始，后续会陆续介绍比如cgroup、aufs、devicemapper等技术。\n参考 Namespace in operation\nLinux namespace man page\nIntroduction to linux namespace\n什么是Namespace 简单来说，linux namespace是Linux提供的一种内核级别环境隔离的方法。在早期的Unix中，提供了一种叫做chroot的系统调用：通过修改root目录把用户关到一个特定的目录下面。这种就是简单的隔离方式，也就是chroot内部的file system无法访问外部的内容。Linux Namespace在此基础之上，提供了对UTS、IPC、mount、network、PID、User等隔离机制。\n这里可以简单举例，比如Linux的超级父进程的PID为1，如果我们可以把用户的进程空间关到某个进程分支之下，并且像chroot那样能够让下面的进程看到那个超级父进程的PID为1，而不同PID Namespace中的进程无法看到彼此，这样就能达到进程隔离。\nLinux Namespace有以下的种类，供给后续参考（刚看有个印象就行）：\n分类 系统调用参数 相关内核版本 Mount namespaces CLONE_NEWNS Linux 2.4.19 UTS namespaces CLONE_NEWUTS Linux 2.6.19 IPC namespaces CLONE_NEWIPC Linux 2.6.19 PID namespaces CLONE_NEWPID Linux 2.6.24 Network namespaces CLONE_NEWNET 始于Linux 2.6.24 完成于 Linux 2.6.29 User namespaces CLONE_NEWUSER 始于 Linux 2.6.23 完成于 Linux 3.8) 其主要涉及到三个系统调用：\nclone()： 实现线程的系统调用，用来创建新的线程，并可通过涉及上述参数做到隔离 unshare()： 让某一个线程脱离某namespace setns(): 把某一个线程加到某namespace 如果读者你想看具体的实例，请自己man一下(关注一下自己的linux虚拟机内核)，或者google一下，我这里贴一个clone()的source code：\n","keywords":[],"articleBody":"容器技术出现已经很久，只不过Docker容器平台的出现它变火了。Docker是第一个让容器能在不同机器之间移植的系统，它简化了打包应用的流程，也简化了打包应用的库和各种依赖。思考下整个OS的file system能直接被打包成一个简单的可移植的包，一开始的时候概念上还是很有趣的。\n有时候我认为自己的阅读比较碎片化(short-term memory越来越少)，所以我想把之前学习容器知识的一些基础技术再整理出来，也算是给自己学习的反馈。这个基础系列从Linux Namespace开始，后续会陆续介绍比如cgroup、aufs、devicemapper等技术。\n参考 Namespace in operation\nLinux namespace man page\nIntroduction to linux namespace\n什么是Namespace 简单来说，linux namespace是Linux提供的一种内核级别环境隔离的方法。在早期的Unix中，提供了一种叫做chroot的系统调用：通过修改root目录把用户关到一个特定的目录下面。这种就是简单的隔离方式，也就是chroot内部的file system无法访问外部的内容。Linux Namespace在此基础之上，提供了对UTS、IPC、mount、network、PID、User等隔离机制。\n这里可以简单举例，比如Linux的超级父进程的PID为1，如果我们可以把用户的进程空间关到某个进程分支之下，并且像chroot那样能够让下面的进程看到那个超级父进程的PID为1，而不同PID Namespace中的进程无法看到彼此，这样就能达到进程隔离。\nLinux Namespace有以下的种类，供给后续参考（刚看有个印象就行）：\n分类 系统调用参数 相关内核版本 Mount namespaces CLONE_NEWNS Linux 2.4.19 UTS namespaces CLONE_NEWUTS Linux 2.6.19 IPC namespaces CLONE_NEWIPC Linux 2.6.19 PID namespaces CLONE_NEWPID Linux 2.6.24 Network namespaces CLONE_NEWNET 始于Linux 2.6.24 完成于 Linux 2.6.29 User namespaces CLONE_NEWUSER 始于 Linux 2.6.23 完成于 Linux 3.8) 其主要涉及到三个系统调用：\nclone()： 实现线程的系统调用，用来创建新的线程，并可通过涉及上述参数做到隔离 unshare()： 让某一个线程脱离某namespace setns(): 把某一个线程加到某namespace 如果读者你想看具体的实例，请自己man一下(关注一下自己的linux虚拟机内核)，或者google一下，我这里贴一个clone()的source code：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #define _GNU_SOURCE #include #include #include #include #include #include /* 定义一个给 clone 用的栈，栈大小1M */ #define STACK_SIZE (1024 * 1024) static char container_stack[STACK_SIZE]; char* const container_args[] = { \"/bin/bash\", NULL }; int container_main(void* arg) { printf(\"Container - inside the container!\\n\"); /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */ execv(container_args[0], container_args); printf(\"Something's wrong!\\n\"); return 1; } int main() { printf(\"Parent - start a container!\\n\"); /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */ int container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, NULL); /* 等待子进程结束 */ waitpid(container_pid, NULL, 0); printf(\"Parent - container stopped!\\n\"); return 0; } 上面的程序注释写的比较明白，和pthreads差不多。不过这个程序里，父子进程的进程空间没有什么区别，父进程能访问到的明显子进程也能访问。\n我们用几个例子来看看linux的namespace到底是啥样的，运行的虚拟机为ubuntu14.4\nUTS Namespace 这里略去一些头文件和数据结构的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int container_main(void* arg) { printf(\"Container - inside the container!\\n\"); sethostname(\"container\",10); /* 设置hostname */ execv(container_args[0], container_args); printf(\"Something's wrong!\\n\"); return 1; } int main() { printf(\"Parent - start a container!\\n\"); int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | SIGCHLD, NULL); /*启用CLONE_NEWUTS Namespace隔离 */ waitpid(container_pid, NULL, 0); printf(\"Parent - container stopped!\\n\"); return 0; } 执行上述的c++程序，会发现子进程的hostname变为了container\n1 2 3 4 5 6 7 derios@ubuntu:~$ sudo ./uts Parent - start a container! Container - inside the container! root@container:~# hostname container root@container:~# uname -n container IPC Namespace IPC(Inter-Process Communication)，是Unix/Linux下的一种通信方式。IPC有共享内存、信号量、消息队列等方法。所以如果要隔离我们也要把IPC进行隔离。换句话说，这样可以保证只有在同一个namespace下的进程之间才能互相通信。目前我对IPC的原理没什么研究，查了查资料，IPC需要有个全局的ID，那么如果我们要做隔离，namespace肯定需要对这个全局ID进行隔离，不能和其他namespace中的进程共享。\n要启动IPC隔离，我们需要在clone时加上CLONE_NEWPIC的参数:\n1 2 int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, NULL); 我们先创建一个IPC的queue，下面的全局ID为0：\n1 2 3 4 5 6 derios@ubuntu:~$ ipcmk -Q Message queue id: 0 derios@ubuntu:~$ ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages 0xd0d56eb2 0 hchen 644 0 0 如果我们不加CLONE_NEWIPC参数运行程序，我们可以看到在子进程中还是能看到全局的IPC queue：\n1 2 3 4 5 6 7 derios@ubuntu:~$ sudo ./uts Parent - start a container! Container - inside the container! root@container:~# ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages 0xd0d56eb2 0 hchen 644 0 0 如果我们运行加上了CLONE_NEWIPC的程序，可以有如下的结果:\n1 2 3 4 5 6 root@ubuntu:~$ sudo./ipc Parent - start a container! Container - inside the container! root@container:~/linux_namespace# ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages 可见IPC已经被隔离。\nPID Namespace 我们继续修改上述的程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int container_main(void* arg) { /* 查看子进程的PID，我们可以看到其输出子进程的 pid 为 1 */ printf(\"Container [%5d] - inside the container!\\n\", getpid()); sethostname(\"container\",10); execv(container_args[0], container_args); printf(\"Something's wrong!\\n\"); return 1; } int main() { printf(\"Parent [%5d] - start a container!\\n\", getpid()); /*启用PID namespace - CLONE_NEWPID*/ int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD, NULL); waitpid(container_pid, NULL, 0); printf(\"Parent - container stopped!\\n\"); return 0; } 运行看一下，发现子进程的PID为1：\n1 2 3 4 5 derios@ubuntu:~$ sudo ./pid Parent [ 3474] - start a container! Container [ 1] - inside the container! root@container:~# echo $$ 1 这里的1有啥意义，你可能会问。其实在传统UNIX系统中，PID为1的进程地位比较特殊，指代init\n，作为所有进程的父进程，有非常多的特权（信号屏蔽etc.），此外它还会检查所有进程的状态，而且如果子进程脱离了父进程（父进程没有wait它），那么init会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建pid为1的进程，比如可以像chroot一样，把子进程的pid在容器内变为1。\n不过，很奇怪的是，**我们在子进程的shell里执行top, ps等命令，还是可以看到所有的进程。**这意味着隔离并没有完全。因为像ps, top这些命令会读取/proc文件系统，而因为/proc文件系统在父子进程里都是一样的，所以命令的回显也都是一样的。\n因此，我们还要做到对文件系统的隔离。\nMount Namespace 下面的程序，我们在启用mount namespace并在子进程中重新mount了/proc文件系统。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int container_main(void* arg) { printf(\"Container [%5d] - inside the container!\\n\", getpid()); sethostname(\"container\",10); /* 重新mount proc文件系统到 /proc下 */ system(\"mount -t proc proc /proc\"); execv(container_args[0], container_args); printf(\"Something's wrong!\\n\"); return 1; } int main() { printf(\"Parent [%5d] - start a container!\\n\", getpid()); /* 启用Mount Namespace - 增加CLONE_NEWNS参数 */ int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL); waitpid(container_pid, NULL, 0); printf(\"Parent - container stopped!\\n\"); return 0; } 执行结果如下:\n1 2 3 4 5 6 7 derioshen@ubuntu:~$ sudo ./pid.mnt Parent [ 3502] - start a container! Container [ 1] - inside the container! root@container:~# ps -elf F S UID PID PPID C PRI NI ADDR SZ WCHAN STIME TTY TIME CMD 4 S root 1 0 0 80 0 - 6917 wait 19:55 pts/2 00:00:00 /bin/bash 0 R root 14 1 0 80 0 - 5671 - 19:56 pts/2 00:00:00 ps -elf 我们看到只有2个进程了，pid=1的是我们的/bin/bash，同时再看看/proc目录，也变得比较干净:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 root@container:~# ls /proc 1 dma key-users net sysvipc 16 driver kmsg pagetypeinfo timer_list acpi execdomains kpagecount partitions timer_stats asound fb kpageflags sched_debug tty buddyinfo filesystems loadavg schedstat uptime bus fs locks scsi version cgroups interrupts mdstat self version_signature cmdline iomem meminfo slabinfo vmallocinfo consoles ioports misc softirqs vmstat cpuinfo irq modules stat zoneinfo crypto kallsyms mounts swaps devices kcore mpt sys diskstats keys mtrr sysrq-trigger 通过CLONE_NEWNS创建mount namespace以后，父进程会把自己的文件结构复制给子进程。而子进程中新的namespace中所有mount操作都只会影响自身的文件系统，不会对外界产生任何影响，这就做到了严格的隔离。\n那么我们是不是还有别的一些文件系统也要mount？答案是肯定的。\nDocker的Mount Namespace 我们可以简单搞个小的镜像，这种玩法是我google参考来的，模仿docker的mount namespace。\n首先，我们需要一个rootfs， 也就是我们需要把我们要做的镜像中的那些命令什么的copy到一个rootfs的目录下，我们模仿Linux构建如下的目录：\n1 2 derios@ubuntu:~/rootfs$ ls bin dev etc home lib lib64 mnt opt proc root run sbin sys tmp usr var 然后，我们把一些我们需要的命令copy到 rootfs/bin目录中（sh命令必需要copy进去，不然我们无法 chroot ）：\n1 2 3 4 5 6 7 8 9 10 derios@ubuntu:~/rootfs$ ls ./bin ./usr/bin ./bin: bash chown gzip less mount netstat rm tabs tee top tty cat cp hostname ln mountpoint ping sed tac test touch umount chgrp echo ip ls mv ps sh tail timeout tr uname chmod grep kill more nc pwd sleep tar toe truncate which ./usr/bin: awk env groups head id mesg sort strace tail top uniq vi wc xargs 注：你可以使用ldd命令把这些命令相关的那些so文件copy到对应的目录：\n1 2 3 4 5 6 derios@ubuntu:~/rootfs/bin$ ldd bash linux-vdso.so.1 =\u003e (0x00007fffd33fc000) libtinfo.so.5 =\u003e /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f4bd42c2000) libdl.so.2 =\u003e /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4bd40be000) libc.so.6 =\u003e /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4bd3cf8000) /lib64/ld-linux-x86-64.so.2 (0x00007f4bd4504000) 下面是我的rootfs中的一些so文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 derios@ubuntu:~/rootfs$ ls ./lib64 ./lib/x86_64-linux-gnu/ ./lib64: ld-linux-x86-64.so.2 ./lib/x86_64-linux-gnu/: libacl.so.1 libmemusage.so libnss_files-2.19.so libpython3.4m.so.1 libacl.so.1.1.0 libmount.so.1 libnss_files.so.2 libpython3.4m.so.1.0 libattr.so.1 libmount.so.1.1.0 libnss_hesiod-2.19.so libresolv-2.19.so libblkid.so.1 libm.so.6 libnss_hesiod.so.2 libresolv.so.2 libc-2.19.so libncurses.so.5 libnss_nis-2.19.so libselinux.so.1 libcap.a libncurses.so.5.9 libnss_nisplus-2.19.so libtinfo.so.5 libcap.so libncursesw.so.5 libnss_nisplus.so.2 libtinfo.so.5.9 libcap.so.2 libncursesw.so.5.9 libnss_nis.so.2 libutil-2.19.so libcap.so.2.24 libnsl-2.19.so libpcre.so.3 libutil.so.1 libc.so.6 libnsl.so.1 libprocps.so.3 libuuid.so.1 libdl-2.19.so libnss_compat-2.19.so libpthread-2.19.so libz.so.1 libdl.so.2 libnss_compat.so.2 libpthread.so.0 libgpm.so.2 libnss_dns-2.19.so libpython2.7.so.1 libm-2.19.so libnss_dns.so.2 libpython2.7.so.1.0 包括这些命令依赖的一些配置文件：\n1 2 3 derios@ubuntu:~/rootfs$ ls ./etc bash.bashrc group hostname hosts ld.so.cache nsswitch.conf passwd profile resolv.conf shadow 看到现在你可能比较懵逼，有的比较熟悉os的同学也可能会问：有的配置希望是在容器起动时给他设置的，而不是hard code在镜像中的。比如：/etc/hosts，/etc/hostname，还有DNS的/etc/resolv.conf文件。OK, 那我们在rootfs外面，我们再创建一个conf目录，把这些文件放到这个目录中:\n1 2 derios@ubuntu:~$ ls ./conf hostname hosts resolv.conf 这样，我们的父进程就可以动态地设置容器需要的这些文件的配置， 然后再把他们mount进容器，这样，容器的镜像中的配置就比较灵活了。\n接下来是程序(Google真好)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #define _GNU_SOURCE #include #include #include #include #include #include #include #define STACK_SIZE (1024 * 1024) static char container_stack[STACK_SIZE]; char* const container_args[] = { \"/bin/bash\", \"-l\", NULL }; int container_main(void* arg) { printf(\"Container [%5d] - inside the container!\\n\", getpid()); //set hostname sethostname(\"container\",10); //remount \"/proc\" to make sure the \"top\" and \"ps\" show container's information if (mount(\"proc\", \"rootfs/proc\", \"proc\", 0, NULL) !=0 ) { perror(\"proc\"); } if (mount(\"sysfs\", \"rootfs/sys\", \"sysfs\", 0, NULL)!=0) { perror(\"sys\"); } if (mount(\"none\", \"rootfs/tmp\", \"tmpfs\", 0, NULL)!=0) { perror(\"tmp\"); } if (mount(\"udev\", \"rootfs/dev\", \"devtmpfs\", 0, NULL)!=0) { perror(\"dev\"); } if (mount(\"devpts\", \"rootfs/dev/pts\", \"devpts\", 0, NULL)!=0) { perror(\"dev/pts\"); } if (mount(\"shm\", \"rootfs/dev/shm\", \"tmpfs\", 0, NULL)!=0) { perror(\"dev/shm\"); } if (mount(\"tmpfs\", \"rootfs/run\", \"tmpfs\", 0, NULL)!=0) { perror(\"run\"); } /* * 模仿Docker的从外向容器里mount相关的配置文件 * 你可以查看：/var/lib/docker/containers//目录， * 你会看到docker的这些文件的。 */ if (mount(\"conf/hosts\", \"rootfs/etc/hosts\", \"none\", MS_BIND, NULL)!=0 || mount(\"conf/hostname\", \"rootfs/etc/hostname\", \"none\", MS_BIND, NULL)!=0 || mount(\"conf/resolv.conf\", \"rootfs/etc/resolv.conf\", \"none\", MS_BIND, NULL)!=0 ) { perror(\"conf\"); } /* 模仿docker run命令中的 -v, --volume=[] 参数干的事 */ if (mount(\"/tmp/t1\", \"rootfs/mnt\", \"none\", MS_BIND, NULL)!=0) { perror(\"mnt\"); } /* chroot 隔离目录 */ if ( chdir(\"./rootfs\") != 0 || chroot(\"./\") != 0 ){ perror(\"chdir/chroot\"); } execv(container_args[0], container_args); perror(\"exec\"); printf(\"Something's wrong!\\n\"); return 1; } int main() { printf(\"Parent [%5d] - start a container!\\n\", getpid()); int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL); waitpid(container_pid, NULL, 0); printf(\"Parent - container stopped!\\n\"); return 0; } \u003c/container_id\u003e\u003c/unistd.h\u003e\u003c/signal.h\u003e\u003c/sched.h\u003e\u003c/stdio.h\u003e\u003c/sys\u003e\u003c/sys\u003e\u003c/sys\u003e sudo运行上面的程序，你会看到下面的挂载信息以及一个所谓的“镜像”：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 derios@ubuntu:~$ sudo ./mount Parent [ 4517] - start a container! Container [ 1] - inside the container! root@container:/# mount proc on /proc type proc (rw,relatime) sysfs on /sys type sysfs (rw,relatime) none on /tmp type tmpfs (rw,relatime) udev on /dev type devtmpfs (rw,relatime,size=493976k,nr_inodes=123494,mode=755) devpts on /dev/pts type devpts (rw,relatime,mode=600,ptmxmode=000) tmpfs on /run type tmpfs (rw,relatime) /dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hosts type ext4 (rw,relatime,errors=remount-ro,data=ordered) /dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hostname type ext4 (rw,relatime,errors=remount-ro,data=ordered) /dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/resolv.conf type ext4 (rw,relatime,errors=remount-ro,data=ordered) root@container:/# ls /bin /usr/bin /bin: bash chmod echo hostname less more mv ping rm sleep tail test top truncate uname cat chown grep ip ln mount nc ps sed tabs tar timeout touch tty which chgrp cp gzip kill ls mountpoint netstat pwd sh tac tee toe tr umount /usr/bin: awk env groups head id mesg sort strace tail top uniq vi wc xargs User Namespace User Namespace 主要用到了CLONE_NEWUSER参数，当我们使用这个参数以后，在内部看到的UID和GID和外部就不一样了，默认为65534。因为容器找不到其真正的UID，因此设置成了最大的UID（/proc/sys/kernel/overflowuid）。\n要把容器中的uid和真实系统的uid给映射在一起，需要修改 /proc//uid_map 和 /proc//gid_map 这两个文件。这两个文件的格式为：\nID-inside-ns ID-outside-ns length\n第一个字段ID-inside-ns表示在容器显示的UID或GID， 第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。 第三个字段表示映射的范围，一般填1，表示一一对应。 比如，把真实的uid=1000映射成容器内的uid=0\n1 2 $ cat /proc/2465/uid_map 0 1000 1 再比如下面的示例：表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形：\n1 2 $ cat /proc/$$/uid_map 0 0 4294967295 写这两个文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限（可参看Capabilities） 写入的进程必须是此user namespace的父或子的user namespace进程。 另外需要满如下条件之一：1）父进程将effective uid/gid映射到子进程的user namespace中，2）父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid。 User Namespace是以普通用户运行，但是别的Namespace需要root权限，那么，如果我要同时使用多个Namespace，该怎么办呢？一般来说，我们先用一般用户创建User Namespace，然后把这个一般用户映射成root，在容器内用root来创建其它的Namesapce。\nNetwork Namespace 在linux中，一般用ip命令创建network namespace。不过在docker源码中并没有使用ip，而是自己实现了ip命令的一些内容。在这还是用ip命令描述一下做了啥。\n首先我们来看一个图，这个图是Docker在host主机上的网络示意图\n实际上图还是有问题的，因为Docker也可以运行在虚拟机中，所以所谓的物理网卡其实也就是一个有能够路由的IP的网卡。\n图中Docker用了一个私有的网段: 172.40.1.0，此外docker还会使用10.0.0.0以及192.168.0.0两个私有网段。如果你机器的路由表配置了(占用)所有的私有网段，那么docker就会无法启动。\n启动docker以后，可以使用ip link show和ip addr show来查看目前宿主机的网络情况。这里我在minikube容器里执行了指令:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 root@minikube:/# ip link show 1: lo: mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: tunl0@NONE: mtu 1480 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ipip 0.0.0.0 brd 0.0.0.0 3: ip6tnl0@NONE: mtu 1452 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/tunnel6 :: brd :: 4: docker0: mtu 1500 qdisc noqueue state UP mode DEFAULT group default link/ether 02:42:2e:11:a4:ae brd ff:ff:ff:ff:ff:ff 6: vetha68cfee@if5: mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default link/ether 46:2d:cf:22:79:9f brd ff:ff:ff:ff:ff:ff link-netnsid 1 12: veth8b65072@if11: mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default link/ether 3e:fb:54:6d:ae:1e brd ff:ff:ff:ff:ff:ff link-netnsid 3 14: veth61918b0@if13: mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default link/ether d2:68:38:76:73:c9 brd ff:ff:ff:ff:ff:ff link-netnsid 4 18: vethd7fa219@if17: mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default link/ether 1e:14:79:68:f1:50 brd ff:ff:ff:ff:ff:ff link-netnsid 5 20: eth0@if21: mtu 1500 qdisc noqueue state UP mode DEFAULT group default link/ether 02:42:c0:a8:31:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 21: veth3b477c9@if19: mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default link/ether 7e:b1:5d:53:00:ff brd ff:ff:ff:ff:ff:ff link-netnsid 2 23: veth265059d@if22: mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default link/ether 4a:22:a4:05:79:e1 brd ff:ff:ff:ff:ff:ff link-netnsid 6 可以看到有docker0还有一些虚拟网卡。\n为了能够做成这样，我又google了一段代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ## 首先，我们先增加一个网桥lxcbr0，模仿docker0 brctl addbr lxcbr0 brctl stp lxcbr0 off ifconfig lxcbr0 192.168.10.1/24 up #为网桥设置IP地址 ## 接下来，我们要创建一个network namespace - ns1 # 增加一个namesapce 命令为 ns1 （使用ip netns add命令） ip netns add ns1 # 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令） ip netns exec ns1 ip link set dev lo up ## 然后，我们需要增加一对虚拟网卡 # 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中 ip link add veth-ns1 type veth peer name lxcbr0.1 # 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了 ip link set veth-ns1 netns ns1 # 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了） ip netns exec ns1 ip link set dev veth-ns1 name eth0 # 为容器中的网卡分配一个IP地址，并激活它 ip netns exec ns1 ifconfig eth0 192.168.10.11/24 up # 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上 brctl addif lxcbr0 lxcbr0.1 # 为容器增加一个路由规则，让容器可以访问外面的网络 ip netns exec ns1 ip route add default via 192.168.10.1 # 在/etc/netns下创建network namespce名称为ns1的目录， # 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了 mkdir -p /etc/netns/ns1 echo \"nameserver 8.8.8.8\" \u003e /etc/netns/ns1/resolv.conf 上述就是docker网络的原理，但是有几点要注意的\ndocker的resolv.conf（配置系统DNS解析器）没有采取这样的方式，而是采取类似上述mount namespace的方式 另外，docker采用进程的PID来做network namepspace的名称 我们原理了解了，甚至可以给正在运行的docker容器新增网卡:\n1 2 3 4 5 6 7 ip link add peerA type veth peer name peerB brctl addif docker0 peerA ip link set peerA up ip link set peerB netns ${container-pid} ip netns exec ${container-pid} ip link set dev peerB name eth1 ip netns exec ${container-pid} ip link set eth1 up ; ip netns exec ${container-pid} ip addr add ${ROUTEABLE_IP} dev eth1 ; 上述指令即为一个正在运行的docker容器新增一个eth1网卡，以及给了一个可以被外部访问到的IP静态IP地址。\n这种做法，需要把外部的物理网卡设置为混杂模式(Promiscuous Model)，也就是网卡接受所有流过网卡的帧(数据包)，包括那些不是发给本机的包，不验证MAC地址。这样这个eth1网卡就会向外部通过ARP地址解析协议发送自己的MAC地址，然后外部的交换机就会把这个IP地址的包转到物理网卡上。因为网卡工作在混杂模式，因此eth1就能收到相关的数据。如果发现是自己的数据，那么就接受，这样Docker容器的网络就与外部相通。\n其实不管是Docker的NAT模式，还是混杂模式都会存在性能问题。NAT很明显转发(NAT转换)就有开销，而混杂模式下，网卡收到的负载都会完全交给所有的虚拟网卡，所以想想哪怕一个网卡没有数据，也会被其他网卡的数据影响。\n因此这两种方式都不算完美，真正解决这样网络问题的是VLAN技术。因此Google的开发者为linux内核实现了一个IPVLAN驱动，基本为Docker量身定制。\nNamespace文件 整理完了linux namespace的玩法，在看一下ns的文件。\n我们再运行一遍PID Namepace篇章中的pid.mnt程序(mount proc)，然后不退出:\n1 2 3 4 $ sudo ./pid.mnt [sudo] password for derios: Parent [ 4599] - start a container! Container [ 1] - inside the container! 打开另外一个shell看一下父子进程的PID:\n1 2 derios@ubuntu:~$ pstree -p 4599 pid.mnt(4599)───bash(4600) 我们可以到proc下（/proc//ns）查看进程的各个namespace的id（内核版本需要3.8以上），下面是父进程的：\n1 2 3 4 5 6 7 8 derios@ubuntu:~$ sudo ls -l /proc/4599/ns total 0 lrwxrwxrwx 1 root root 0 4月 7 22:01 ipc -\u003e ipc:[4026531839] lrwxrwxrwx 1 root root 0 4月 7 22:01 mnt -\u003e mnt:[4026531840] lrwxrwxrwx 1 root root 0 4月 7 22:01 net -\u003e net:[4026531956] lrwxrwxrwx 1 root root 0 4月 7 22:01 pid -\u003e pid:[4026531836] lrwxrwxrwx 1 root root 0 4月 7 22:01 user -\u003e user:[4026531837] lrwxrwxrwx 1 root root 0 4月 7 22:01 uts -\u003e uts:[4026531838] 下面是子进程的:\n1 2 3 4 5 6 7 8 derios@ubuntu:~$ sudo ls -l /proc/4600/ns total 0 lrwxrwxrwx 1 root root 0 4月 7 22:01 ipc -\u003e ipc:[4026531839] lrwxrwxrwx 1 root root 0 4月 7 22:01 mnt -\u003e mnt:[4026532520] lrwxrwxrwx 1 root root 0 4月 7 22:01 net -\u003e net:[4026531956] lrwxrwxrwx 1 root root 0 4月 7 22:01 pid -\u003e pid:[4026532522] lrwxrwxrwx 1 root root 0 4月 7 22:01 user -\u003e user:[4026531837] lrwxrwxrwx 1 root root 0 4月 7 22:01 uts -\u003e uts:[4026532521] 仔细看一下区别，发现ipc, net, user为相同ID，而mnt, pid, uts都不同。如果两个进程指向的namespace编号相同，则说明它俩在同一个namespace下，否则就不在。（如果读者你想验证，docker exec -it bash到一个容器里，top找两个进程，然后cat一下proc中对应PID的ns即可）\n这些文件还有另一个作用，那就是，一旦这些文件被打开，只要其fd被占用着，那么就算PID所属的所有进程都已经结束，创建的namespace也会一直存在。比如：我们可以通过：mount –bind /proc/4600/ns/uts ~/uts 来hold这个namespace。\n我们在最开始点了一下setns系统调用，函数声明如下:\n1 int setns(int fd, int nstype); 其中第一个参数就是一个fd，也就是一个open()系统调用打开了上述文件后返回的fd，比如：\n1 2 fd = open(\"/proc/4600/ns/nts\", O_RDONLY); // 获取namespace文件描述符 setns(fd, 0); // 加入新的namespace ","wordCount":"2282","inLanguage":"en","image":"https://pillumina.github.io/imgs/icon_head.png","datePublished":"2021-04-01T11:22:18+08:00","dateModified":"2021-04-01T11:22:18+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://pillumina.github.io/posts/programming/cloud-computing/docker-namespace/"},"publisher":{"@type":"Organization","name":"CctoctoFX","logo":{"@type":"ImageObject","url":"https://pillumina.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pillumina.github.io/ accesskey=h title="CctoctoFX (Alt + H)"><img src=https://pillumina.github.io/apple-touch-icon.png alt aria-label=logo height=30>CctoctoFX</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pillumina.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://pillumina.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://pillumina.github.io/posts/aiinfra title="AI Infra"><span>AI Infra</span></a></li><li><a href=https://pillumina.github.io/posts/programming title=Programming><span>Programming</span></a></li><li><a href=https://pillumina.github.io/social title=Social><span>Social</span></a></li><li><a href=https://pillumina.github.io/open_courses title=Study><span>Study</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://pillumina.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://pillumina.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://pillumina.github.io/posts/programming/>Programming</a>&nbsp;»&nbsp;<a href=https://pillumina.github.io/posts/programming/cloud-computing/>Kubernetes & Docker</a></div><h1 class="post-title entry-hint-parent">Docker Fundamentals: Namespace</h1><div class=post-meta><span title='2021-04-01 11:22:18 +0800 CST'>April 1, 2021</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2282 words&nbsp;·&nbsp;Me</div></header><div class="toc side left"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#参考>参考</a></li><li><a href=#什么是namespace>什么是Namespace</a></li><li><a href=#uts-namespace>UTS Namespace</a></li><li><a href=#ipc-namespace>IPC Namespace</a></li><li><a href=#pid-namespace>PID Namespace</a></li><li><a href=#mount-namespace>Mount Namespace</a></li><li><a href=#docker的mount-namespace>Docker的Mount Namespace</a></li><li><a href=#user-namespace>User Namespace</a></li><li><a href=#network-namespace>Network Namespace</a></li><li><a href=#namespace文件>Namespace文件</a></li></ul></nav></div></details></div><div class=post-content><p>容器技术出现已经很久，只不过Docker容器平台的出现它变火了。Docker是第一个让容器能在不同机器之间移植的系统，它简化了打包应用的流程，也简化了打包应用的库和各种依赖。思考下整个OS的file system能直接被打包成一个简单的可移植的包，一开始的时候概念上还是很有趣的。</p><p>有时候我认为自己的阅读比较碎片化(<del>short-term memory越来越少</del>)，所以我想把之前学习容器知识的一些基础技术再整理出来，也算是给自己学习的反馈。这个基础系列从Linux Namespace开始，后续会陆续介绍比如cgroup、aufs、devicemapper等技术。</p><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><p><a href=https://lwn.net/Articles/531114/>Namespace in operation</a></p><p><a href=https://man7.org/linux/man-pages/man7/namespaces.7.html>Linux namespace man page</a></p><p><a href=https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/>Introduction to linux namespace</a></p><h2 id=什么是namespace>什么是Namespace<a hidden class=anchor aria-hidden=true href=#什么是namespace>#</a></h2><p>简单来说，linux namespace是Linux提供的一种内核级别环境隔离的方法。在早期的Unix中，提供了一种叫做chroot的系统调用：通过修改root目录把用户关到一个特定的目录下面。这种就是简单的隔离方式，也就是chroot内部的file system无法访问外部的内容。Linux Namespace在此基础之上，提供了对UTS、IPC、mount、network、PID、User等隔离机制。</p><p>这里可以简单举例，比如Linux的超级父进程的PID为1，如果我们可以把用户的进程空间关到某个进程分支之下，并且像chroot那样能够让下面的进程看到那个超级父进程的PID为1，而不同PID Namespace中的进程无法看到彼此，这样就能达到进程隔离。</p><p>Linux Namespace有以下的种类，供给后续参考（刚看有个印象就行）：</p><table><thead><tr><th style=text-align:left>分类</th><th style=text-align:left>系统调用参数</th><th style=text-align:left>相关内核版本</th></tr></thead><tbody><tr><td style=text-align:left><strong>Mount namespaces</strong></td><td style=text-align:left>CLONE_NEWNS</td><td style=text-align:left><a href=http://lwn.net/2001/0301/a/namespaces.php3>Linux 2.4.19</a></td></tr><tr><td style=text-align:left><strong>UTS namespaces</strong></td><td style=text-align:left>CLONE_NEWUTS</td><td style=text-align:left><a href=http://lwn.net/Articles/179345/>Linux 2.6.19</a></td></tr><tr><td style=text-align:left><strong>IPC namespaces</strong></td><td style=text-align:left>CLONE_NEWIPC</td><td style=text-align:left><a href=http://lwn.net/Articles/187274/>Linux 2.6.19</a></td></tr><tr><td style=text-align:left><strong>PID namespaces</strong></td><td style=text-align:left>CLONE_NEWPID</td><td style=text-align:left><a href=http://lwn.net/Articles/259217/>Linux 2.6.24</a></td></tr><tr><td style=text-align:left><strong>Network namespaces</strong></td><td style=text-align:left>CLONE_NEWNET</td><td style=text-align:left><a href=http://lwn.net/Articles/219794/>始于Linux 2.6.24 完成于 Linux 2.6.29</a></td></tr><tr><td style=text-align:left><strong>User namespaces</strong></td><td style=text-align:left>CLONE_NEWUSER</td><td style=text-align:left><a href=http://lwn.net/Articles/528078/>始于 Linux 2.6.23 完成于 Linux 3.8)</a></td></tr></tbody></table><p>其主要涉及到三个系统调用：</p><ol><li><code>clone()</code>： 实现线程的系统调用，用来创建新的线程，并可通过涉及上述参数做到隔离</li><li><code>unshare()</code>： 让某一个线程脱离某namespace</li><li><code>setns()</code>: 把某一个线程加到某namespace</li></ol><p>如果读者你想看具体的实例，请自己man一下(关注一下自己的linux虚拟机内核)，或者google一下，我这里贴一个<code>clone()</code>的source code：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#define _GNU_SOURCE
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sched.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* 定义一个给 clone 用的栈，栈大小1M */</span>
</span></span><span class=line><span class=cl><span class=cp>#define STACK_SIZE (1024 * 1024)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>static</span> <span class=kt>char</span> <span class=n>container_stack</span><span class=p>[</span><span class=n>STACK_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=n>container_args</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;/bin/bash&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nb>NULL</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>container_main</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Container - inside the container!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span>
</span></span><span class=line><span class=cl>    <span class=n>execv</span><span class=p>(</span><span class=n>container_args</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>container_args</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Something&#39;s wrong!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Parent - start a container!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>container_pid</span> <span class=o>=</span> <span class=n>clone</span><span class=p>(</span><span class=n>container_main</span><span class=p>,</span> <span class=n>container_stack</span><span class=o>+</span><span class=n>STACK_SIZE</span><span class=p>,</span> <span class=n>SIGCHLD</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 等待子进程结束 */</span>
</span></span><span class=line><span class=cl>    <span class=n>waitpid</span><span class=p>(</span><span class=n>container_pid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Parent - container stopped!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>上面的程序注释写的比较明白，和pthreads差不多。不过这个程序里，父子进程的进程空间没有什么区别，父进程能访问到的明显子进程也能访问。</p><p>我们用几个例子来看看linux的namespace到底是啥样的，运行的虚拟机为<code>ubuntu14.4</code></p><h2 id=uts-namespace>UTS Namespace<a hidden class=anchor aria-hidden=true href=#uts-namespace>#</a></h2><p>这里略去一些头文件和数据结构的定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>container_main</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Container - inside the container!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>sethostname</span><span class=p>(</span><span class=s>&#34;container&#34;</span><span class=p>,</span><span class=mi>10</span><span class=p>);</span> <span class=cm>/* 设置hostname */</span>
</span></span><span class=line><span class=cl>    <span class=n>execv</span><span class=p>(</span><span class=n>container_args</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>container_args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Something&#39;s wrong!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Parent - start a container!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>container_pid</span> <span class=o>=</span> <span class=n>clone</span><span class=p>(</span><span class=n>container_main</span><span class=p>,</span> <span class=n>container_stack</span><span class=o>+</span><span class=n>STACK_SIZE</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=n>CLONE_NEWUTS</span> <span class=o>|</span> <span class=n>SIGCHLD</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span> <span class=cm>/*启用CLONE_NEWUTS Namespace隔离 */</span>
</span></span><span class=line><span class=cl>    <span class=n>waitpid</span><span class=p>(</span><span class=n>container_pid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Parent - container stopped!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>执行上述的c++程序，会发现子进程的hostname变为了container</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~$ sudo ./uts
</span></span><span class=line><span class=cl>Parent - start a container!
</span></span><span class=line><span class=cl>Container - inside the container!
</span></span><span class=line><span class=cl>root@container:~# hostname
</span></span><span class=line><span class=cl>container
</span></span><span class=line><span class=cl>root@container:~# uname -n
</span></span><span class=line><span class=cl>container
</span></span></code></pre></td></tr></table></div></div><h2 id=ipc-namespace>IPC Namespace<a hidden class=anchor aria-hidden=true href=#ipc-namespace>#</a></h2><p>IPC(Inter-Process Communication)，是Unix/Linux下的一种通信方式。IPC有共享内存、信号量、消息队列等方法。所以如果要隔离我们也要把IPC进行隔离。换句话说，这样可以保证只有在同一个namespace下的进程之间才能互相通信。目前我对IPC的原理没什么研究，查了查资料，IPC需要有个全局的ID，那么如果我们要做隔离，namespace肯定需要对这个全局ID进行隔离，不能和其他namespace中的进程共享。</p><p>要启动IPC隔离，我们需要在<code>clone</code>时加上<code>CLONE_NEWPIC</code>的参数:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>container_pid</span> <span class=o>=</span> <span class=n>clone</span><span class=p>(</span><span class=n>container_main</span><span class=p>,</span> <span class=n>container_stack</span><span class=o>+</span><span class=n>STACK_SIZE</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=n>CLONE_NEWUTS</span> <span class=o>|</span> <span class=n>CLONE_NEWIPC</span> <span class=o>|</span> <span class=n>SIGCHLD</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>我们先创建一个IPC的queue，下面的全局ID为0：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~$ ipcmk -Q 
</span></span><span class=line><span class=cl>Message queue id: <span class=m>0</span>
</span></span><span class=line><span class=cl>derios@ubuntu:~$ ipcs -q
</span></span><span class=line><span class=cl>------ Message Queues --------
</span></span><span class=line><span class=cl>key        msqid      owner      perms      used-bytes   messages    
</span></span><span class=line><span class=cl>0xd0d56eb2 <span class=m>0</span>          hchen      <span class=m>644</span>        <span class=m>0</span>            <span class=m>0</span>
</span></span></code></pre></td></tr></table></div></div><p>如果我们不加<code>CLONE_NEWIPC</code>参数运行程序，我们可以看到在子进程中还是能看到全局的IPC queue：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~$ sudo ./uts 
</span></span><span class=line><span class=cl>Parent - start a container!
</span></span><span class=line><span class=cl>Container - inside the container!
</span></span><span class=line><span class=cl>root@container:~# ipcs -q
</span></span><span class=line><span class=cl>------ Message Queues --------
</span></span><span class=line><span class=cl>key        msqid      owner      perms      used-bytes   messages    
</span></span><span class=line><span class=cl>0xd0d56eb2 <span class=m>0</span>          hchen      <span class=m>644</span>        <span class=m>0</span>            <span class=m>0</span>
</span></span></code></pre></td></tr></table></div></div><p>如果我们运行加上了<code>CLONE_NEWIPC</code>的程序，可以有如下的结果:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>root@ubuntu:~$ sudo./ipc
</span></span><span class=line><span class=cl>Parent - start a container!
</span></span><span class=line><span class=cl>Container - inside the container!
</span></span><span class=line><span class=cl>root@container:~/linux_namespace# ipcs -q
</span></span><span class=line><span class=cl>------ Message Queues --------
</span></span><span class=line><span class=cl>key        msqid      owner      perms      used-bytes   messages
</span></span></code></pre></td></tr></table></div></div><p>可见IPC已经被隔离。</p><h2 id=pid-namespace>PID Namespace<a hidden class=anchor aria-hidden=true href=#pid-namespace>#</a></h2><p>我们继续修改上述的程序：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>container_main</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 查看子进程的PID，我们可以看到其输出子进程的 pid 为 1 */</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Container [%5d] - inside the container!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>sethostname</span><span class=p>(</span><span class=s>&#34;container&#34;</span><span class=p>,</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>execv</span><span class=p>(</span><span class=n>container_args</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>container_args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Something&#39;s wrong!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Parent [%5d] - start a container!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*启用PID namespace - CLONE_NEWPID*/</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>container_pid</span> <span class=o>=</span> <span class=n>clone</span><span class=p>(</span><span class=n>container_main</span><span class=p>,</span> <span class=n>container_stack</span><span class=o>+</span><span class=n>STACK_SIZE</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=n>CLONE_NEWUTS</span> <span class=o>|</span> <span class=n>CLONE_NEWPID</span> <span class=o>|</span> <span class=n>SIGCHLD</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=n>waitpid</span><span class=p>(</span><span class=n>container_pid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Parent - container stopped!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>运行看一下，发现子进程的PID为1：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~$ sudo ./pid
</span></span><span class=line><span class=cl>Parent <span class=o>[</span> 3474<span class=o>]</span> - start a container!
</span></span><span class=line><span class=cl>Container <span class=o>[</span> 1<span class=o>]</span> - inside the container!
</span></span><span class=line><span class=cl>root@container:~# <span class=nb>echo</span> <span class=nv>$$</span>
</span></span><span class=line><span class=cl><span class=m>1</span>
</span></span></code></pre></td></tr></table></div></div><p>这里的1有啥意义，你可能会问。其实在传统UNIX系统中，PID为1的进程地位比较特殊，指代<code>init</code></p><p>，作为所有进程的父进程，有非常多的特权（信号屏蔽etc.），此外它还会检查所有进程的状态，而且如果子进程脱离了父进程（父进程没有wait它），那么<code>init</code>会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建pid为1的进程，比如可以像chroot一样，把子进程的pid在容器内变为1。</p><p>不过，很奇怪的是，**我们在子进程的shell里执行top, ps等命令，还是可以看到所有的进程。**这意味着隔离并没有完全。因为像ps, top这些命令会读取<code>/proc</code>文件系统，而因为<code>/proc</code>文件系统在父子进程里都是一样的，所以命令的回显也都是一样的。</p><p>因此，我们还要做到<strong>对文件系统的隔离</strong>。</p><h2 id=mount-namespace>Mount Namespace<a hidden class=anchor aria-hidden=true href=#mount-namespace>#</a></h2><p>下面的程序，我们在启用mount namespace并在子进程中重新mount了<code>/proc</code>文件系统。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>container_main</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Container [%5d] - inside the container!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>sethostname</span><span class=p>(</span><span class=s>&#34;container&#34;</span><span class=p>,</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 重新mount proc文件系统到 /proc下 */</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=s>&#34;mount -t proc proc /proc&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>execv</span><span class=p>(</span><span class=n>container_args</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>container_args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Something&#39;s wrong!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Parent [%5d] - start a container!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 启用Mount Namespace - 增加CLONE_NEWNS参数 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>container_pid</span> <span class=o>=</span> <span class=n>clone</span><span class=p>(</span><span class=n>container_main</span><span class=p>,</span> <span class=n>container_stack</span><span class=o>+</span><span class=n>STACK_SIZE</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=n>CLONE_NEWUTS</span> <span class=o>|</span> <span class=n>CLONE_NEWPID</span> <span class=o>|</span> <span class=n>CLONE_NEWNS</span> <span class=o>|</span> <span class=n>SIGCHLD</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>waitpid</span><span class=p>(</span><span class=n>container_pid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Parent - container stopped!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>执行结果如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derioshen@ubuntu:~$ sudo ./pid.mnt
</span></span><span class=line><span class=cl>Parent <span class=o>[</span> 3502<span class=o>]</span> - start a container!
</span></span><span class=line><span class=cl>Container <span class=o>[</span>    1<span class=o>]</span> - inside the container!
</span></span><span class=line><span class=cl>root@container:~# ps -elf 
</span></span><span class=line><span class=cl>F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
</span></span><span class=line><span class=cl><span class=m>4</span> S root         <span class=m>1</span>     <span class=m>0</span>  <span class=m>0</span>  <span class=m>80</span>   <span class=m>0</span> -  <span class=m>6917</span> <span class=nb>wait</span>   19:55 pts/2    00:00:00 /bin/bash
</span></span><span class=line><span class=cl><span class=m>0</span> R root        <span class=m>14</span>     <span class=m>1</span>  <span class=m>0</span>  <span class=m>80</span>   <span class=m>0</span> -  <span class=m>5671</span> -      19:56 pts/2    00:00:00 ps -elf
</span></span></code></pre></td></tr></table></div></div><p>我们看到只有2个进程了，<code>pid=1</code>的是我们的<code>/bin/bash</code>，同时再看看<code>/proc</code>目录，也变得比较干净:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>root@container:~# ls /proc
</span></span><span class=line><span class=cl><span class=m>1</span>          dma          key-users   net            sysvipc
</span></span><span class=line><span class=cl><span class=m>16</span>         driver       kmsg        pagetypeinfo   timer_list
</span></span><span class=line><span class=cl>acpi       execdomains  kpagecount  partitions     timer_stats
</span></span><span class=line><span class=cl>asound     fb           kpageflags  sched_debug    tty
</span></span><span class=line><span class=cl>buddyinfo  filesystems  loadavg     schedstat      uptime
</span></span><span class=line><span class=cl>bus        fs           locks       scsi           version
</span></span><span class=line><span class=cl>cgroups    interrupts   mdstat      self           version_signature
</span></span><span class=line><span class=cl>cmdline    iomem        meminfo     slabinfo       vmallocinfo
</span></span><span class=line><span class=cl>consoles   ioports      misc        softirqs       vmstat
</span></span><span class=line><span class=cl>cpuinfo    irq          modules     stat           zoneinfo
</span></span><span class=line><span class=cl>crypto     kallsyms     mounts      swaps
</span></span><span class=line><span class=cl>devices    kcore        mpt         sys
</span></span><span class=line><span class=cl>diskstats  keys         mtrr        sysrq-trigger
</span></span></code></pre></td></tr></table></div></div><p>通过<code>CLONE_NEWNS</code>创建mount namespace以后，父进程会把自己的文件结构复制给子进程。而子进程中新的namespace中所有mount操作都只会影响自身的文件系统，不会对外界产生任何影响，这就做到了严格的隔离。</p><p>那么我们是不是还有别的一些文件系统也要mount？答案是肯定的。</p><h2 id=docker的mount-namespace>Docker的Mount Namespace<a hidden class=anchor aria-hidden=true href=#docker的mount-namespace>#</a></h2><p>我们可以简单搞个小的镜像，这种玩法是我google参考来的，模仿docker的mount namespace。</p><p>首先，我们需要一个rootfs， 也就是我们需要把我们要做的镜像中的那些命令什么的copy到一个rootfs的目录下，我们模仿Linux构建如下的目录：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~/rootfs$ ls
</span></span><span class=line><span class=cl>bin  dev  etc  home  lib  lib64  mnt  opt  proc  root  run  sbin  sys  tmp  usr  var
</span></span></code></pre></td></tr></table></div></div><p>然后，我们把一些我们需要的命令copy到 rootfs/bin目录中（sh命令必需要copy进去，不然我们无法 chroot ）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~/rootfs$ ls ./bin ./usr/bin
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>./bin:
</span></span><span class=line><span class=cl>bash   chown  gzip      less  mount       netstat  rm     tabs  tee      top       tty
</span></span><span class=line><span class=cl>cat    cp     hostname  ln    mountpoint  ping     sed    tac   <span class=nb>test</span>     touch     umount
</span></span><span class=line><span class=cl>chgrp  <span class=nb>echo</span>   ip        ls    mv          ps       sh     tail  timeout  tr        uname
</span></span><span class=line><span class=cl>chmod  grep   <span class=nb>kill</span>      more  nc          <span class=nb>pwd</span>      sleep  tar   toe      truncate  which
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>./usr/bin:
</span></span><span class=line><span class=cl>awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs
</span></span></code></pre></td></tr></table></div></div><p>注：你可以使用ldd命令把这些命令相关的那些so文件copy到对应的目录：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~/rootfs/bin$ ldd bash
</span></span><span class=line><span class=cl>  linux-vdso.so.1 <span class=o>=</span>&gt;  <span class=o>(</span>0x00007fffd33fc000<span class=o>)</span>
</span></span><span class=line><span class=cl>  libtinfo.so.5 <span class=o>=</span>&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 <span class=o>(</span>0x00007f4bd42c2000<span class=o>)</span>
</span></span><span class=line><span class=cl>  libdl.so.2 <span class=o>=</span>&gt; /lib/x86_64-linux-gnu/libdl.so.2 <span class=o>(</span>0x00007f4bd40be000<span class=o>)</span>
</span></span><span class=line><span class=cl>  libc.so.6 <span class=o>=</span>&gt; /lib/x86_64-linux-gnu/libc.so.6 <span class=o>(</span>0x00007f4bd3cf8000<span class=o>)</span>
</span></span><span class=line><span class=cl>  /lib64/ld-linux-x86-64.so.2 <span class=o>(</span>0x00007f4bd4504000<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>下面是我的rootfs中的一些so文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~/rootfs$ ls ./lib64 ./lib/x86_64-linux-gnu/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>./lib64:
</span></span><span class=line><span class=cl>ld-linux-x86-64.so.2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>./lib/x86_64-linux-gnu/:
</span></span><span class=line><span class=cl>libacl.so.1      libmemusage.so         libnss_files-2.19.so    libpython3.4m.so.1
</span></span><span class=line><span class=cl>libacl.so.1.1.0  libmount.so.1          libnss_files.so.2       libpython3.4m.so.1.0
</span></span><span class=line><span class=cl>libattr.so.1     libmount.so.1.1.0      libnss_hesiod-2.19.so   libresolv-2.19.so
</span></span><span class=line><span class=cl>libblkid.so.1    libm.so.6              libnss_hesiod.so.2      libresolv.so.2
</span></span><span class=line><span class=cl>libc-2.19.so     libncurses.so.5        libnss_nis-2.19.so      libselinux.so.1
</span></span><span class=line><span class=cl>libcap.a         libncurses.so.5.9      libnss_nisplus-2.19.so  libtinfo.so.5
</span></span><span class=line><span class=cl>libcap.so        libncursesw.so.5       libnss_nisplus.so.2     libtinfo.so.5.9
</span></span><span class=line><span class=cl>libcap.so.2      libncursesw.so.5.9     libnss_nis.so.2         libutil-2.19.so
</span></span><span class=line><span class=cl>libcap.so.2.24   libnsl-2.19.so         libpcre.so.3            libutil.so.1
</span></span><span class=line><span class=cl>libc.so.6        libnsl.so.1            libprocps.so.3          libuuid.so.1
</span></span><span class=line><span class=cl>libdl-2.19.so    libnss_compat-2.19.so  libpthread-2.19.so      libz.so.1
</span></span><span class=line><span class=cl>libdl.so.2       libnss_compat.so.2     libpthread.so.0
</span></span><span class=line><span class=cl>libgpm.so.2      libnss_dns-2.19.so     libpython2.7.so.1
</span></span><span class=line><span class=cl>libm-2.19.so     libnss_dns.so.2        libpython2.7.so.1.0
</span></span></code></pre></td></tr></table></div></div><p>包括这些命令依赖的一些配置文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~/rootfs$ ls ./etc
</span></span><span class=line><span class=cl>bash.bashrc  group  hostname  hosts  ld.so.cache  nsswitch.conf  passwd  profile  
</span></span><span class=line><span class=cl>resolv.conf  shadow
</span></span></code></pre></td></tr></table></div></div><p>看到现在你可能比较懵逼，有的比较熟悉os的同学也可能会问：有的配置希望是在容器起动时给他设置的，而不是hard code在镜像中的。比如：/etc/hosts，/etc/hostname，还有DNS的/etc/resolv.conf文件。OK, 那我们在rootfs外面，我们再创建一个conf目录，把这些文件放到这个目录中:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~$ ls ./conf
</span></span><span class=line><span class=cl>hostname     hosts     resolv.conf
</span></span></code></pre></td></tr></table></div></div><p>这样，我们的父进程就可以动态地设置容器需要的这些文件的配置， 然后再把他们mount进容器，这样，容器的镜像中的配置就比较灵活了。</p><p>接下来是程序(<del>Google真好</del>)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#define _GNU_SOURCE
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys types.h=&#34;&#34;&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys wait.h=&#34;&#34;&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys mount.h=&#34;&#34;&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sched.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define STACK_SIZE (1024 * 1024)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>char</span> <span class=n>container_stack</span><span class=p>[</span><span class=n>STACK_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=n>container_args</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;/bin/bash&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;-l&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nb>NULL</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>container_main</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Container [%5d] - inside the container!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//set hostname
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>sethostname</span><span class=p>(</span><span class=s>&#34;container&#34;</span><span class=p>,</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//remount &#34;/proc&#34; to make sure the &#34;top&#34; and &#34;ps&#34; show container&#39;s information
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>mount</span><span class=p>(</span><span class=s>&#34;proc&#34;</span><span class=p>,</span> <span class=s>&#34;rootfs/proc&#34;</span><span class=p>,</span> <span class=s>&#34;proc&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>!=</span><span class=mi>0</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;proc&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mount</span><span class=p>(</span><span class=s>&#34;sysfs&#34;</span><span class=p>,</span> <span class=s>&#34;rootfs/sys&#34;</span><span class=p>,</span> <span class=s>&#34;sysfs&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=o>!=</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;sys&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mount</span><span class=p>(</span><span class=s>&#34;none&#34;</span><span class=p>,</span> <span class=s>&#34;rootfs/tmp&#34;</span><span class=p>,</span> <span class=s>&#34;tmpfs&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=o>!=</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;tmp&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mount</span><span class=p>(</span><span class=s>&#34;udev&#34;</span><span class=p>,</span> <span class=s>&#34;rootfs/dev&#34;</span><span class=p>,</span> <span class=s>&#34;devtmpfs&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=o>!=</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;dev&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mount</span><span class=p>(</span><span class=s>&#34;devpts&#34;</span><span class=p>,</span> <span class=s>&#34;rootfs/dev/pts&#34;</span><span class=p>,</span> <span class=s>&#34;devpts&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=o>!=</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;dev/pts&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mount</span><span class=p>(</span><span class=s>&#34;shm&#34;</span><span class=p>,</span> <span class=s>&#34;rootfs/dev/shm&#34;</span><span class=p>,</span> <span class=s>&#34;tmpfs&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=o>!=</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;dev/shm&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mount</span><span class=p>(</span><span class=s>&#34;tmpfs&#34;</span><span class=p>,</span> <span class=s>&#34;rootfs/run&#34;</span><span class=p>,</span> <span class=s>&#34;tmpfs&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=o>!=</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;run&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm>     * 模仿Docker的从外向容器里mount相关的配置文件 
</span></span></span><span class=line><span class=cl><span class=cm>     * 你可以查看：/var/lib/docker/containers/&lt;container_id&gt;/目录，
</span></span></span><span class=line><span class=cl><span class=cm>     * 你会看到docker的这些文件的。
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mount</span><span class=p>(</span><span class=s>&#34;conf/hosts&#34;</span><span class=p>,</span> <span class=s>&#34;rootfs/etc/hosts&#34;</span><span class=p>,</span> <span class=s>&#34;none&#34;</span><span class=p>,</span> <span class=n>MS_BIND</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=o>!=</span><span class=mi>0</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>          <span class=n>mount</span><span class=p>(</span><span class=s>&#34;conf/hostname&#34;</span><span class=p>,</span> <span class=s>&#34;rootfs/etc/hostname&#34;</span><span class=p>,</span> <span class=s>&#34;none&#34;</span><span class=p>,</span> <span class=n>MS_BIND</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=o>!=</span><span class=mi>0</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>          <span class=n>mount</span><span class=p>(</span><span class=s>&#34;conf/resolv.conf&#34;</span><span class=p>,</span> <span class=s>&#34;rootfs/etc/resolv.conf&#34;</span><span class=p>,</span> <span class=s>&#34;none&#34;</span><span class=p>,</span> <span class=n>MS_BIND</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=o>!=</span><span class=mi>0</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;conf&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 模仿docker run命令中的 -v, --volume=[] 参数干的事 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mount</span><span class=p>(</span><span class=s>&#34;/tmp/t1&#34;</span><span class=p>,</span> <span class=s>&#34;rootfs/mnt&#34;</span><span class=p>,</span> <span class=s>&#34;none&#34;</span><span class=p>,</span> <span class=n>MS_BIND</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=o>!=</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;mnt&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* chroot 隔离目录 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span> <span class=n>chdir</span><span class=p>(</span><span class=s>&#34;./rootfs&#34;</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>chroot</span><span class=p>(</span><span class=s>&#34;./&#34;</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;chdir/chroot&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>execv</span><span class=p>(</span><span class=n>container_args</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>container_args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>perror</span><span class=p>(</span><span class=s>&#34;exec&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Something&#39;s wrong!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Parent [%5d] - start a container!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>container_pid</span> <span class=o>=</span> <span class=n>clone</span><span class=p>(</span><span class=n>container_main</span><span class=p>,</span> <span class=n>container_stack</span><span class=o>+</span><span class=n>STACK_SIZE</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=n>CLONE_NEWUTS</span> <span class=o>|</span> <span class=n>CLONE_NEWIPC</span> <span class=o>|</span> <span class=n>CLONE_NEWPID</span> <span class=o>|</span> <span class=n>CLONE_NEWNS</span> <span class=o>|</span> <span class=n>SIGCHLD</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>waitpid</span><span class=p>(</span><span class=n>container_pid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Parent - container stopped!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>&lt;/</span><span class=n>container_id</span><span class=o>&gt;&lt;/</span><span class=n>unistd</span><span class=p>.</span><span class=n>h</span><span class=o>&gt;&lt;/</span><span class=n>signal</span><span class=p>.</span><span class=n>h</span><span class=o>&gt;&lt;/</span><span class=n>sched</span><span class=p>.</span><span class=n>h</span><span class=o>&gt;&lt;/</span><span class=n>stdio</span><span class=p>.</span><span class=n>h</span><span class=o>&gt;&lt;/</span><span class=n>sys</span><span class=o>&gt;&lt;/</span><span class=n>sys</span><span class=o>&gt;&lt;/</span><span class=n>sys</span><span class=o>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>sudo运行上面的程序，你会看到下面的挂载信息以及一个所谓的“镜像”：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~$ sudo ./mount 
</span></span><span class=line><span class=cl>Parent <span class=o>[</span> 4517<span class=o>]</span> - start a container!
</span></span><span class=line><span class=cl>Container <span class=o>[</span>    1<span class=o>]</span> - inside the container!
</span></span><span class=line><span class=cl>root@container:/# mount
</span></span><span class=line><span class=cl>proc on /proc <span class=nb>type</span> proc <span class=o>(</span>rw,relatime<span class=o>)</span>
</span></span><span class=line><span class=cl>sysfs on /sys <span class=nb>type</span> sysfs <span class=o>(</span>rw,relatime<span class=o>)</span>
</span></span><span class=line><span class=cl>none on /tmp <span class=nb>type</span> tmpfs <span class=o>(</span>rw,relatime<span class=o>)</span>
</span></span><span class=line><span class=cl>udev on /dev <span class=nb>type</span> devtmpfs <span class=o>(</span>rw,relatime,size<span class=o>=</span>493976k,nr_inodes<span class=o>=</span>123494,mode<span class=o>=</span>755<span class=o>)</span>
</span></span><span class=line><span class=cl>devpts on /dev/pts <span class=nb>type</span> devpts <span class=o>(</span>rw,relatime,mode<span class=o>=</span>600,ptmxmode<span class=o>=</span>000<span class=o>)</span>
</span></span><span class=line><span class=cl>tmpfs on /run <span class=nb>type</span> tmpfs <span class=o>(</span>rw,relatime<span class=o>)</span>
</span></span><span class=line><span class=cl>/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hosts <span class=nb>type</span> ext4 <span class=o>(</span>rw,relatime,errors<span class=o>=</span>remount-ro,data<span class=o>=</span>ordered<span class=o>)</span>
</span></span><span class=line><span class=cl>/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hostname <span class=nb>type</span> ext4 <span class=o>(</span>rw,relatime,errors<span class=o>=</span>remount-ro,data<span class=o>=</span>ordered<span class=o>)</span>
</span></span><span class=line><span class=cl>/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/resolv.conf <span class=nb>type</span> ext4 <span class=o>(</span>rw,relatime,errors<span class=o>=</span>remount-ro,data<span class=o>=</span>ordered<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>root@container:/# ls /bin /usr/bin
</span></span><span class=line><span class=cl>/bin:
</span></span><span class=line><span class=cl>bash   chmod  <span class=nb>echo</span>  hostname  less  more  mv   ping  rm   sleep  tail  <span class=nb>test</span>    top   truncate  uname
</span></span><span class=line><span class=cl>cat    chown  grep  ip        ln    mount  nc   ps    sed  tabs   tar   timeout  touch  tty     which
</span></span><span class=line><span class=cl>chgrp  cp     gzip  <span class=nb>kill</span>      ls    mountpoint  netstat  <span class=nb>pwd</span>   sh   tac    tee   toe    tr   umount
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/usr/bin:
</span></span><span class=line><span class=cl>awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs
</span></span></code></pre></td></tr></table></div></div><h2 id=user-namespace>User Namespace<a hidden class=anchor aria-hidden=true href=#user-namespace>#</a></h2><p>User Namespace 主要用到了<code>CLONE_NEWUSER</code>参数，当我们使用这个参数以后，在内部看到的UID和GID和外部就不一样了，默认为65534。因为容器找不到其真正的UID，因此设置成了最大的UID（<code>/proc/sys/kernel/overflowuid</code>）。</p><p>要把容器中的uid和真实系统的uid给映射在一起，需要修改 <strong>/proc/<pid>/uid_map</strong> 和 <strong>/proc/<pid>/gid_map</strong> 这两个文件。这两个文件的格式为：</p><p><code>ID-inside-ns ID-outside-ns length</code></p><ul><li>第一个字段ID-inside-ns表示在容器显示的UID或GID，</li><li>第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。</li><li>第三个字段表示映射的范围，一般填1，表示一一对应。</li></ul><p>比如，把真实的uid=1000映射成容器内的uid=0</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ cat /proc/2465/uid_map
</span></span><span class=line><span class=cl>         <span class=m>0</span>       <span class=m>1000</span>          <span class=m>1</span>
</span></span></code></pre></td></tr></table></div></div><p>再比如下面的示例：表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ cat /proc/<span class=nv>$$</span>/uid_map
</span></span><span class=line><span class=cl>         <span class=m>0</span>          <span class=m>0</span>          <span class=m>4294967295</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>写这两个文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限（可参看<a href=http://man7.org/linux/man-pages/man7/capabilities.7.html>Capabilities</a>）</li><li>写入的进程必须是此user namespace的父或子的user namespace进程。</li><li>另外需要满如下条件之一：1）父进程将effective uid/gid映射到子进程的user namespace中，2）父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid。</li></ul><p>User Namespace是以普通用户运行，但是别的Namespace需要root权限，那么，如果我要同时使用多个Namespace，该怎么办呢？一般来说，我们先用一般用户创建User Namespace，然后把这个一般用户映射成root，在容器内用root来创建其它的Namesapce。</p><h2 id=network-namespace>Network Namespace<a hidden class=anchor aria-hidden=true href=#network-namespace>#</a></h2><p>在linux中，一般用<code>ip</code>命令创建network namespace。不过在docker源码中并没有使用<code>ip</code>，而是自己实现了ip命令的一些内容。在这还是用<code>ip</code>命令描述一下做了啥。</p><p>首先我们来看一个图，这个图是Docker在host主机上的网络示意图</p><p><img alt="host network" loading=lazy src=https://coolshell.cn/wp-content/uploads/2015/04/network.namespace.jpg data-zoomable></p><p>实际上图还是有问题的，因为Docker也可以运行在虚拟机中，所以所谓的物理网卡其实也就是一个有能够路由的IP的网卡。</p><p>图中Docker用了一个私有的网段: 172.40.1.0，此外docker还会使用10.0.0.0以及192.168.0.0两个私有网段。如果你机器的路由表配置了(占用)所有的私有网段，那么docker就会无法启动。</p><p>启动docker以后，可以使用<code>ip link show</code>和<code>ip addr show</code>来查看目前宿主机的网络情况。这里我在<code>minikube</code>容器里执行了指令:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>root@minikube:/# ip link show
</span></span><span class=line><span class=cl>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class=m>65536</span> qdisc noqueue state UNKNOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class=line><span class=cl>2: tunl0@NONE: &lt;NOARP&gt; mtu <span class=m>1480</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=cl>    link/ipip 0.0.0.0 brd 0.0.0.0
</span></span><span class=line><span class=cl>3: ip6tnl0@NONE: &lt;NOARP&gt; mtu <span class=m>1452</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=cl>    link/tunnel6 :: brd ::
</span></span><span class=line><span class=cl>4: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP mode DEFAULT group default
</span></span><span class=line><span class=cl>    link/ether 02:42:2e:11:a4:ae brd ff:ff:ff:ff:ff:ff
</span></span><span class=line><span class=cl>6: vetha68cfee@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
</span></span><span class=line><span class=cl>    link/ether 46:2d:cf:22:79:9f brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>1</span>
</span></span><span class=line><span class=cl>12: veth8b65072@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
</span></span><span class=line><span class=cl>    link/ether 3e:fb:54:6d:ae:1e brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>3</span>
</span></span><span class=line><span class=cl>14: veth61918b0@if13: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
</span></span><span class=line><span class=cl>    link/ether d2:68:38:76:73:c9 brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>4</span>
</span></span><span class=line><span class=cl>18: vethd7fa219@if17: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
</span></span><span class=line><span class=cl>    link/ether 1e:14:79:68:f1:50 brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>5</span>
</span></span><span class=line><span class=cl>20: eth0@if21: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP mode DEFAULT group default
</span></span><span class=line><span class=cl>    link/ether 02:42:c0:a8:31:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>0</span>
</span></span><span class=line><span class=cl>21: veth3b477c9@if19: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
</span></span><span class=line><span class=cl>    link/ether 7e:b1:5d:53:00:ff brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>2</span>
</span></span><span class=line><span class=cl>23: veth265059d@if22: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue master docker0 state UP mode DEFAULT group default
</span></span><span class=line><span class=cl>    link/ether 4a:22:a4:05:79:e1 brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>6</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到有<code>docker0</code>还有一些虚拟网卡。</p><p>为了能够做成这样，我又google了一段代码:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>## 首先，我们先增加一个网桥lxcbr0，模仿docker0</span>
</span></span><span class=line><span class=cl>brctl addbr lxcbr0
</span></span><span class=line><span class=cl>brctl stp lxcbr0 off
</span></span><span class=line><span class=cl>ifconfig lxcbr0 192.168.10.1/24 up <span class=c1>#为网桥设置IP地址</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## 接下来，我们要创建一个network namespace - ns1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 增加一个namesapce 命令为 ns1 （使用ip netns add命令）</span>
</span></span><span class=line><span class=cl>ip netns add ns1 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）</span>
</span></span><span class=line><span class=cl>ip netns <span class=nb>exec</span> ns1   ip link <span class=nb>set</span> dev lo up 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## 然后，我们需要增加一对虚拟网卡</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中</span>
</span></span><span class=line><span class=cl>ip link add veth-ns1 <span class=nb>type</span> veth peer name lxcbr0.1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了</span>
</span></span><span class=line><span class=cl>ip link <span class=nb>set</span> veth-ns1 netns ns1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）</span>
</span></span><span class=line><span class=cl>ip netns <span class=nb>exec</span> ns1  ip link <span class=nb>set</span> dev veth-ns1 name eth0 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 为容器中的网卡分配一个IP地址，并激活它</span>
</span></span><span class=line><span class=cl>ip netns <span class=nb>exec</span> ns1 ifconfig eth0 192.168.10.11/24 up
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上</span>
</span></span><span class=line><span class=cl>brctl addif lxcbr0 lxcbr0.1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 为容器增加一个路由规则，让容器可以访问外面的网络</span>
</span></span><span class=line><span class=cl>ip netns <span class=nb>exec</span> ns1     ip route add default via 192.168.10.1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 在/etc/netns下创建network namespce名称为ns1的目录，</span>
</span></span><span class=line><span class=cl><span class=c1># 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了</span>
</span></span><span class=line><span class=cl>mkdir -p /etc/netns/ns1
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;nameserver 8.8.8.8&#34;</span> &gt; /etc/netns/ns1/resolv.conf
</span></span></code></pre></td></tr></table></div></div><p>上述就是docker网络的原理，但是有几点要注意的</p><ol><li>docker的resolv.conf（配置系统DNS解析器）没有采取这样的方式，而是采取类似上述<code>mount namespace</code>的方式</li><li>另外，docker采用进程的PID来做network namepspace的名称</li></ol><p>我们原理了解了，甚至可以给正在运行的docker容器新增网卡:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ip link add peerA <span class=nb>type</span> veth peer name peerB 
</span></span><span class=line><span class=cl>brctl addif docker0 peerA 
</span></span><span class=line><span class=cl>ip link <span class=nb>set</span> peerA up 
</span></span><span class=line><span class=cl>ip link <span class=nb>set</span> peerB netns <span class=si>${</span><span class=nv>container</span><span class=p>-pid</span><span class=si>}</span> 
</span></span><span class=line><span class=cl>ip netns <span class=nb>exec</span> <span class=si>${</span><span class=nv>container</span><span class=p>-pid</span><span class=si>}</span> ip link <span class=nb>set</span> dev peerB name eth1 
</span></span><span class=line><span class=cl>ip netns <span class=nb>exec</span> <span class=si>${</span><span class=nv>container</span><span class=p>-pid</span><span class=si>}</span> ip link <span class=nb>set</span> eth1 up <span class=p>;</span> 
</span></span><span class=line><span class=cl>ip netns <span class=nb>exec</span> <span class=si>${</span><span class=nv>container</span><span class=p>-pid</span><span class=si>}</span> ip addr add <span class=si>${</span><span class=nv>ROUTEABLE_IP</span><span class=si>}</span> dev eth1 <span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>上述指令即为一个正在运行的docker容器新增一个<code>eth1</code>网卡，以及给了一个可以被外部访问到的IP静态IP地址。</p><p>这种做法，需要把外部的<code>物理网卡</code>设置为混杂模式(<a href=https://cloud.tencent.com/developer/article/1439013>Promiscuous Model</a>)，也就是网卡接受所有流过网卡的帧(数据包)，包括那些不是发给本机的包，不验证MAC地址。这样这个<code>eth1</code>网卡就会向外部通过<a href=https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE>ARP地址解析协议</a>发送自己的MAC地址，然后外部的交换机就会把这个IP地址的包转到<code>物理网卡</code>上。因为网卡工作在混杂模式，因此<code>eth1</code>就能收到相关的数据。如果发现是自己的数据，那么就接受，这样Docker容器的网络就与外部相通。</p><p>其实不管是Docker的NAT模式，还是混杂模式都会存在性能问题。NAT很明显转发(NAT转换)就有开销，而混杂模式下，网卡收到的负载都会完全交给所有的虚拟网卡，所以想想哪怕一个网卡没有数据，也会被其他网卡的数据影响。</p><p>因此这两种方式都不算完美，真正解决这样网络问题的是<a href=https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91>VLAN技术</a>。因此Google的开发者为linux内核实现了一个<a href=https://lwn.net/Articles/620087/>IPVLAN驱动</a>，基本为Docker量身定制。</p><h2 id=namespace文件>Namespace文件<a hidden class=anchor aria-hidden=true href=#namespace文件>#</a></h2><p>整理完了linux namespace的玩法，在看一下ns的文件。</p><p>我们再运行一遍PID Namepace篇章中的<code>pid.mnt</code>程序(mount proc)，然后不退出:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo ./pid.mnt 
</span></span><span class=line><span class=cl><span class=o>[</span>sudo<span class=o>]</span> password <span class=k>for</span> derios: 
</span></span><span class=line><span class=cl>Parent <span class=o>[</span> 4599<span class=o>]</span> - start a container!
</span></span><span class=line><span class=cl>Container <span class=o>[</span>    1<span class=o>]</span> - inside the container!
</span></span></code></pre></td></tr></table></div></div><p>打开另外一个shell看一下父子进程的PID:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~$ pstree -p <span class=m>4599</span>
</span></span><span class=line><span class=cl>pid.mnt<span class=o>(</span>4599<span class=o>)</span>───bash<span class=o>(</span>4600<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>我们可以到proc下（/proc//ns）查看进程的各个namespace的id（内核版本需要3.8以上），下面是父进程的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~$ sudo ls -l /proc/4599/ns
</span></span><span class=line><span class=cl>total <span class=m>0</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>0</span>  4月  <span class=m>7</span> 22:01 ipc -&gt; ipc:<span class=o>[</span>4026531839<span class=o>]</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>0</span>  4月  <span class=m>7</span> 22:01 mnt -&gt; mnt:<span class=o>[</span>4026531840<span class=o>]</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>0</span>  4月  <span class=m>7</span> 22:01 net -&gt; net:<span class=o>[</span>4026531956<span class=o>]</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>0</span>  4月  <span class=m>7</span> 22:01 pid -&gt; pid:<span class=o>[</span>4026531836<span class=o>]</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>0</span>  4月  <span class=m>7</span> 22:01 user -&gt; user:<span class=o>[</span>4026531837<span class=o>]</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>0</span>  4月  <span class=m>7</span> 22:01 uts -&gt; uts:<span class=o>[</span>4026531838<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>下面是子进程的:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>derios@ubuntu:~$ sudo ls -l /proc/4600/ns
</span></span><span class=line><span class=cl>total <span class=m>0</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>0</span>  4月  <span class=m>7</span> 22:01 ipc -&gt; ipc:<span class=o>[</span>4026531839<span class=o>]</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>0</span>  4月  <span class=m>7</span> 22:01 mnt -&gt; mnt:<span class=o>[</span>4026532520<span class=o>]</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>0</span>  4月  <span class=m>7</span> 22:01 net -&gt; net:<span class=o>[</span>4026531956<span class=o>]</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>0</span>  4月  <span class=m>7</span> 22:01 pid -&gt; pid:<span class=o>[</span>4026532522<span class=o>]</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>0</span>  4月  <span class=m>7</span> 22:01 user -&gt; user:<span class=o>[</span>4026531837<span class=o>]</span>
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>0</span>  4月  <span class=m>7</span> 22:01 uts -&gt; uts:<span class=o>[</span>4026532521<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>仔细看一下区别，发现ipc, net, user为相同ID，而mnt, pid, uts都不同。如果两个进程指向的namespace编号相同，则说明它俩在同一个namespace下，否则就不在。（如果读者你想验证，<code>docker exec -it &lt;container name> bash</code>到一个容器里，top找两个进程，然后cat一下proc中对应PID的ns即可）</p><p>这些文件还有另一个作用，那就是，一旦这些文件被打开，只要其fd被占用着，那么就算PID所属的所有进程都已经结束，创建的namespace也会一直存在。比如：我们可以通过：mount –bind /proc/4600/ns/uts ~/uts 来hold这个namespace。</p><p>我们在最开始点了一下<code>setns</code>系统调用，函数声明如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>setns</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>nstype</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>其中第一个参数就是一个fd，也就是一个open()系统调用打开了上述文件后返回的fd，比如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&#34;/proc/4600/ns/nts&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>  <span class=c1>// 获取namespace文件描述符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>setns</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// 加入新的namespace
</span></span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://pillumina.github.io/posts/programming/cloud-computing/docker-cgroup/><span class=title>« Prev</span><br><span>Docker Fundamentals: Cgroup</span>
</a><a class=next href=https://pillumina.github.io/posts/programming/design-pattern/go-visitor/><span class=title>Next »</span><br><span>Go编程模式：Visitor（k8s）</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Fundamentals: Namespace on x" href="https://x.com/intent/tweet/?text=Docker%20Fundamentals%3a%20Namespace&amp;url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-namespace%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Fundamentals: Namespace on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-namespace%2f&amp;title=Docker%20Fundamentals%3a%20Namespace&amp;summary=Docker%20Fundamentals%3a%20Namespace&amp;source=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-namespace%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Fundamentals: Namespace on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-namespace%2f&title=Docker%20Fundamentals%3a%20Namespace"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Fundamentals: Namespace on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-namespace%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Fundamentals: Namespace on whatsapp" href="https://api.whatsapp.com/send?text=Docker%20Fundamentals%3a%20Namespace%20-%20https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-namespace%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Fundamentals: Namespace on telegram" href="https://telegram.me/share/url?text=Docker%20Fundamentals%3a%20Namespace&amp;url=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-namespace%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Fundamentals: Namespace on ycombinator" href="https://news.ycombinator.com/submitlink?t=Docker%20Fundamentals%3a%20Namespace&u=https%3a%2f%2fpillumina.github.io%2fposts%2fprogramming%2fcloud-computing%2fdocker-namespace%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://pillumina.github.io/>CctoctoFX</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg></a><div class=reading-progress-bar></div><script src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){const t=document.querySelector(".reading-progress-bar");if(!t)return;const n=document.querySelector(".post-single");if(!n)return;function s(){const e=n.getBoundingClientRect(),s=e.height,o=window.innerHeight,i=window.scrollY||window.pageYOffset,a=i/(s-o)*100;t.style.width=`${Math.min(100,Math.max(0,a))}%`}let e=!1;window.addEventListener("scroll",function(){e||(window.requestAnimationFrame(function(){s(),e=!1}),e=!0)}),s()}),document.addEventListener("DOMContentLoaded",function(){mediumZoom("article img:not(.nozoom)",{margin:24,background:"var(--theme)",scrollOffset:0})})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>